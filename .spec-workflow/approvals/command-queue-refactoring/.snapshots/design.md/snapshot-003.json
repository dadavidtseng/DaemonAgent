{
  "id": "snapshot_1764513765860_mokky6slq",
  "approvalId": "approval_1764512739016_4b0iobjrw",
  "approvalTitle": "Design Document (Updated with JobSystem Integration)",
  "version": 3,
  "timestamp": "2025-11-30T14:42:45.860Z",
  "trigger": "revision_requested",
  "status": "pending",
  "content": "# Design Document: Unified Command Queue Architecture\r\n\r\n## Overview\r\n\r\nThis design document specifies a comprehensive refactoring of the async communication infrastructure into a unified, template-based architecture. The refactoring eliminates ~800 lines of duplicate code by extracting common SPSC (Single-Producer-Single-Consumer) queue implementation into a reusable `CommandQueueBase` template, then specializing for domain-specific queues (Render, Audio, Resource, Debug, Callback).\r\n\r\nAdditionally, this design completes the SOLID-compliant separation of Renderer and Resource modules by migrating remaining resource loading responsibilities (Shader, BitmapFont) from Renderer to Resource, ensuring each module has a single, well-defined purpose.\r\n\r\n### Design Goals\r\n1. **Eliminate Duplication**: Replace 5+ handwritten queue implementations with 1 template + 5 specializations\r\n2. **Consistent Patterns**: All async subsystems use identical command submission and callback patterns\r\n3. **Module Separation**: Complete Renderer/Resource SOLID refactoring\r\n4. **Zero Breaking Changes**: Preserve all existing C++ and JavaScript APIs\r\n5. **Visual Studio Organization**: Logical filter grouping without physical directory restructuring\r\n\r\n## Steering Document Alignment\r\n\r\n### Technical Standards (tech.md)\r\n\r\n*Note: Project does not currently have steering documents. This design follows established patterns from existing codebase:*\r\n\r\n- **Lock-Free Async Architecture**: Continues Phase 1-4 async pattern (SPSC queues, cache-line padding, acquire/release memory ordering)\r\n- **Template-Based Design**: Leverages C++ templates for code reuse (CRTP pattern)\r\n- **SOLID Principles**: Enforces Single Responsibility (Renderer vs Resource separation)\r\n- **Professional Documentation**: Maintains academic-grade documentation standards established in existing headers\r\n\r\n### Project Structure (structure.md)\r\n\r\n*Note: Project does not currently have structure steering document. This design preserves existing structure:*\r\n\r\n- **Module Organization**: Engine/{Core,Renderer,Audio,Resource}/ preserved\r\n- **Header-Only Templates**: CommandQueueBase.hpp contains full template implementation (standard C++ practice)\r\n- **Visual Studio Filters**: Logical organization via .vcxproj.filters (IDE-only), physical structure unchanged\r\n\r\n## Code Reuse Analysis\r\n\r\n### Existing Components to Leverage\r\n\r\n#### 1. **RenderCommandQueue** (`Engine/Renderer/RenderCommandQueue.hpp`)\r\n**Reuse Strategy**: Extract common implementation\r\n- Ring buffer allocation/deallocation\r\n- Atomic index management (m_head, m_tail)\r\n- Cache-line padding (`alignas(64)`)\r\n- Submit/ConsumeAll pattern\r\n- Statistics tracking (m_totalSubmitted, m_totalConsumed)\r\n\r\n**What Changes**: Becomes specialization of `CommandQueueBase<RenderCommand>`\r\n\r\n#### 2. **CallbackQueue** (`Engine/Core/CallbackQueue.hpp`)\r\n**Reuse Strategy**: Extract common implementation\r\n- Identical ring buffer pattern\r\n- Same thread safety model (SPSC)\r\n- Same memory ordering (acquire/release)\r\n\r\n**What Changes**: Becomes specialization of `CommandQueueBase<CallbackData>`\r\n\r\n#### 3. **Existing Command Structures**\r\n**Preserve As-Is**:\r\n- `RenderCommand` (Engine/Renderer/RenderCommand.hpp)\r\n- `CallbackData` (Engine/Core/CallbackQueue.hpp - extracted to separate file)\r\n\r\n**New Structures** (same pattern):\r\n- `AudioCommand` (Engine/Audio/AudioCommand.hpp)\r\n- `ResourceCommand` (Engine/Resource/ResourceCommand.hpp)\r\n- `DebugRenderCommand` (Engine/Renderer/DebugRenderCommand.hpp)\r\n\r\n#### 4. **Engine JobSystem** (`Engine/Core/JobSystem.hpp`)\r\n**Reuse Strategy**: Replace ResourceSubsystem's custom worker threads with JobSystem\r\n- **Why JobSystem**: Professional-grade job system with typed workers (JOB_TYPE_IO perfect for resource loading)\r\n- **Architecture**: Three-queue model (queued → executing → completed) with worker thread specialization\r\n- **Integration**: ResourceSubsystem submits Jobs to JobSystem instead of maintaining custom thread pool\r\n- **Benefits**:\r\n  - Eliminates duplicate worker thread implementation (~150 lines)\r\n  - Typed I/O workers prevent blocking generic computation workers\r\n  - Consistent job infrastructure across all engine systems\r\n  - Better lifecycle management (client controls job creation/deletion)\r\n- **Backward Compatibility**: Preserve `std::async` wrapper for existing C++ `LoadResourceAsync()` API\r\n\r\n### Integration Points\r\n\r\n#### 1. **ScriptSubsystem** (`Engine/Script/`)\r\n**Integration**: Optional command queue injection\r\n```cpp\r\n// If scripting enabled:\r\nresourceSubsystem->SetCommandQueue(resourceCommandQueue, callbackQueue);\r\naudioSubsystem->SetCommandQueue(audioCommandQueue, callbackQueue);\r\n\r\n// If scripting disabled:\r\n// Queues remain nullptr, systems work normally\r\n```\r\n\r\n#### 2. **Existing Script Interfaces**\r\n**Integration**: Add async methods\r\n```cpp\r\n// ResourceScriptInterface (new)\r\nScriptMethodResult ExecuteLoadTexture(ScriptArgs const& args);  // Uses ResourceCommandQueue\r\n\r\n// AudioScriptInterface (existing - add async)\r\nScriptMethodResult ExecuteLoadSound(ScriptArgs const& args);    // Uses AudioCommandQueue\r\n```\r\n\r\n#### 3. **CallbackQueue** (`Engine/Core/CallbackQueue.hpp`)\r\n**Integration**: Shared result delivery for all async operations\r\n- Audio loading callbacks\r\n- Resource loading callbacks\r\n- Entity/Camera creation callbacks (existing)\r\n\r\n## Architecture\r\n\r\n### Unified Command Queue Pattern\r\n\r\nAll queues follow identical architecture, varying only in command type (`TCommand`):\r\n\r\n```\r\n┌────────────────────────────────────────────────────┐\r\n│         CommandQueueBase<TCommand>                  │\r\n│  (Template Base Class - CRTP Pattern)               │\r\n├────────────────────────────────────────────────────┤\r\n│  • Ring buffer: TCommand* m_buffer                  │\r\n│  • Atomic indices: m_head, m_tail (cache-aligned)   │\r\n│  • Submit(command): Producer API                    │\r\n│  • ConsumeAll(processor): Consumer API              │\r\n│  • Virtual hooks: OnSubmit, OnConsume, OnQueueFull  │\r\n└────────────────────────────────────────────────────┘\r\n                          ▲\r\n                          │ Inherits\r\n         ┌────────────────┼────────────────┐\r\n         │                │                │\r\n   ┌─────▼─────┐   ┌──────▼──────┐  ┌─────▼─────┐\r\n   │ RenderCmd │   │  AudioCmd   │  │ResourceCmd│\r\n   │  Queue    │   │   Queue     │  │   Queue   │\r\n   └───────────┘   └─────────────┘  └───────────┘\r\n```\r\n\r\n### Modular Design Principles\r\n\r\n#### Single File Responsibility\r\n- **CommandQueueBase.hpp**: Template implementation only\r\n- **{Domain}Command.hpp**: Command structure definitions only\r\n- **{Domain}CommandQueue.hpp**: Queue specialization only (typically <30 lines)\r\n- **{Domain}ScriptInterface.hpp**: JavaScript bindings only\r\n\r\n#### Component Isolation\r\nEach queue is independent:\r\n```cpp\r\n// RenderCommandQueue does not know about AudioCommandQueue\r\n// AudioCommandQueue does not know about ResourceCommandQueue\r\n// All share common base template, but zero cross-dependencies\r\n```\r\n\r\n#### Service Layer Separation\r\n```\r\nJavaScript Layer (high-level)\r\n    ↓ (calls)\r\nScriptInterface Layer (bindings)\r\n    ↓ (submits)\r\nCommandQueue Layer (async transport)\r\n    ↓ (processed by)\r\nSubsystem Layer (business logic)\r\n```\r\n\r\n### Architecture Diagram\r\n\r\n```mermaid\r\ngraph TD\r\n    subgraph \"JavaScript Thread\"\r\n        JS_Render[Render Commands]\r\n        JS_Audio[Audio Commands]\r\n        JS_Resource[Resource Commands]\r\n    end\r\n\r\n    subgraph \"C++ Command Queues (SPSC Lock-Free)\"\r\n        RenderQ[RenderCommandQueue<br/>TCommand=RenderCommand]\r\n        AudioQ[AudioCommandQueue<br/>TCommand=AudioCommand]\r\n        ResourceQ[ResourceCommandQueue<br/>TCommand=ResourceCommand]\r\n\r\n        Base[CommandQueueBase Template<br/>Ring Buffer + Atomics]\r\n\r\n        RenderQ -->|Inherits| Base\r\n        AudioQ -->|Inherits| Base\r\n        ResourceQ -->|Inherits| Base\r\n    end\r\n\r\n    subgraph \"C++ Processing Threads\"\r\n        RenderThread[Main Render Thread]\r\n        AudioThread[Audio Worker Thread]\r\n        ResourceThread[Resource Worker Pool]\r\n    end\r\n\r\n    subgraph \"Callback Delivery\"\r\n        CallbackQ[CallbackQueue<br/>C++ → JavaScript]\r\n    end\r\n\r\n    JS_Render -->|Submit| RenderQ\r\n    JS_Audio -->|Submit| AudioQ\r\n    JS_Resource -->|Submit| ResourceQ\r\n\r\n    RenderQ -->|ConsumeAll| RenderThread\r\n    AudioQ -->|ConsumeAll| AudioThread\r\n    ResourceQ -->|ConsumeAll| ResourceThread\r\n\r\n    RenderThread -->|Result| CallbackQ\r\n    AudioThread -->|Result| CallbackQ\r\n    ResourceThread -->|Result| CallbackQ\r\n\r\n    CallbackQ -->|Dequeue| JS_Render\r\n\r\n    style Base fill:#e3f2fd\r\n    style RenderQ fill:#fff3e0\r\n    style AudioQ fill:#fff3e0\r\n    style ResourceQ fill:#fff3e0\r\n    style CallbackQ fill:#f3e5f5\r\n```\r\n\r\n## Components and Interfaces\r\n\r\n### Component 1: CommandQueueBase Template\r\n\r\n**File**: `Engine/Core/CommandQueueBase.hpp` (new)\r\n\r\n**Purpose**: Reusable lock-free SPSC ring buffer template for all command queues\r\n\r\n**Interfaces**:\r\n```cpp\r\ntemplate <typename TCommand>\r\nclass CommandQueueBase\r\n{\r\npublic:\r\n    // Construction\r\n    explicit CommandQueueBase(size_t capacity);\r\n    virtual ~CommandQueueBase();\r\n\r\n    // Producer API (single thread)\r\n    bool Submit(TCommand const& command);\r\n    size_t GetApproximateSize() const;\r\n\r\n    // Consumer API (single thread)\r\n    template <typename ProcessorFunc>\r\n    void ConsumeAll(ProcessorFunc&& processor);\r\n\r\n    // Monitoring\r\n    bool IsEmpty() const;\r\n    bool IsFull() const;\r\n    size_t GetCapacity() const;\r\n    uint64_t GetTotalSubmitted() const;\r\n    uint64_t GetTotalConsumed() const;\r\n\r\nprotected:\r\n    // Virtual hooks (subclass customization)\r\n    virtual void OnSubmit(TCommand const& command) {}\r\n    virtual void OnConsume(TCommand const& command) {}\r\n    virtual void OnQueueFull() {}\r\n\r\nprivate:\r\n    // Ring buffer storage\r\n    TCommand* m_buffer;\r\n    size_t m_capacity;\r\n\r\n    // Atomic indices (cache-line separated)\r\n    alignas(64) std::atomic<size_t> m_head;\r\n    alignas(64) std::atomic<size_t> m_tail;\r\n\r\n    // Statistics\r\n    std::atomic<uint64_t> m_totalSubmitted;\r\n    std::atomic<uint64_t> m_totalConsumed;\r\n\r\n    // Helper\r\n    size_t NextIndex(size_t index) const;\r\n};\r\n```\r\n\r\n**Dependencies**:\r\n- `<atomic>`, `<cstddef>`, `<cstdint>` (standard library only)\r\n- **Zero** engine-specific dependencies\r\n\r\n**Reuses**: None (foundational component)\r\n\r\n**Memory Ordering Design**:\r\n```cpp\r\n// Submit (Producer)\r\nbool Submit(TCommand const& command) {\r\n    size_t currentTail = m_tail.load(std::memory_order_relaxed);  // Producer owns tail\r\n    size_t nextTail = NextIndex(currentTail);\r\n\r\n    if (nextTail == m_head.load(std::memory_order_acquire)) {     // Sync with consumer\r\n        OnQueueFull();\r\n        return false;\r\n    }\r\n\r\n    m_buffer[currentTail] = command;                               // Write command\r\n    m_tail.store(nextTail, std::memory_order_release);             // Publish to consumer\r\n    m_totalSubmitted.fetch_add(1, std::memory_order_relaxed);      // Stats only\r\n    OnSubmit(command);\r\n    return true;\r\n}\r\n\r\n// ConsumeAll (Consumer)\r\ntemplate <typename ProcessorFunc>\r\nvoid ConsumeAll(ProcessorFunc&& processor) {\r\n    size_t currentHead = m_head.load(std::memory_order_relaxed);  // Consumer owns head\r\n    size_t currentTail = m_tail.load(std::memory_order_acquire);   // Sync with producer\r\n\r\n    while (currentHead != currentTail) {\r\n        OnConsume(m_buffer[currentHead]);\r\n        processor(m_buffer[currentHead]);                          // Process command\r\n        currentHead = NextIndex(currentHead);\r\n        m_totalConsumed.fetch_add(1, std::memory_order_relaxed);\r\n    }\r\n\r\n    m_head.store(currentHead, std::memory_order_release);          // Publish to producer\r\n}\r\n```\r\n\r\n---\r\n\r\n### Component 2: RenderCommandQueue (Refactored)\r\n\r\n**File**: `Engine/Renderer/RenderCommandQueue.hpp` (existing - minimal changes)\r\n\r\n**Purpose**: Render command submission (JavaScript → Render Thread)\r\n\r\n**Interfaces**:\r\n```cpp\r\nclass RenderCommandQueue : public CommandQueueBase<RenderCommand>\r\n{\r\npublic:\r\n    static constexpr size_t DEFAULT_CAPACITY = 1000;\r\n\r\n    explicit RenderCommandQueue(size_t capacity = DEFAULT_CAPACITY)\r\n        : CommandQueueBase<RenderCommand>(capacity) {}\r\n\r\nprotected:\r\n    void OnQueueFull() override {\r\n        // Log warning: render commands being dropped\r\n    }\r\n};\r\n```\r\n\r\n**Dependencies**:\r\n- `CommandQueueBase<RenderCommand>`\r\n- `RenderCommand` (Engine/Renderer/RenderCommand.hpp)\r\n\r\n**Reuses**: Inherits entire SPSC implementation from `CommandQueueBase`\r\n\r\n**Migration Strategy**:\r\n1. Keep existing RenderCommand.hpp unchanged\r\n2. Replace RenderCommandQueue implementation with inheritance from base\r\n3. Delete ~200 lines of duplicate ring buffer code\r\n4. Preserve all public APIs (binary compatible)\r\n\r\n---\r\n\r\n### Component 3: AudioCommandQueue (New)\r\n\r\n**File**: `Engine/Audio/AudioCommandQueue.hpp` (new)\r\n\r\n**Purpose**: Audio command submission (JavaScript → Audio Thread)\r\n\r\n**Interfaces**:\r\n```cpp\r\nclass AudioCommandQueue : public CommandQueueBase<AudioCommand>\r\n{\r\npublic:\r\n    static constexpr size_t DEFAULT_CAPACITY = 200;  // Fewer audio ops per frame\r\n\r\n    explicit AudioCommandQueue(size_t capacity = DEFAULT_CAPACITY)\r\n        : CommandQueueBase<AudioCommand>(capacity) {}\r\n\r\nprotected:\r\n    void OnSubmit(AudioCommand const& command) override {\r\n        // Optional: Log audio operations for debugging\r\n        if (command.type == AudioCommandType::LOAD_SOUND)\r\n            LOG_INFO(\"Audio: Loading %s\", command.soundPath.c_str());\r\n    }\r\n};\r\n```\r\n\r\n**Dependencies**:\r\n- `CommandQueueBase<AudioCommand>`\r\n- `AudioCommand` (Engine/Audio/AudioCommand.hpp - new)\r\n\r\n**Reuses**: Entire queue implementation from base template\r\n\r\n---\r\n\r\n### Component 4: ResourceCommandQueue (New)\r\n\r\n**File**: `Engine/Resource/ResourceCommandQueue.hpp` (new)\r\n\r\n**Purpose**: Resource loading command submission (JavaScript → Resource Worker Pool)\r\n\r\n**Interfaces**:\r\n```cpp\r\nclass ResourceCommandQueue : public CommandQueueBase<ResourceCommand>\r\n{\r\npublic:\r\n    static constexpr size_t DEFAULT_CAPACITY = 200;\r\n\r\n    explicit ResourceCommandQueue(size_t capacity = DEFAULT_CAPACITY)\r\n        : CommandQueueBase<ResourceCommand>(capacity) {}\r\n\r\nprotected:\r\n    void OnQueueFull() override {\r\n        LOG_WARNING(\"Resource queue full! Commands being dropped.\");\r\n    }\r\n};\r\n```\r\n\r\n**Dependencies**:\r\n- `CommandQueueBase<ResourceCommand>`\r\n- `ResourceCommand` (Engine/Resource/ResourceCommand.hpp - new)\r\n\r\n**Reuses**: Entire queue implementation from base template\r\n\r\n**Integration with ResourceSubsystem and JobSystem**:\r\n```cpp\r\n// ResourceSubsystem.hpp (updated)\r\nclass ResourceSubsystem {\r\npublic:\r\n    // Existing C++ API (unchanged)\r\n    template <typename T>\r\n    ResourceHandle<T> LoadResource(String const& path);\r\n\r\n    template <typename T>\r\n    std::future<ResourceHandle<T>> LoadResourceAsync(String const& path);  // Now uses JobSystem\r\n\r\n#if ENGINE_SCRIPTING_ENABLED\r\n    // New: JavaScript integration (optional)\r\n    void SetCommandQueue(ResourceCommandQueue* cmdQueue, CallbackQueue* cbQueue);\r\n    void ProcessPendingCommands();  // Called by App::Update() - submits Jobs to JobSystem\r\n#endif\r\n\r\n    // New: JobSystem integration (replaces custom worker threads)\r\n    void SetJobSystem(JobSystem* jobSystem);\r\n\r\nprivate:\r\n    // REMOVED: Custom worker thread implementation\r\n    // std::vector<std::thread> m_workerThreads;              // Deleted (JobSystem replaces)\r\n    // std::queue<std::function<void()>> m_taskQueue;         // Deleted (JobSystem replaces)\r\n    // std::mutex m_queueMutex;                               // Deleted (JobSystem handles)\r\n    // std::condition_variable m_condition;                   // Deleted (JobSystem handles)\r\n\r\n    // NEW: Dependency injection\r\n    JobSystem* m_jobSystem = nullptr;  // Required for async operations\r\n\r\n    // Optional script integration\r\n    ResourceCommandQueue* m_commandQueue = nullptr;  // Optional (nullptr if no script)\r\n    CallbackQueue* m_callbackQueue = nullptr;\r\n};\r\n```\r\n\r\n**Flow: JavaScript → ResourceCommandQueue → JobSystem → CallbackQueue**\r\n1. JavaScript calls `resource.loadTexture(path, callback)` via ScriptSubsystem\r\n2. ResourceScriptInterface submits `ResourceCommand{LOAD_TEXTURE}` to ResourceCommandQueue\r\n3. ResourceSubsystem::ProcessPendingCommands() consumes commands, creates Jobs\r\n4. Jobs submitted to JobSystem with `JOB_TYPE_IO` (I/O worker threads execute)\r\n5. Job completion triggers CallbackQueue submission with `{ callbackId, resourceId }`\r\n6. JavaScript receives callback result in next frame\r\n\r\n---\r\n\r\n### Component 5: DebugRenderCommandQueue (New, Debug-Only)\r\n\r\n**File**: `Engine/Renderer/DebugRenderCommand.hpp` (new)\r\n\r\n**Purpose**: Debug visualization command submission (JavaScript → Render Thread)\r\n\r\n**Interfaces**:\r\n```cpp\r\n#if defined(_DEBUG) || defined(DEBUG)\r\n\r\nclass DebugRenderCommandQueue : public CommandQueueBase<DebugRenderCommand>\r\n{\r\npublic:\r\n    static constexpr size_t DEFAULT_CAPACITY = 500;\r\n\r\n    explicit DebugRenderCommandQueue(size_t capacity = DEFAULT_CAPACITY)\r\n        : CommandQueueBase<DebugRenderCommand>(capacity) {}\r\n};\r\n\r\n#else\r\n\r\n// Release build: stub implementation\r\nclass DebugRenderCommandQueue {\r\npublic:\r\n    explicit DebugRenderCommandQueue(size_t = 0) {}\r\n    bool Submit(DebugRenderCommand const&) { return true; }\r\n    template <typename F> void ConsumeAll(F&&) {}\r\n};\r\n\r\n#endif\r\n```\r\n\r\n**Dependencies**:\r\n- `CommandQueueBase<DebugRenderCommand>` (DEBUG builds only)\r\n- `DebugRenderCommand` (Engine/Renderer/DebugRenderCommand.hpp)\r\n\r\n**Reuses**: Entire queue implementation from base (DEBUG), stub (RELEASE)\r\n\r\n---\r\n\r\n### Component 6: JobSystem Integration for Resource Loading\r\n\r\n**Files**:\r\n- `Engine/Core/JobSystem.hpp` (existing - reused)\r\n- `Engine/Resource/ResourceLoadJob.hpp` (new)\r\n\r\n**Purpose**: Replace ResourceSubsystem's custom worker threads with professional JobSystem architecture\r\n\r\n**Why JobSystem Over Custom Threads?**\r\n\r\n| Aspect | Custom Worker Threads (Current) | JobSystem (Proposed) |\r\n|--------|--------------------------------|---------------------|\r\n| **Worker Specialization** | No specialization | `JOB_TYPE_IO` workers dedicated to I/O operations |\r\n| **Code Duplication** | ~150 lines duplicate implementation | Reuses existing infrastructure |\r\n| **Lifecycle Management** | Manual thread creation/destruction | Managed by JobSystem |\r\n| **Job Tracking** | Simple queue (no visibility) | Three-queue model (queued/executing/completed) |\r\n| **Integration** | ResourceSubsystem only | Shared across all engine systems |\r\n| **Performance** | Generic mutex locking | Condition variable sleeping + typed workers |\r\n\r\n**ResourceLoadJob Implementation**:\r\n```cpp\r\n// ResourceLoadJob.hpp (new)\r\n#include \"Engine/Core/Job.hpp\"\r\n#include \"Engine/Resource/ResourceSubsystem.hpp\"\r\n\r\nclass ResourceLoadJob : public Job\r\n{\r\npublic:\r\n    explicit ResourceLoadJob(ResourceCommand const& cmd, ResourceSubsystem* subsystem, CallbackQueue* callbackQueue)\r\n        : Job(JOB_TYPE_IO)  // I/O worker threads only\r\n        , m_command(cmd)\r\n        , m_subsystem(subsystem)\r\n        , m_callbackQueue(callbackQueue)\r\n    {}\r\n\r\n    void Execute() override\r\n    {\r\n        // Execute on I/O worker thread (non-blocking for generic workers)\r\n        switch (m_command.type)\r\n        {\r\n        case ResourceCommandType::LOAD_TEXTURE:\r\n        {\r\n            auto handle = m_subsystem->LoadResource<TextureResource>(m_command.path);\r\n\r\n            // Return result to JavaScript via CallbackQueue\r\n            if (m_callbackQueue && handle.IsValid())\r\n            {\r\n                CallbackData callback;\r\n                callback.callbackId = m_command.callbackId;\r\n                callback.data[\"resourceId\"] = handle.GetID();\r\n                callback.data[\"success\"] = true;\r\n                m_callbackQueue->Submit(callback);\r\n            }\r\n            break;\r\n        }\r\n        // ... other resource types\r\n        }\r\n    }\r\n\r\nprivate:\r\n    ResourceCommand m_command;\r\n    ResourceSubsystem* m_subsystem;\r\n    CallbackQueue* m_callbackQueue;\r\n};\r\n```\r\n\r\n**ResourceSubsystem Integration**:\r\n```cpp\r\n// ResourceSubsystem.cpp (updated)\r\nvoid ResourceSubsystem::ProcessPendingCommands()\r\n{\r\n#if ENGINE_SCRIPTING_ENABLED\r\n    if (!m_commandQueue || !m_jobSystem) return;\r\n\r\n    m_commandQueue->ConsumeAll([this](ResourceCommand const& cmd)\r\n    {\r\n        // Create job and submit to JobSystem (I/O workers will execute)\r\n        auto job = new ResourceLoadJob(cmd, this, m_callbackQueue);\r\n        m_jobSystem->SubmitJob(job);\r\n    });\r\n\r\n    // Retrieve completed jobs and delete them\r\n    // (Jobs manage their own callback submission)\r\n    auto completedJobs = m_jobSystem->RetrieveAllCompletedJobs();\r\n    for (Job* job : completedJobs)\r\n    {\r\n        delete job;  // Client manages job lifecycle\r\n    }\r\n#endif\r\n}\r\n```\r\n\r\n**Benefits**:\r\n1. **Eliminates Duplication**: Removes ~150 lines of worker thread code from ResourceSubsystem\r\n2. **Typed Workers**: I/O jobs don't block generic computation workers (terrain generation, etc.)\r\n3. **Consistent Pattern**: All async operations use JobSystem (resource, terrain, physics)\r\n4. **Better Lifecycle**: Three-queue model provides visibility into job states\r\n5. **Professional Grade**: Production-ready job system with proper condition variable sleeping\r\n\r\n**Migration Strategy**:\r\n- **Phase 1**: Add JobSystem dependency injection to ResourceSubsystem\r\n- **Phase 2**: Implement ResourceLoadJob class\r\n- **Phase 3**: Update `ProcessPendingCommands()` to use JobSystem\r\n- **Phase 4**: Remove custom worker thread implementation (`m_workerThreads`, `m_taskQueue`, etc.)\r\n- **Phase 5**: Preserve `std::async` wrapper for backward compatibility\r\n\r\n---\r\n\r\n## Data Models\r\n\r\n### Model 1: AudioCommand\r\n\r\n**File**: `Engine/Audio/AudioCommand.hpp` (new)\r\n\r\n```cpp\r\nenum class AudioCommandType : uint8_t {\r\n    LOAD_SOUND,\r\n    PLAY_SOUND,\r\n    STOP_SOUND,\r\n    SET_VOLUME,\r\n    UPDATE_3D_POSITION\r\n};\r\n\r\nstruct AudioCommand {\r\n    AudioCommandType type;\r\n    uint64_t callbackId;          // JavaScript callback ID\r\n    std::string soundPath;        // Path for LOAD_SOUND\r\n    uint64_t soundId;             // ID for PLAY_SOUND, STOP_SOUND, SET_VOLUME\r\n    float volume;                 // For SET_VOLUME (0.0-1.0)\r\n    Vec3 position;                // For UPDATE_3D_POSITION\r\n\r\n    // Size: ~280 bytes (string storage)\r\n};\r\n```\r\n\r\n### Model 2: ResourceCommand\r\n\r\n**File**: `Engine/Resource/ResourceCommand.hpp` (new)\r\n\r\n```cpp\r\nenum class ResourceCommandType : uint8_t {\r\n    LOAD_TEXTURE,\r\n    LOAD_MODEL,\r\n    LOAD_SHADER,\r\n    LOAD_AUDIO,\r\n    LOAD_FONT,\r\n    UNLOAD_RESOURCE\r\n};\r\n\r\nstruct ResourceCommand {\r\n    ResourceCommandType type;\r\n    uint64_t callbackId;          // JavaScript callback ID\r\n    std::string path;             // Resource file path\r\n    eResourceType resourceType;   // TEXTURE, MODEL, SHADER, AUDIO, FONT\r\n    bool async;                   // true = background load, false = priority load\r\n    int priority;                 // 0-10 (higher = load sooner)\r\n\r\n    // Size: ~280 bytes (string storage)\r\n};\r\n```\r\n\r\n### Model 3: DebugRenderCommand\r\n\r\n**File**: `Engine/Renderer/DebugRenderCommand.hpp` (new)\r\n\r\n```cpp\r\nenum class DebugRenderCommandType : uint8_t {\r\n    ADD_WORLD_LINE,\r\n    ADD_WORLD_SPHERE,\r\n    ADD_WORLD_ARROW,\r\n    ADD_BILLBOARD_TEXT,\r\n    ADD_SCREEN_TEXT,\r\n    CLEAR,\r\n    SET_VISIBLE,\r\n    SET_HIDDEN\r\n};\r\n\r\nstruct DebugRenderCommand {\r\n    DebugRenderCommandType type;\r\n\r\n    // Geometry parameters (union for memory efficiency)\r\n    union {\r\n        struct { Vec3 start, end; float radius; } line;\r\n        struct { Vec3 center; float radius; } sphere;\r\n        struct { Vec3 base, top; float radius; } arrow;\r\n        struct { char text[256]; Vec3 pos; float height; } worldText;\r\n        struct { char text[256]; Vec2 screenPos; float size; } screenText;\r\n    } params;\r\n\r\n    Rgba8 color;\r\n    float duration;\r\n    uint8_t renderMode;  // ALWAYS, USE_DEPTH, X_RAY\r\n\r\n    // Size: ~280 bytes (text buffer)\r\n};\r\n```\r\n\r\n### Model 4: CallbackData (Existing - Enhanced)\r\n\r\n**File**: `Engine/Core/CallbackData.hpp` (extracted from CallbackQueue.hpp)\r\n\r\n```cpp\r\nenum class CallbackType : uint8_t {\r\n    ENTITY_CREATED,\r\n    CAMERA_CREATED,\r\n    RESOURCE_LOADED,   // Enhanced: Add resource loading\r\n    AUDIO_LOADED,      // New: Audio loading complete\r\n    GENERIC\r\n};\r\n\r\nstruct CallbackData {\r\n    uint64_t callbackId;      // JavaScript-generated callback ID\r\n    uint64_t resultId;        // EntityID, CameraID, ResourceID, SoundID\r\n    std::string errorMessage; // Empty = success, non-empty = error description\r\n    CallbackType type;        // Type of callback\r\n\r\n    // Size: ~40 bytes\r\n};\r\n```\r\n\r\n## SOLID Module Separation: Renderer/Resource\r\n\r\n### Current State (Violates SRP)\r\n\r\n**Renderer Module** currently has:\r\n- ✅ DirectX API wrapping (correct responsibility)\r\n- ✅ Rendering pipeline (correct)\r\n- ❌ Texture file loading (`CreateTextureFromFile`) - SHOULD be in Resource\r\n- ❌ Shader file loading (`CreateOrGetShaderFromFile`) - SHOULD be in Resource\r\n- ❌ BitmapFont file loading (`CreateOrGetBitmapFontFromFile`) - SHOULD be in Resource\r\n- ❌ Resource caching (`std::vector<Texture*> m_loadedTextures`) - SHOULD be in Resource\r\n\r\n### Target State (SOLID Compliant)\r\n\r\n**Renderer Module** SHALL have ONLY:\r\n- DirectX device/context management\r\n- Shader compilation (DirectX API responsibility)\r\n- Rendering pipeline (draw calls, state management)\r\n- Viewport management\r\n\r\n**Resource Module** SHALL have ALL:\r\n- File I/O operations (`fopen`, `std::ifstream`)\r\n- Resource loading (textures, shaders, fonts, models, audio)\r\n- Resource caching (`ResourceCache`)\r\n- Lifetime management (`ResourceHandle`)\r\n\r\n### Migration Strategy\r\n\r\n#### 1. Shader Loading Migration\r\n\r\n**From**: `Renderer::CreateOrGetShaderFromFile()`\r\n**To**: `ResourceSubsystem::CreateOrGetShader<ShaderResource>()`\r\n\r\n```cpp\r\n// Phase 1: Create ShaderLoader\r\nclass ShaderLoader : public IResourceLoader {\r\n    bool CanLoad(String const& extension) const override {\r\n        return extension == \".hlsl\" || extension == \".shader\";\r\n    }\r\n\r\n    std::shared_ptr<IResource> Load(String const& path) override {\r\n        // Read shader source from file\r\n        std::string shaderSource = ReadTextFile(path);\r\n\r\n        // Create ShaderResource\r\n        auto shaderResource = std::make_shared<ShaderResource>();\r\n        shaderResource->m_path = path;\r\n        shaderResource->m_source = shaderSource;\r\n\r\n        return shaderResource;\r\n    }\r\n};\r\n\r\n// Phase 2: Renderer compiles shader bytecode from ShaderResource\r\nShader* Renderer::CompileShader(ShaderResource const& resource, eVertexType vertexType) {\r\n    // Renderer responsibility: DirectX shader compilation\r\n    // Input: shader source code (from Resource module)\r\n    // Output: compiled DirectX shader objects\r\n}\r\n```\r\n\r\n**Boundary**: Resource loads source text, Renderer compiles to DirectX bytecode\r\n\r\n#### 2. BitmapFont Loading Migration\r\n\r\n**From**: `Renderer::CreateOrGetBitmapFontFromFile()`\r\n**To**: `ResourceSubsystem::CreateOrGetBitmapFont<FontResource>()`\r\n\r\n```cpp\r\n// FontLoader reads .fnt files\r\nclass FontLoader : public IResourceLoader {\r\n    std::shared_ptr<IResource> Load(String const& path) override {\r\n        // Read font definition file\r\n        // Parse glyph metrics\r\n        // Create FontResource\r\n    }\r\n};\r\n\r\n// BitmapFont creation stays in Renderer (uses DirectX)\r\nBitmapFont* Renderer::CreateBitmapFont(FontResource const& resource) {\r\n    // Renderer responsibility: Create DirectX texture atlas\r\n    // Input: font data (from Resource module)\r\n    // Output: renderable BitmapFont\r\n}\r\n```\r\n\r\n#### 3. Texture Loading (Already Migrated ✅)\r\n\r\n**Status**: Texture loading already migrated to ResourceSubsystem (Phase 6)\r\n- `Renderer::CreateTextureFromFile()` removed\r\n- `ResourceSubsystem::CreateOrGetTextureFromFile()` implemented\r\n- `TextureLoader` class exists\r\n\r\n**Validation**: Ensure Renderer has ZERO texture file I/O\r\n\r\n## Error Handling\r\n\r\n### Error Scenarios\r\n\r\n#### 1. **Queue Full (Backpressure)**\r\n**Scenario**: Submit() called when queue at capacity\r\n**Handling**:\r\n```cpp\r\nbool submitted = queue->Submit(command);\r\nif (!submitted) {\r\n    LOG_WARNING(\"Queue full! Command type %d dropped\", command.type);\r\n\r\n    // Optional: Return error callback to JavaScript\r\n    CallbackData errorCallback;\r\n    errorCallback.callbackId = command.callbackId;\r\n    errorCallback.errorMessage = \"Queue full - command dropped\";\r\n    callbackQueue->Enqueue(errorCallback);\r\n}\r\n```\r\n**User Impact**: Command silently dropped, error callback to JavaScript\r\n\r\n#### 2. **Resource Loading Failure**\r\n**Scenario**: File not found, format error, memory allocation failure\r\n**Handling**:\r\n```cpp\r\nvoid ResourceSubsystem::ProcessResourceCommand(ResourceCommand const& cmd) {\r\n    std::shared_ptr<IResource> resource = LoadResourceInternal(cmd.path);\r\n\r\n    CallbackData callback;\r\n    callback.callbackId = cmd.callbackId;\r\n    callback.type = CallbackType::RESOURCE_LOADED;\r\n\r\n    if (resource) {\r\n        callback.resultId = resource->GetID();\r\n        callback.errorMessage = \"\";\r\n    } else {\r\n        callback.resultId = 0;\r\n        callback.errorMessage = \"Failed to load: \" + cmd.path;\r\n    }\r\n\r\n    m_callbackQueue->Enqueue(callback);\r\n}\r\n```\r\n**User Impact**: JavaScript callback receives error message\r\n\r\n#### 3. **Audio Loading Failure (FMOD)**\r\n**Scenario**: FMOD_Sound_Load fails (corrupted file, unsupported format)\r\n**Handling**:\r\n```cpp\r\n// Similar to resource loading - return error via callback\r\ncallback.errorMessage = \"FMOD error: \" + FMOD_ErrorString(result);\r\n```\r\n**User Impact**: JavaScript receives FMOD error description\r\n\r\n#### 4. **Callback Queue Full**\r\n**Scenario**: C++ generates callbacks faster than JavaScript consumes\r\n**Handling**:\r\n```cpp\r\nbool enqueued = callbackQueue->Enqueue(callback);\r\nif (!enqueued) {\r\n    LOG_ERROR(\"Callback queue full! JavaScript not consuming fast enough\");\r\n    // Critical: This indicates JavaScript thread is blocked or slow\r\n}\r\n```\r\n**User Impact**: JavaScript misses callback (promise never resolves)\r\n\r\n## Testing Strategy\r\n\r\n### Unit Testing\r\n\r\n#### CommandQueueBase Template\r\n```cpp\r\nTEST(CommandQueueBase, SubmitAndConsume) {\r\n    struct TestCommand { int value; };\r\n    CommandQueueBase<TestCommand> queue(10);\r\n\r\n    // Test: Submit and consume\r\n    queue.Submit({42});\r\n    int receivedValue = 0;\r\n    queue.ConsumeAll([&](TestCommand const& cmd) {\r\n        receivedValue = cmd.value;\r\n    });\r\n    EXPECT_EQ(receivedValue, 42);\r\n}\r\n\r\nTEST(CommandQueueBase, BackpressureWhenFull) {\r\n    CommandQueueBase<TestCommand> queue(2);  // Small capacity\r\n\r\n    EXPECT_TRUE(queue.Submit({1}));  // OK\r\n    EXPECT_TRUE(queue.Submit({2}));  // OK\r\n    EXPECT_FALSE(queue.Submit({3})); // Full - backpressure\r\n}\r\n\r\nTEST(CommandQueueBase, Statistics) {\r\n    CommandQueueBase<TestCommand> queue(10);\r\n    queue.Submit({1});\r\n    queue.Submit({2});\r\n\r\n    EXPECT_EQ(queue.GetTotalSubmitted(), 2);\r\n    EXPECT_EQ(queue.GetApproximateSize(), 2);\r\n}\r\n```\r\n\r\n#### Specialized Queues\r\n```cpp\r\nTEST(RenderCommandQueue, InheritanceWorks) {\r\n    RenderCommandQueue queue(100);\r\n    RenderCommand cmd{RenderCommandType::CREATE_MESH, /*...*/};\r\n\r\n    EXPECT_TRUE(queue.Submit(cmd));\r\n    EXPECT_EQ(queue.GetCapacity(), 100);\r\n}\r\n```\r\n\r\n### Integration Testing\r\n\r\n#### End-to-End JavaScript → C++ → JavaScript\r\n```javascript\r\n// JavaScript test\r\ndescribe('Resource Async Loading', () => {\r\n    it('should load texture and return resource ID', async () => {\r\n        const resourceId = await new Promise((resolve, reject) => {\r\n            resource.loadTexture('test.png', (id, error) => {\r\n                if (error) reject(error);\r\n                else resolve(id);\r\n            });\r\n        });\r\n\r\n        expect(resourceId).toBeGreaterThan(0);\r\n    });\r\n});\r\n```\r\n\r\n#### C++ Integration Test\r\n```cpp\r\nTEST(AsyncArchitecture, ResourceCommandToCallback) {\r\n    ResourceCommandQueue cmdQueue(100);\r\n    CallbackQueue cbQueue(100);\r\n    ResourceSubsystem resourceSys(config);\r\n    resourceSys.SetCommandQueue(&cmdQueue, &cbQueue);\r\n\r\n    // Submit resource command\r\n    ResourceCommand cmd;\r\n    cmd.type = ResourceCommandType::LOAD_TEXTURE;\r\n    cmd.callbackId = 12345;\r\n    cmd.path = \"test.png\";\r\n    cmdQueue.Submit(cmd);\r\n\r\n    // Process (simulates worker thread)\r\n    resourceSys.ProcessPendingCommands();\r\n\r\n    // Verify callback\r\n    bool callbackReceived = false;\r\n    cbQueue.DequeueAll([&](CallbackData const& cb) {\r\n        EXPECT_EQ(cb.callbackId, 12345);\r\n        EXPECT_GT(cb.resultId, 0);\r\n        EXPECT_TRUE(cb.errorMessage.empty());\r\n        callbackReceived = true;\r\n    });\r\n\r\n    EXPECT_TRUE(callbackReceived);\r\n}\r\n```\r\n\r\n### End-to-End Testing\r\n\r\n#### User Scenarios\r\n\r\n**Scenario 1: JavaScript loads texture asynchronously**\r\n1. JavaScript calls `resource.loadTexture('player.png', callback)`\r\n2. Command submitted to ResourceCommandQueue\r\n3. Worker thread loads texture from disk\r\n4. Callback enqueued to CallbackQueue\r\n5. JavaScript receives resource ID via callback\r\n6. Verify texture renderable\r\n\r\n**Scenario 2: Audio plays during gameplay**\r\n1. JavaScript calls `audio.playSound(soundId)`\r\n2. Command submitted to AudioCommandQueue\r\n3. Audio thread triggers FMOD playback\r\n4. Verify sound audible\r\n5. Verify JavaScript continues (non-blocking)\r\n\r\n**Scenario 3: Queue backpressure handling**\r\n1. Flood queue with 1000+ commands (exceed capacity)\r\n2. Verify Submit() returns false after queue full\r\n3. Verify error callbacks to JavaScript\r\n4. Verify system remains stable (no crash)\r\n\r\n## Performance Benchmarks\r\n\r\n### Target Metrics (Must Maintain)\r\n- **Submit latency**: <0.5ms (lock-free, non-blocking)\r\n- **Consume throughput**: >10,000 commands/second\r\n- **Memory overhead**: <200 KB total for all queues\r\n- **Template instantiation**: <50 KB binary size increase\r\n\r\n### Regression Prevention\r\n- Benchmark existing RenderCommandQueue before refactoring\r\n- Benchmark refactored RenderCommandQueue after migration\r\n- Variance must be <5% (ensure template doesn't add overhead)\r\n\r\n## Visual Studio Filter Configuration\r\n\r\n### .vcxproj.filters Structure\r\n\r\n```xml\r\n<ItemGroup>\r\n  <!-- Filter Definitions -->\r\n  <Filter Include=\"Engine\\Core\\Async\">\r\n    <UniqueIdentifier>{12345678-1234-1234-1234-123456789ABC}</UniqueIdentifier>\r\n  </Filter>\r\n  <Filter Include=\"Engine\\Core\\Async\\Base\">\r\n    <UniqueIdentifier>{GENERATED-GUID-1}</UniqueIdentifier>\r\n  </Filter>\r\n  <Filter Include=\"Engine\\Core\\Async\\Commands\">\r\n    <UniqueIdentifier>{GENERATED-GUID-2}</UniqueIdentifier>\r\n  </Filter>\r\n  <Filter Include=\"Engine\\Core\\Async\\Queues\">\r\n    <UniqueIdentifier>{GENERATED-GUID-3}</UniqueIdentifier>\r\n  </Filter>\r\n</ItemGroup>\r\n\r\n<ItemGroup>\r\n  <!-- Base Template -->\r\n  <ClInclude Include=\"..\\..\\Engine\\Code\\Engine\\Core\\CommandQueueBase.hpp\">\r\n    <Filter>Engine\\Core\\Async\\Base</Filter>\r\n  </ClInclude>\r\n\r\n  <!-- Commands (logical grouping) -->\r\n  <ClInclude Include=\"..\\..\\Engine\\Code\\Engine\\Renderer\\RenderCommand.hpp\">\r\n    <Filter>Engine\\Core\\Async\\Commands</Filter>\r\n  </ClInclude>\r\n  <ClInclude Include=\"..\\..\\Engine\\Code\\Engine\\Audio\\AudioCommand.hpp\">\r\n    <Filter>Engine\\Core\\Async\\Commands</Filter>\r\n  </ClInclude>\r\n  <ClInclude Include=\"..\\..\\Engine\\Code\\Engine\\Resource\\ResourceCommand.hpp\">\r\n    <Filter>Engine\\Core\\Async\\Commands</Filter>\r\n  </ClInclude>\r\n  <ClInclude Include=\"..\\..\\Engine\\Code\\Engine\\Renderer\\DebugRenderCommand.hpp\">\r\n    <Filter>Engine\\Core\\Async\\Commands</Filter>\r\n  </ClInclude>\r\n\r\n  <!-- Queues (logical grouping) -->\r\n  <ClInclude Include=\"..\\..\\Engine\\Code\\Engine\\Renderer\\RenderCommandQueue.hpp\">\r\n    <Filter>Engine\\Core\\Async\\Queues</Filter>\r\n  </ClInclude>\r\n  <ClInclude Include=\"..\\..\\Engine\\Code\\Engine\\Audio\\AudioCommandQueue.hpp\">\r\n    <Filter>Engine\\Core\\Async\\Queues</Filter>\r\n  </ClInclude>\r\n  <ClInclude Include=\"..\\..\\Engine\\Code\\Engine\\Resource\\ResourceCommandQueue.hpp\">\r\n    <Filter>Engine\\Core\\Async\\Queues</Filter>\r\n  </ClInclude>\r\n  <ClInclude Include=\"..\\..\\Engine\\Code\\Engine\\Core\\CallbackQueue.hpp\">\r\n    <Filter>Engine\\Core\\Async\\Queues</Filter>\r\n  </ClInclude>\r\n</ItemGroup>\r\n```\r\n\r\n**Result in Solution Explorer**:\r\n```\r\nEngine\r\n└── Core\r\n    └── Async\r\n        ├── Base\r\n        │   └── CommandQueueBase.hpp\r\n        ├── Commands\r\n        │   ├── AudioCommand.hpp\r\n        │   ├── DebugRenderCommand.hpp\r\n        │   ├── RenderCommand.hpp\r\n        │   └── ResourceCommand.hpp\r\n        └── Queues\r\n            ├── AudioCommandQueue.hpp\r\n            ├── CallbackQueue.hpp\r\n            ├── RenderCommandQueue.hpp\r\n            └── ResourceCommandQueue.hpp\r\n```\r\n\r\n**Physical Directory Structure** (UNCHANGED):\r\n```\r\nEngine/\r\n├── Core/\r\n│   ├── CommandQueueBase.hpp (new)\r\n│   ├── CallbackQueue.hpp (existing)\r\n│   └── CallbackData.hpp (extracted)\r\n├── Renderer/\r\n│   ├── RenderCommand.hpp (existing)\r\n│   ├── RenderCommandQueue.hpp (refactored)\r\n│   └── DebugRenderCommand.hpp (new)\r\n├── Audio/\r\n│   ├── AudioCommand.hpp (new)\r\n│   └── AudioCommandQueue.hpp (new)\r\n└── Resource/\r\n    ├── ResourceCommand.hpp (new)\r\n    └── ResourceCommandQueue.hpp (new)\r\n```\r\n\r\n## Migration Timeline\r\n\r\n### Phase 1: Template Foundation (Week 1)\r\n- Create `CommandQueueBase.hpp`\r\n- Unit tests for template\r\n- Documentation\r\n\r\n### Phase 2: Queue Refactoring (Week 1-2)\r\n- Refactor `RenderCommandQueue` to use base\r\n- Refactor `CallbackQueue` to use base\r\n- Regression testing\r\n\r\n### Phase 3: New Queues (Week 2)\r\n- Implement `AudioCommandQueue`\r\n- Implement `ResourceCommandQueue`\r\n- Implement `DebugRenderCommandQueue`\r\n\r\n### Phase 4: SOLID Separation (Week 2-3)\r\n- Migrate Shader loading to Resource\r\n- Migrate BitmapFont loading to Resource\r\n- Remove file I/O from Renderer\r\n\r\n### Phase 5: Visual Studio Filters (Week 3)\r\n- Update `.vcxproj.filters`\r\n- Validate IDE organization\r\n\r\n### Phase 6: Integration & Testing (Week 3-4)\r\n- End-to-end testing\r\n- Performance benchmarking\r\n- Documentation updates\r\n\r\n## Success Criteria\r\n\r\n1. ✅ Zero code duplication - all queues use `CommandQueueBase`\r\n2. ✅ <5% performance variance from original implementation\r\n3. ✅ All subsystems support async JavaScript operations\r\n4. ✅ Renderer has ZERO file I/O operations\r\n5. ✅ Visual Studio shows unified Async filter hierarchy\r\n6. ✅ All existing C++ APIs unchanged (backward compatible)\r\n7. ✅ JavaScript APIs consistent across all subsystems\r\n",
  "fileStats": {
    "size": 39373,
    "lines": 1154,
    "lastModified": "2025-11-30T14:25:29.766Z"
  },
  "comments": []
}