{
  "id": "snapshot_1764518486142_xmxljc162",
  "approvalId": "approval_1764518431260_k0mhfpuym",
  "approvalTitle": "Tasks Document (Revised: Visual Rendering + README Location)",
  "version": 3,
  "timestamp": "2025-11-30T16:01:26.142Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Tasks: Unified Command Queue Architecture & SOLID Module Separation\r\n\r\n## Phase 1: Core Template Infrastructure (Foundation)\r\n\r\n- [ ] 1.1. Extract CallbackData structure to separate header file\r\n  - File: `Engine/Core/CallbackData.hpp` (new)\r\n  - Extract `CallbackData` struct and `CallbackType` enum from `CallbackQueue.hpp`\r\n  - Purpose: Prepare for template-based refactoring by separating data structures\r\n  - _Leverage: Engine/Core/CallbackQueue.hpp (existing)_\r\n  - _Requirements: Requirement 1 (Unified Command Queue Infrastructure)_\r\n  - _Prompt: Role: C++ Engine Developer specializing in header organization and forward declarations | Task: Extract CallbackData struct and CallbackType enum from CallbackQueue.hpp into a new CallbackData.hpp header file, ensuring proper include guards and forward declarations | Restrictions: Do not modify CallbackData structure, maintain exact same binary layout, preserve all comments and documentation | Success: CallbackData.hpp compiles independently, CallbackQueue.hpp includes new header, zero breaking changes to existing code, all comments preserved_\r\n\r\n- [ ] 1.2. Create CommandQueueBase template header\r\n  - File: `Engine/Core/CommandQueueBase.hpp` (new)\r\n  - Implement template class with ring buffer, atomic indices, cache-line padding\r\n  - Add Submit(), ConsumeAll(), virtual hooks (OnSubmit, OnConsume, OnQueueFull)\r\n  - Purpose: Provide reusable SPSC queue implementation for all command queues\r\n  - _Leverage: Engine/Renderer/RenderCommandQueue.hpp (extract common implementation)_\r\n  - _Requirements: Requirement 1 (Unified Command Queue Infrastructure)_\r\n  - _Prompt: Role: C++ Template Expert specializing in lock-free data structures and CRTP patterns | Task: Create CommandQueueBase template class by extracting and generalizing common SPSC ring buffer implementation from RenderCommandQueue.hpp, including atomic indices with cache-line padding (alignas(64)), Submit/ConsumeAll APIs, and virtual hooks for customization | Restrictions: Must maintain identical performance to handwritten queues, use acquire/release memory ordering for synchronization and relaxed for statistics, header-only implementation (no .cpp file), preserve all documentation from RenderCommandQueue.hpp explaining SPSC design rationale | Success: Template compiles without errors, cache-line alignment is correct (64 bytes), memory ordering is appropriate, comprehensive documentation explains lock-free SPSC pattern, virtual hooks enable customization without modifying base_\r\n\r\n- [ ] 1.3. Refactor RenderCommandQueue to use CommandQueueBase\r\n  - File: `Engine/Renderer/RenderCommandQueue.hpp` (modify existing)\r\n  - Change to inherit from `CommandQueueBase<RenderCommand>`\r\n  - Remove duplicate ring buffer implementation (~200 lines)\r\n  - Preserve existing public API (zero breaking changes)\r\n  - Purpose: Validate template works correctly, eliminate first instance of code duplication\r\n  - _Leverage: Engine/Core/CommandQueueBase.hpp (new template)_\r\n  - _Requirements: Requirement 1 (Unified Command Queue Infrastructure)_\r\n  - _Prompt: Role: C++ Refactoring Specialist with expertise in maintaining API compatibility during refactoring | Task: Refactor RenderCommandQueue to inherit from CommandQueueBase<RenderCommand>, removing duplicate ring buffer implementation while preserving exact same public API and behavior | Restrictions: Zero breaking changes to existing API, must maintain identical performance, preserve all existing documentation and comments, do not modify RenderCommand structure | Success: RenderCommandQueue compiles and links correctly, inherits all functionality from CommandQueueBase, duplicate code removed (~200 lines), existing code using RenderCommandQueue works without changes, performance benchmarks show <5% variance_\r\n\r\n- [ ] 1.4. Refactor CallbackQueue to use CommandQueueBase\r\n  - File: `Engine/Core/CallbackQueue.hpp` (modify existing)\r\n  - Change to inherit from `CommandQueueBase<CallbackData>`\r\n  - Remove duplicate ring buffer implementation (~150 lines)\r\n  - Preserve existing public API (Enqueue/Dequeue compatibility)\r\n  - Purpose: Eliminate second instance of code duplication, validate template reusability\r\n  - _Leverage: Engine/Core/CommandQueueBase.hpp (template), Engine/Core/CallbackData.hpp (new)_\r\n  - _Requirements: Requirement 1 (Unified Command Queue Infrastructure)_\r\n  - _Prompt: Role: C++ Refactoring Specialist with expertise in API compatibility and template specialization | Task: Refactor CallbackQueue to inherit from CommandQueueBase<CallbackData>, removing duplicate implementation while preserving Enqueue/Dequeue API compatibility | Restrictions: Must maintain backward compatibility with existing Enqueue/Dequeue methods, preserve exact same behavior, do not modify CallbackData structure, maintain all documentation | Success: CallbackQueue compiles correctly, Enqueue/Dequeue methods work identically to before, duplicate code removed (~150 lines), existing script interface code works without changes, performance <5% variance_\r\n\r\n## Phase 2: Audio Command Queue Implementation\r\n\r\n- [ ] 2.1. Create AudioCommand structure\r\n  - File: `Engine/Audio/AudioCommand.hpp` (new)\r\n  - Define `AudioCommandType` enum (LOAD_SOUND, PLAY_SOUND, STOP_SOUND, SET_VOLUME, UPDATE_3D_POSITION)\r\n  - Define `AudioCommand` struct with type, callbackId, soundPath, soundId, volume, position fields\r\n  - Purpose: Define command structure for JavaScript → Audio thread communication\r\n  - _Leverage: Engine/Renderer/RenderCommand.hpp (follow same pattern)_\r\n  - _Requirements: Requirement 2 (Audio Command Queue Integration)_\r\n  - _Prompt: Role: C++ Engine Developer specializing in audio systems and command pattern design | Task: Create AudioCommand.hpp defining AudioCommandType enum and AudioCommand struct following the same pattern as RenderCommand.hpp, with fields for all audio operations (load, play, stop, volume, 3D position) | Restrictions: Follow exact same code style as RenderCommand.hpp, ensure struct size ~280 bytes for cache efficiency, include comprehensive documentation for each command type, do not include FMOD headers (forward declare only if needed) | Success: AudioCommand.hpp compiles independently, struct size is appropriate (~280 bytes), all command types documented with usage examples, follows existing command pattern conventions_\r\n\r\n- [ ] 2.2. Create AudioCommandQueue class\r\n  - File: `Engine/Audio/AudioCommandQueue.hpp` (new)\r\n  - Inherit from `CommandQueueBase<AudioCommand>`\r\n  - Set DEFAULT_CAPACITY = 200 commands (~56 KB)\r\n  - Override OnQueueFull() to log warnings\r\n  - Purpose: Provide lock-free queue for audio commands from JavaScript\r\n  - _Leverage: Engine/Core/CommandQueueBase.hpp (template), Engine/Audio/AudioCommand.hpp (new)_\r\n  - _Requirements: Requirement 2 (Audio Command Queue Integration)_\r\n  - _Prompt: Role: C++ Engine Developer with expertise in lock-free queues and audio system integration | Task: Create AudioCommandQueue class inheriting from CommandQueueBase<AudioCommand> with capacity of 200 commands, overriding OnQueueFull() virtual hook to log backpressure warnings | Restrictions: Must be <30 lines of code (template does heavy lifting), follow same pattern as RenderCommandQueue, include usage examples in header comments, do not include FMOD dependencies | Success: AudioCommandQueue compiles correctly, inherits all queue functionality from template, OnQueueFull() logging works, header documentation is comprehensive with usage examples, code is concise (<30 lines)_\r\n\r\n- [ ] 2.3. Integrate AudioCommandQueue into AudioSubsystem\r\n  - File: `Engine/Audio/AudioSubsystem.hpp` and `.cpp` (modify existing)\r\n  - Add `AudioCommandQueue* m_commandQueue` member (optional, nullptr if no script)\r\n  - Add `SetCommandQueue(AudioCommandQueue*, CallbackQueue*)` method with `#if ENGINE_SCRIPTING_ENABLED`\r\n  - Add `ProcessPendingCommands()` method to consume commands in audio thread\r\n  - Purpose: Enable async audio operations from JavaScript\r\n  - _Leverage: Engine/Audio/AudioCommandQueue.hpp (new), Engine/Core/CallbackQueue.hpp (existing)_\r\n  - _Requirements: Requirement 2 (Audio Command Queue Integration)_\r\n  - _Prompt: Role: C++ Audio System Developer with expertise in FMOD integration and thread-safe command processing | Task: Integrate AudioCommandQueue into AudioSubsystem by adding optional command queue member, SetCommandQueue() method (conditional on ENGINE_SCRIPTING_ENABLED), and ProcessPendingCommands() method that consumes commands and processes them on audio thread | Restrictions: Must support compilation without script module (#if ENGINE_SCRIPTING_ENABLED), preserve existing synchronous audio API, commands must execute on audio thread only, return results via CallbackQueue | Success: AudioSubsystem compiles with and without ENGINE_SCRIPTING_ENABLED, ProcessPendingCommands() correctly processes all command types, results returned via CallbackQueue with callbackId, existing synchronous API unchanged_\r\n\r\n- [ ] 2.4. Create AudioScriptInterface for JavaScript bindings\r\n  - File: `Engine/Script/AudioScriptInterface.hpp` and `.cpp` (new or modify existing)\r\n  - Add `ExecuteLoadSound(ScriptArgs const& args)` → submits LOAD_SOUND command\r\n  - Add `ExecutePlaySound(ScriptArgs const& args)` → submits PLAY_SOUND command\r\n  - Add `ExecuteStopSound(ScriptArgs const& args)` → submits STOP_SOUND command\r\n  - Purpose: Expose async audio operations to JavaScript\r\n  - _Leverage: Engine/Script/EntityScriptInterface.hpp (follow same pattern)_\r\n  - _Requirements: Requirement 2 (Audio Command Queue Integration)_\r\n  - _Prompt: Role: C++ Script Integration Developer with expertise in V8 bindings and JavaScript interop | Task: Create or extend AudioScriptInterface to expose async audio methods (loadSound, playSound, stopSound) that submit commands to AudioCommandQueue and return immediately, following the same pattern as EntityScriptInterface | Restrictions: Must follow existing ScriptInterface pattern, validate all JavaScript arguments before submission, handle queue full gracefully, return unique callbackId to JavaScript, do not block JavaScript thread | Success: JavaScript can call audio methods asynchronously, commands submitted to queue correctly, callbackId returned immediately, queue full handled gracefully with JavaScript error, follows existing script interface conventions_\r\n\r\n## Phase 3: Resource Command Queue & JobSystem Integration\r\n\r\n- [ ] 3.1. Create ResourceCommand structure\r\n  - File: `Engine/Resource/ResourceCommand.hpp` (new)\r\n  - Define `ResourceCommandType` enum (LOAD_TEXTURE, LOAD_MODEL, LOAD_SHADER, LOAD_AUDIO, LOAD_FONT, UNLOAD_RESOURCE)\r\n  - Define `ResourceCommand` struct with type, callbackId, path, resourceType, async, priority fields\r\n  - Purpose: Define command structure for JavaScript → Resource workers communication\r\n  - _Leverage: Engine/Renderer/RenderCommand.hpp (follow same pattern)_\r\n  - _Requirements: Requirement 3 (Resource Command Queue Integration)_\r\n  - _Prompt: Role: C++ Engine Developer specializing in resource management and command pattern design | Task: Create ResourceCommand.hpp defining ResourceCommandType enum and ResourceCommand struct following RenderCommand.hpp pattern, with fields for all resource loading operations (texture, model, shader, audio, font, unload) | Restrictions: Follow exact same code style as RenderCommand.hpp, ensure struct size ~280 bytes, include comprehensive documentation for each resource type, use String type for path (project convention) | Success: ResourceCommand.hpp compiles independently, struct size appropriate (~280 bytes), all resource types documented, follows existing command pattern, priority field enables load ordering_\r\n\r\n- [ ] 3.2. Create ResourceCommandQueue class\r\n  - File: `Engine/Resource/ResourceCommandQueue.hpp` (new)\r\n  - Inherit from `CommandQueueBase<ResourceCommand>`\r\n  - Set DEFAULT_CAPACITY = 200 commands (~56 KB)\r\n  - Override OnQueueFull() to log backpressure warnings\r\n  - Purpose: Provide lock-free queue for resource loading commands from JavaScript\r\n  - _Leverage: Engine/Core/CommandQueueBase.hpp (template), Engine/Resource/ResourceCommand.hpp (new)_\r\n  - _Requirements: Requirement 3 (Resource Command Queue Integration)_\r\n  - _Prompt: Role: C++ Engine Developer with expertise in lock-free queues and resource management | Task: Create ResourceCommandQueue class inheriting from CommandQueueBase<ResourceCommand> with capacity of 200 commands, overriding OnQueueFull() for logging | Restrictions: Must be <30 lines of code, follow same pattern as AudioCommandQueue, include usage examples in header comments, do not include renderer dependencies | Success: ResourceCommandQueue compiles correctly, inherits all functionality from template, OnQueueFull() logging works, header documentation comprehensive, code concise (<30 lines)_\r\n\r\n- [ ] 3.3. Create ResourceLoadJob class for JobSystem integration\r\n  - File: `Engine/Resource/ResourceLoadJob.hpp` and `.cpp` (new)\r\n  - Inherit from `Job` with `JOB_TYPE_IO`\r\n  - Store ResourceCommand, ResourceSubsystem*, CallbackQueue* in members\r\n  - Implement Execute() to process command on I/O worker thread\r\n  - Purpose: Wrap resource commands as Jobs for JobSystem execution\r\n  - _Leverage: Engine/Core/Job.hpp (existing), Engine/Resource/ResourceCommand.hpp (new)_\r\n  - _Requirements: Requirement 3 (Resource Command Queue Integration), Component 6 (JobSystem Integration)_\r\n  - _Prompt: Role: C++ Multithreading Expert with expertise in job systems and resource loading | Task: Create ResourceLoadJob class inheriting from Job with JOB_TYPE_IO, implementing Execute() method that processes ResourceCommand on I/O worker thread and returns results via CallbackQueue | Restrictions: Must use JOB_TYPE_IO (not generic workers), handle all ResourceCommandType cases in Execute(), submit results to CallbackQueue with callbackId, handle errors gracefully without crashing, do not call DirectX on worker thread | Success: ResourceLoadJob compiles and executes correctly, all command types handled in Execute(), results returned via CallbackQueue, errors handled gracefully, runs on I/O workers only (not blocking generic workers)_\r\n\r\n- [ ] 3.4. Refactor ResourceSubsystem to use JobSystem (remove custom worker threads)\r\n  - File: `Engine/Resource/ResourceSubsystem.hpp` and `.cpp` (modify existing)\r\n  - **REMOVE**: `std::vector<std::thread> m_workerThreads`, `std::queue<std::function<void()>> m_taskQueue`, `std::mutex m_queueMutex`, `std::condition_variable m_condition`\r\n  - **ADD**: `JobSystem* m_jobSystem` member, `SetJobSystem(JobSystem*)` method\r\n  - **ADD**: `ResourceCommandQueue* m_commandQueue`, `CallbackQueue* m_callbackQueue` (optional, `#if ENGINE_SCRIPTING_ENABLED`)\r\n  - **ADD**: `ProcessPendingCommands()` method to create ResourceLoadJobs from commands\r\n  - **PRESERVE**: Existing `LoadResource<T>()` and `LoadResourceAsync<T>()` APIs unchanged\r\n  - Purpose: Replace custom worker threads with professional JobSystem architecture\r\n  - _Leverage: Engine/Core/JobSystem.hpp (existing), Engine/Resource/ResourceLoadJob.hpp (new)_\r\n  - _Requirements: Requirement 3 (Resource Command Queue Integration), Component 6 (JobSystem Integration)_\r\n  - _Prompt: Role: Senior C++ Architect with expertise in refactoring and dependency injection | Task: Refactor ResourceSubsystem to eliminate custom worker thread implementation (~150 lines) and replace with JobSystem integration, adding SetJobSystem/SetCommandQueue methods and ProcessPendingCommands() for JavaScript integration while preserving all existing C++ APIs | Restrictions: Zero breaking changes to LoadResource<T> and LoadResourceAsync<T> APIs, must compile with/without ENGINE_SCRIPTING_ENABLED, JobSystem injection required for async operations, preserve existing resource loader architecture, ensure thread safety | Success: Custom worker thread code removed (~150 lines), JobSystem integration working correctly, LoadResourceAsync() now uses JobSystem internally, ProcessPendingCommands() creates and submits ResourceLoadJobs, compiles with/without scripting, existing C++ code works without changes, performance maintained or improved_\r\n\r\n- [ ] 3.5. Create ResourceScriptInterface for JavaScript bindings\r\n  - File: `Engine/Script/ResourceScriptInterface.hpp` and `.cpp` (new or modify existing)\r\n  - Add `ExecuteLoadTexture(ScriptArgs const& args)` → submits LOAD_TEXTURE command\r\n  - Add `ExecuteLoadModel(ScriptArgs const& args)` → submits LOAD_MODEL command\r\n  - Add `ExecuteLoadShader(ScriptArgs const& args)` → submits LOAD_SHADER command\r\n  - Purpose: Expose async resource loading to JavaScript\r\n  - _Leverage: Engine/Script/EntityScriptInterface.hpp (follow same pattern)_\r\n  - _Requirements: Requirement 3 (Resource Command Queue Integration)_\r\n  - _Prompt: Role: C++ Script Integration Developer with expertise in V8 bindings and resource management | Task: Create or extend ResourceScriptInterface to expose async resource loading methods (loadTexture, loadModel, loadShader) that submit commands to ResourceCommandQueue and return immediately with callbackId | Restrictions: Must follow existing ScriptInterface pattern, validate all JavaScript arguments (path must be valid string), handle queue full gracefully, return unique callbackId, do not block JavaScript thread, do not trigger resource loading synchronously | Success: JavaScript can call resource loading methods asynchronously, commands submitted correctly, callbackId returned immediately, queue full handled with JavaScript error, follows script interface conventions, resource IDs returned via callback_\r\n\r\n## Phase 4: Debug Render Command Queue (Debug Build Only)\r\n\r\n- [ ] 4.1. Create DebugRenderCommand structure\r\n  - File: `Engine/Renderer/DebugRenderCommand.hpp` (new)\r\n  - Define `DebugRenderCommandType` enum (ADD_WORLD_LINE, ADD_WORLD_SPHERE, ADD_WORLD_ARROW, ADD_WORLD_TEXT, ADD_BILLBOARD, CLEAR_ALL)\r\n  - Define `DebugRenderCommand` struct with type, color, positions, radius, duration, text fields\r\n  - Wrap entire file in `#if defined(_DEBUG) || defined(DEBUG)` ... `#endif`\r\n  - Purpose: Define command structure for debug visualization from JavaScript\r\n  - _Leverage: Engine/Renderer/RenderCommand.hpp (follow same pattern)_\r\n  - _Requirements: Requirement 4 (Debug Render Command Queue)_\r\n  - _Prompt: Role: C++ Engine Developer specializing in debug visualization and command patterns | Task: Create DebugRenderCommand.hpp defining DebugRenderCommandType enum and DebugRenderCommand struct for all debug primitives (lines, spheres, arrows, text, billboards), wrapped in DEBUG conditional compilation | Restrictions: Entire file must be #if defined(_DEBUG), follow RenderCommand.hpp pattern, struct size ~280 bytes, include duration field for timed visualization, support multiple Vec3 positions for lines/arrows, include comprehensive documentation | Success: DebugRenderCommand.hpp compiles in DEBUG mode only, struct size appropriate (~280 bytes), all primitive types supported, duration field enables timed visualization, follows existing command pattern, compiles out in RELEASE build_\r\n\r\n- [ ] 4.2. Create DebugRenderCommandQueue class (DEBUG) and stub (RELEASE)\r\n  - File: `Engine/Renderer/DebugRenderCommandQueue.hpp` (new)\r\n  - **DEBUG**: Inherit from `CommandQueueBase<DebugRenderCommand>`, capacity = 500\r\n  - **RELEASE**: Stub implementation (empty class with no-op methods)\r\n  - Purpose: Provide debug command queue that compiles out in release builds\r\n  - _Leverage: Engine/Core/CommandQueueBase.hpp (template), Engine/Renderer/DebugRenderCommand.hpp (new)_\r\n  - _Requirements: Requirement 4 (Debug Render Command Queue)_\r\n  - _Prompt: Role: C++ Engine Developer with expertise in conditional compilation and debug systems | Task: Create DebugRenderCommandQueue with full implementation inheriting from CommandQueueBase<DebugRenderCommand> in DEBUG builds (capacity 500) and stub implementation in RELEASE builds that compiles out all overhead | Restrictions: Use #if defined(_DEBUG) for full implementation, stub must have same API signatures (Submit, ConsumeAll) but no-op, ensure zero overhead in RELEASE builds, capacity 500 commands (~140 KB in DEBUG), follow same pattern as other queues | Success: Full queue works in DEBUG builds, stub compiles in RELEASE with zero overhead, API signatures match between DEBUG/RELEASE (code calling it compiles both ways), header documentation explains DEBUG-only behavior, capacity appropriate for heavy debug usage (500 commands)_\r\n\r\n- [ ] 4.3. Integrate DebugRenderCommandQueue into Renderer (DEBUG only)\r\n  - File: `Engine/Renderer/Renderer.hpp` and `.cpp` (modify existing)\r\n  - Add `DebugRenderCommandQueue* m_debugCommandQueue` member (conditional `#if defined(_DEBUG)`)\r\n  - Add `ProcessDebugCommands()` method to consume and render debug primitives\r\n  - Add debug render pass in Render() method\r\n  - Purpose: Enable non-blocking debug visualization from JavaScript\r\n  - _Leverage: Engine/Renderer/DebugRenderCommandQueue.hpp (new)_\r\n  - _Requirements: Requirement 4 (Debug Render Command Queue)_\r\n  - _Prompt: Role: C++ Graphics Developer with expertise in debug rendering and DirectX | Task: Integrate DebugRenderCommandQueue into Renderer by adding optional queue member (DEBUG only), ProcessDebugCommands() method that consumes commands and renders debug primitives, and debug render pass in main Render() | Restrictions: All debug code must be #if defined(_DEBUG), must not impact RELEASE build performance, debug rendering should happen after main scene rendering, support all primitive types (lines, spheres, arrows, text, billboards), duration-based removal of timed debug visuals | Success: Debug queue integrated correctly in DEBUG builds, ProcessDebugCommands() renders all primitive types, timed visualizations removed after duration expires, zero overhead in RELEASE builds, debug rendering doesn't interfere with main rendering_\r\n\r\n## Phase 5: SOLID Module Separation - Renderer/Resource Refactoring\r\n\r\n**IMPORTANT**: After completing Phase 5 migration, Shader and BitmapFont loading will be fully supported via ResourceCommandQueue from JavaScript, enabling async texture/shader/font loading through the unified resource pipeline.\r\n\r\n- [ ] 5.1. Migrate Shader loading from Renderer to ResourceSubsystem\r\n  - Files: `Engine/Renderer/Renderer.hpp/.cpp` (remove), `Engine/Resource/ShaderLoader.hpp/.cpp` (enhance)\r\n  - **REMOVE from Renderer**: `CreateOrGetShaderFromFile()`, `GetShaderForFileName()`, shader caching logic\r\n  - **MOVE TO ResourceSubsystem**: Shader loading logic (already has ShaderLoader), shader caching via ResourceCache\r\n  - **KEEP in Renderer**: DirectX shader compilation (CreateShader with compiled bytecode)\r\n  - Purpose: Separate resource loading (I/O) from rendering (DirectX API)\r\n  - _Leverage: Engine/Resource/ShaderLoader.hpp (existing), Engine/Resource/ResourceCache.hpp (existing)_\r\n  - _Requirements: Requirement 5 (SOLID Module Separation - Renderer/Resource)_\r\n  - _Prompt: Role: C++ Architect specializing in SOLID principles and module refactoring | Task: Migrate shader loading responsibilities from Renderer to ResourceSubsystem by removing CreateOrGetShaderFromFile and caching logic from Renderer, moving to ShaderLoader and ResourceCache, while keeping DirectX shader compilation in Renderer | Restrictions: Renderer must have zero file I/O operations after migration (no fopen, ifstream), ResourceSubsystem owns ALL shader caching, Renderer only handles DirectX shader object creation from bytecode, preserve existing shader API compatibility, maintain performance | Success: Renderer has no shader file loading code, ResourceSubsystem provides CreateOrGetShaderFromFile via ShaderLoader, shader caching unified in ResourceCache, Renderer only creates DirectX shader objects from compiled bytecode, existing code works without changes, SOLID Single Responsibility achieved_\r\n\r\n- [ ] 5.2. Migrate BitmapFont loading from Renderer to ResourceSubsystem\r\n  - Files: `Engine/Renderer/Renderer.hpp/.cpp` (remove), `Engine/Resource/FontLoader.hpp/.cpp` (enhance)\r\n  - **REMOVE from Renderer**: `CreateOrGetBitmapFontFromFile()`, `GetBitmapFontForFileName()`, font caching logic\r\n  - **MOVE TO ResourceSubsystem**: Font loading logic (already has FontLoader), font caching via ResourceCache\r\n  - **KEEP in Renderer**: DirectX texture creation for font glyphs (if needed)\r\n  - Purpose: Complete separation of resource loading from rendering responsibilities\r\n  - _Leverage: Engine/Resource/FontLoader.hpp (existing), Engine/Resource/ResourceCache.hpp (existing)_\r\n  - _Requirements: Requirement 5 (SOLID Module Separation - Renderer/Resource)_\r\n  - _Prompt: Role: C++ Architect specializing in SOLID principles and resource management | Task: Complete SOLID separation by migrating BitmapFont loading from Renderer to ResourceSubsystem, removing CreateOrGetBitmapFontFromFile and caching logic from Renderer, moving to FontLoader and ResourceCache | Restrictions: Renderer must have zero font file loading code after migration, ResourceSubsystem owns ALL font caching, preserve existing font API compatibility, maintain font rendering quality and performance, ensure texture creation for glyphs still works | Success: Renderer has no font file loading code, ResourceSubsystem provides CreateOrGetBitmapFontFromFile via FontLoader, font caching unified in ResourceCache, existing code works without changes, Renderer focuses exclusively on rendering operations, SOLID achieved_\r\n\r\n- [ ] 5.3. Verify Renderer has ZERO file I/O operations (SOLID validation)\r\n  - Files: `Engine/Renderer/Renderer.hpp` and `.cpp` (audit)\r\n  - Search for ALL file I/O operations: `fopen`, `fclose`, `std::ifstream`, `std::ofstream`, `std::filesystem`\r\n  - Verify NO resource caching logic: `std::vector<Texture*>`, `std::vector<Shader*>`, etc.\r\n  - Confirm Renderer responsibilities: DirectX API wrapping, rendering pipeline, shader binding, draw calls ONLY\r\n  - Purpose: Validate SOLID Single Responsibility Principle compliance\r\n  - _Requirements: Requirement 5 (SOLID Module Separation - Renderer/Resource)_\r\n  - _Prompt: Role: C++ Code Auditor with expertise in SOLID principles and static analysis | Task: Perform comprehensive audit of Renderer.hpp and Renderer.cpp to verify zero file I/O operations (fopen, ifstream, filesystem), zero resource caching logic (vectors of Texture*, Shader*, etc.), and confirm Renderer focuses exclusively on DirectX API wrapping, rendering pipeline, shader binding, and draw calls | Restrictions: Use grep or search tools to find all file I/O patterns, check for resource caching containers, verify each method's responsibility, document any violations found, do not modify code (audit only) | Success: Comprehensive audit report generated, zero file I/O operations found in Renderer, zero resource caching containers found, all Renderer methods confirmed to be rendering-focused only, SOLID Single Responsibility validated, any violations documented with remediation plan_\r\n\r\n## Phase 6: Visual Studio Project Organization\r\n\r\n- [ ] 6.1. Update Visual Studio filters (.vcxproj.filters) for logical grouping\r\n  - File: `ProtogameJS3D.vcxproj.filters` (modify existing)\r\n  - Create virtual filters: `Engine\\Core\\Async`, `Engine\\Core\\Async\\Base`, `Engine\\Core\\Async\\Commands`, `Engine\\Core\\Async\\Queues`\r\n  - Add all command/queue files to appropriate virtual filters (physical locations unchanged)\r\n  - Purpose: Organize async infrastructure in IDE without restructuring physical directories\r\n  - _Leverage: Existing .vcxproj.filters structure_\r\n  - _Requirements: Requirement 6 (Visual Studio Filter Organization)_\r\n  - _Prompt: Role: Visual Studio Project Manager with expertise in .vcxproj.filters XML structure | Task: Update ProtogameJS3D.vcxproj.filters to create logical virtual filters for async infrastructure (Engine\\Core\\Async with subfolders Base, Commands, Queues) and assign all command/queue files to appropriate filters while keeping physical file locations unchanged | Restrictions: Do not modify physical file locations, do not change include paths, preserve existing filter structure, ensure all new files are included in appropriate virtual filters, maintain XML formatting and GUID uniqueness | Success: Visual Studio Solution Explorer shows organized Async filter structure, all command/queue files appear in logical groups, physical file locations unchanged, project compiles without errors, filter structure intuitive and clear for developers_\r\n\r\n## Phase 7: Documentation and Testing\r\n\r\n- [ ] 7.1. Update Engine/README.md with async architecture documentation\r\n  - File: `Engine/README.md` (modify existing)\r\n  - Add new section: \"Async Command Queue Architecture\" documenting CommandQueueBase template usage, lock-free SPSC pattern, adding new queue types (<30 lines guide)\r\n  - Include: Architecture diagrams, performance characteristics, threading model, JobSystem integration\r\n  - Purpose: Document async infrastructure in existing Engine README\r\n  - _Leverage: Existing header documentation from CommandQueueBase.hpp, RenderCommandQueue.hpp, Engine/README.md structure_\r\n  - _Requirements: Non-Functional Requirements (Maintainability)_\r\n  - _Prompt: Role: Technical Writer with expertise in documenting C++ engine architecture and lock-free data structures | Task: Update existing Engine/README.md by adding a new \"Async Command Queue Architecture\" section documenting CommandQueueBase template usage, lock-free SPSC pattern explanation, step-by-step guide for adding new queue types (<30 lines), architecture diagrams, performance characteristics, threading model, and JobSystem integration for Resource module | Restrictions: Must follow existing README.md structure and formatting, be accessible to intermediate C++ developers, include practical code examples, explain lock-free SPSC design rationale, provide architecture diagrams (ASCII art or Mermaid), keep guide for adding queues concise (<30 lines of code example), document JobSystem vs SPSC queue decision matrix | Success: Engine/README.md updated with comprehensive async section, CommandQueueBase usage explained with examples, adding new queues documented as <30 lines, architecture diagrams included, performance characteristics documented, threading model explained, JobSystem integration documented, intermediate developers can understand and use async infrastructure_\r\n\r\n- [ ] 7.2. Update CLAUDE.md files with new async infrastructure structure\r\n  - Files: `Engine/Code/Engine/Core/CLAUDE.md`, `Engine/Code/Engine/Renderer/CLAUDE.md`, `Engine/Code/Engine/Audio/CLAUDE.md`, `Engine/Code/Engine/Resource/CLAUDE.md`\r\n  - Update each module's CLAUDE.md to document: CommandQueueBase template, new command queues, JobSystem integration (Resource), SOLID separation (Renderer/Resource)\r\n  - Purpose: Maintain AI assistant context documentation with new architecture\r\n  - _Leverage: Existing CLAUDE.md structure and format_\r\n  - _Requirements: Non-Functional Requirements (Maintainability)_\r\n  - _Prompt: Role: Documentation Specialist with expertise in maintaining AI context documentation and C++ engine architecture | Task: Update CLAUDE.md files for Core, Renderer, Audio, and Resource modules to document new async infrastructure including CommandQueueBase template, new command queues (Audio, Resource, Debug), JobSystem integration for Resource module, and SOLID Renderer/Resource separation | Restrictions: Follow existing CLAUDE.md format and structure, maintain consistent documentation style across modules, include file locations and purpose for each component, update module diagrams if present, ensure AI assistants can understand new architecture from documentation | Success: All CLAUDE.md files updated with new async infrastructure, CommandQueueBase documented in Core/CLAUDE.md, new command queues documented in respective module CLAUDE.md files, JobSystem integration explained in Resource/CLAUDE.md, SOLID separation documented in Renderer/CLAUDE.md, documentation follows existing format and style_\r\n\r\n- [ ] 7.3. Write unit tests for CommandQueueBase template\r\n  - File: `Engine/Tests/CommandQueueBaseTests.cpp` (new)\r\n  - Test: Submit/ConsumeAll with different command types, queue full behavior, thread safety (SPSC), statistics tracking\r\n  - Purpose: Validate template correctness and prevent regressions\r\n  - _Leverage: Existing test framework and patterns_\r\n  - _Requirements: Non-Functional Requirements (Reliability, Testing)_\r\n  - _Prompt: Role: QA Engineer with expertise in C++ unit testing, lock-free data structures, and multithreading | Task: Create comprehensive unit tests for CommandQueueBase template covering Submit/ConsumeAll operations with different command types, queue full backpressure behavior, SPSC thread safety validation, and statistics tracking (GetTotalSubmitted, GetTotalConsumed) | Restrictions: Must test template with multiple instantiations (RenderCommand, AudioCommand, ResourceCommand), use existing test framework conventions, test both success and failure scenarios (queue full), validate thread safety with concurrent producer/consumer, do not test DirectX or audio functionality | Success: Unit tests cover all CommandQueueBase functionality, template tested with multiple command types, queue full behavior validated, SPSC thread safety confirmed with concurrent tests, statistics tracking verified, tests pass consistently, code coverage >90% for template_\r\n\r\n- [ ] 7.4. Write integration tests for async resource loading (JavaScript → JobSystem → Callback)\r\n  - File: `Engine/Tests/AsyncResourceLoadingTests.cpp` (new)\r\n  - Test: JavaScript loadTexture() → ResourceCommandQueue → JobSystem → CallbackQueue → JavaScript callback\r\n  - Validate: End-to-end async loading, callback delivery, error handling, queue backpressure\r\n  - Purpose: Validate complete async resource loading pipeline\r\n  - _Leverage: Existing integration test framework_\r\n  - _Requirements: Requirement 3 (Resource Command Queue Integration), Non-Functional Requirements (Testing)_\r\n  - _Prompt: Role: Integration Test Engineer with expertise in C++/JavaScript interop testing and async workflows | Task: Create integration tests for complete async resource loading pipeline validating JavaScript loadTexture() → ResourceCommandQueue → JobSystem (I/O workers) → CallbackQueue → JavaScript callback delivery, including error handling and queue backpressure scenarios | Restrictions: Must test actual JavaScript → C++ → JavaScript round trip, use real JobSystem with I/O workers, validate callback delivery with correct callbackId and resourceId, test error scenarios (invalid path, queue full), do not mock JobSystem or queues | Success: Integration tests validate end-to-end async resource loading, JavaScript receives callbacks correctly, callbackId and resourceId match expectations, error scenarios handled gracefully, queue backpressure tested, tests run reliably, async workflows proven correct_\r\n\r\n- [ ] 7.5. Benchmark performance: Verify <5% variance from baseline\r\n  - Files: `Engine/Tests/PerformanceBenchmarks.cpp` (new or modify existing)\r\n  - Benchmark: RenderCommandQueue (before/after refactor), CallbackQueue (before/after), ResourceSubsystem async loading (JobSystem vs custom threads)\r\n  - Validate: <5% performance variance, memory usage comparable, latency <0.5ms for Submit\r\n  - Purpose: Ensure refactoring maintains performance characteristics\r\n  - _Leverage: Existing performance testing infrastructure_\r\n  - _Requirements: Non-Functional Requirements (Performance)_\r\n  - _Prompt: Role: Performance Engineer with expertise in C++ benchmarking and profiling | Task: Create performance benchmarks comparing before/after refactoring for RenderCommandQueue, CallbackQueue, and ResourceSubsystem async loading, validating <5% performance variance, comparable memory usage, and Submit latency <0.5ms | Restrictions: Must use consistent benchmark methodology (iterations, warm-up), compare identical workloads before/after, measure latency (Submit/ConsumeAll), throughput (commands/sec), and memory usage, run benchmarks multiple times for statistical validity, document any variance >5% with explanation | Success: Benchmarks show <5% performance variance for RenderCommandQueue and CallbackQueue refactoring, ResourceSubsystem JobSystem integration maintains or improves performance vs custom threads, Submit latency <0.5ms validated, memory usage comparable or reduced, benchmark results documented with statistical analysis_\r\n\r\n## Success Criteria Summary\r\n\r\n### Visual Rendering Validation\r\n- **Exact Visual Parity**: Game renders identically to current state (see screenshot reference: `C:\\Users\\tsengyuwei\\OneDrive\\Pictures\\Screenshots\\Screenshot 2025-11-30 095809.png`)\r\n- **Texture Binding Functional**: ResourceCommandQueue enables JavaScript to load and bind textures asynchronously\r\n- **Resource Loading from JavaScript**: Successfully demonstrate loading textures via `resource.loadTexture(path, callback)` from JavaScript, receiving resourceId via callback, and binding textures to rendered geometry\r\n- **Visual Improvement Target**: Transform current untextured rendering (white/colored geometry) into textured rendering by enabling ResourceSubsystem JavaScript integration\r\n\r\n### Code Quality\r\n- **Code Elimination**: ~800 lines of duplicate queue code eliminated ✓ CommandQueueBase template used by all queues ✓\r\n- **SOLID Compliance**: Renderer has zero file I/O operations ✓ ResourceSubsystem owns all resource loading ✓\r\n- **JobSystem Integration**: ResourceSubsystem uses JobSystem instead of custom worker threads (~150 lines removed) ✓\r\n\r\n### Performance\r\n- **Zero Regression**: Benchmarks show <5% variance from baseline ✓\r\n- **Latency**: Submit latency <0.5ms maintained ✓\r\n- **ResourceSubsystem**: JobSystem integration maintains or improves performance vs custom threads ✓\r\n\r\n### Architecture\r\n- **Unified Pattern**: All async subsystems use CommandQueueBase or JobSystem ✓\r\n- **JobSystem**: Resource module integrated with typed I/O workers ✓\r\n- **Lock-Free SPSC**: Direct thread communication (Render, Audio, Callback) ✓\r\n\r\n### Functional Validation\r\n- **JavaScript Resource Loading**: Verify `resource.loadTexture()`, `resource.loadModel()`, `resource.loadShader()` work from JavaScript\r\n- **Async Callbacks**: Validate CallbackQueue delivers resourceId to JavaScript callbacks correctly\r\n- **Texture Binding**: Demonstrate loaded textures can be bound and rendered on geometry\r\n- **End-to-End Workflow**: JavaScript → ResourceCommandQueue → JobSystem → Resource Loading → CallbackQueue → JavaScript → Texture Binding → Visual Rendering\r\n\r\n### Testing\r\n- **Unit Tests**: CommandQueueBase tests pass ✓ All queue types validated ✓\r\n- **Integration Tests**: Async resource loading pipeline validated end-to-end ✓\r\n- **Performance Benchmarks**: <5% variance confirmed ✓\r\n- **Visual Test**: Textures render correctly after JavaScript loading ✓\r\n\r\n### Documentation\r\n- **Engine README**: Async architecture section added to Engine/README.md ✓\r\n- **CLAUDE.md**: All module CLAUDE.md files updated ✓\r\n- **Visual Studio**: Filters organized for async infrastructure ✓\r\n",
  "fileStats": {
    "size": 39299,
    "lines": 295,
    "lastModified": "2025-11-30T16:00:21.095Z"
  },
  "comments": []
}