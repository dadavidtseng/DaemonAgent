{
  "id": "snapshot_1764508305282_f7z42c8v8",
  "approvalId": "approval_1764504663891_m4ptrtxty",
  "approvalTitle": "Requirements: CommandQueue Refactoring & SOLID Module Separation",
  "version": 2,
  "timestamp": "2025-11-30T13:11:45.281Z",
  "trigger": "revision_requested",
  "status": "pending",
  "content": "# Requirements: Unified Command Queue Architecture & SOLID Module Separation\r\n\r\n## Spec Metadata\r\n- **Spec Name**: command-queue-refactoring\r\n- **Created**: 2025-01-30\r\n- **Priority**: HIGH\r\n- **Type**: Architecture Refactoring\r\n- **Estimated Hours**: 32-48h\r\n- **Dependencies**: None (builds on existing async infrastructure)\r\n\r\n## Introduction\r\n\r\nThis specification defines a comprehensive refactoring of the project's async communication infrastructure to achieve three goals:\r\n\r\n1. **Unified Queue Architecture**: Create a reusable `CommandQueueBase` template to eliminate code duplication across `RenderCommandQueue`, `CallbackQueue`, `AudioCommandQueue`, `ResourceCommandQueue`, and `DebugRenderCommandQueue`.\r\n\r\n2. **Complete Async Coverage**: Add missing command queues for Audio and Resource modules to align with established async patterns used by Entity, Camera, and Render systems.\r\n\r\n3. **SOLID Module Separation**: Complete the migration of resource loading responsibilities from Renderer to Resource module, ensuring each module has a single, well-defined purpose.\r\n\r\n## Alignment with Product Vision\r\n\r\n**Architecture Goal**: Achieve professional-grade, scalable async architecture that:\r\n- Eliminates code duplication (DRY principle)\r\n- Provides consistent async patterns across all subsystems\r\n- Enables independent threading for C++, JavaScript, Audio, and Resource loading\r\n- Maintains clear module boundaries following SOLID principles\r\n\r\nThis refactoring establishes ProtogameJS3D as a proven, reusable template for future game projects built on DaemonEngine.\r\n\r\n## Requirements\r\n\r\n### Requirement 1: Unified Command Queue Infrastructure\r\n\r\n**User Story:** As an engine developer, I want a reusable command queue template, so that I can add new async subsystems without duplicating lock-free SPSC queue implementation code.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN creating `CommandQueueBase<TCommand>` template THEN the system SHALL provide:\r\n   - Lock-free SPSC ring buffer implementation\r\n   - Cache-line aligned atomic indices (64-byte separation)\r\n   - Configurable capacity via template parameter\r\n   - `Submit(command)` producer API (non-blocking)\r\n   - `ConsumeAll(processor)` consumer API (batch processing)\r\n   - Virtual hooks for `OnSubmit()`, `OnConsume()`, `OnQueueFull()`\r\n\r\n2. WHEN a new queue type is needed THEN the developer SHALL:\r\n   - Define command structure (e.g., `AudioCommand`, `ResourceCommand`)\r\n   - Create queue class inheriting from `CommandQueueBase<TCommand>`\r\n   - Optionally override virtual hooks for custom behavior\r\n   - Total implementation SHALL be <30 lines of code\r\n\r\n3. WHEN the template is instantiated THEN the system SHALL:\r\n   - Prevent code duplication (DRY principle)\r\n   - Maintain identical performance to handwritten queues\r\n   - Use memory ordering: acquire/release for synchronization, relaxed for statistics\r\n\r\n### Requirement 2: Audio Command Queue Integration\r\n\r\n**User Story:** As a game developer using JavaScript, I want async audio loading and playback, so that audio file I/O (10-200ms) doesn't block the JavaScript game loop.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN JavaScript calls `audio.loadSound(path, callback)` THEN the system SHALL:\r\n   - Submit `AudioCommand{LOAD_SOUND}` to `AudioCommandQueue` (non-blocking)\r\n   - Return immediately to JavaScript (no blocking)\r\n   - Process loading on Audio worker thread\r\n   - Return result via `CallbackQueue` with `{ callbackId, soundId }`\r\n\r\n2. WHEN JavaScript calls `audio.playSound(soundId)` THEN the system SHALL:\r\n   - Submit `AudioCommand{PLAY_SOUND}` to `AudioCommandQueue` (non-blocking)\r\n   - Process on Audio thread via FMOD\r\n   - Execute without blocking JavaScript or C++ render thread\r\n\r\n3. WHEN `AudioCommandQueue` processes commands THEN the system SHALL:\r\n   - Support command types: `LOAD_SOUND`, `PLAY_SOUND`, `STOP_SOUND`, `SET_VOLUME`, `UPDATE_3D_POSITION`\r\n   - Use default capacity of 200 commands (~8-12 KB memory)\r\n   - Log queue full warnings (backpressure detection)\r\n\r\n### Requirement 3: Resource Command Queue Integration\r\n\r\n**User Story:** As a game developer using JavaScript, I want async resource loading (textures, models, shaders), so that file I/O doesn't block the JavaScript game loop and resources can load in the background.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN JavaScript calls `resource.loadTexture(path, callback)` THEN the system SHALL:\r\n   - Submit `ResourceCommand{LOAD_TEXTURE}` to `ResourceCommandQueue` (non-blocking)\r\n   - Return immediately to JavaScript\r\n   - Process loading on Resource worker thread pool\r\n   - Return result via `CallbackQueue` with `{ callbackId, resourceId }`\r\n\r\n2. WHEN Resource worker thread processes commands THEN the system SHALL:\r\n   - Support command types: `LOAD_TEXTURE`, `LOAD_MODEL`, `LOAD_AUDIO`, `LOAD_SHADER`, `UNLOAD_RESOURCE`\r\n   - Replace `std::async` with unified command queue pattern\r\n   - Maintain existing worker thread pool architecture\r\n   - Use default capacity of 200 commands (~280 bytes each = ~56 KB memory)\r\n\r\n3. WHEN C++ code needs resource loading THEN the system SHALL:\r\n   - Preserve existing synchronous API: `LoadResource<T>(path)` unchanged\r\n   - Preserve existing async API: `LoadResourceAsync<T>(path)` returns `std::future`\r\n   - Allow optional command queue injection via `SetCommandQueue(queue)`\r\n   - Support compilation WITHOUT script module (`#if ENGINE_SCRIPTING_ENABLED`)\r\n\r\n### Requirement 4: Debug Render Command Queue (Optional)\r\n\r\n**User Story:** As a developer debugging game logic, I want debug rendering to be non-blocking, so that extensive debug visualization (100+ lines/spheres per frame) doesn't impact main rendering performance.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN JavaScript calls `debug.addWorldLine(...)` THEN the system SHALL:\r\n   - Submit `DebugRenderCommand{ADD_WORLD_LINE}` to `DebugRenderCommandQueue` (non-blocking)\r\n   - Process on render thread during debug render pass\r\n\r\n2. WHEN compiled in DEBUG mode THEN the system SHALL:\r\n   - Include full `DebugRenderCommandQueue` implementation\r\n   - Use capacity of 500 commands (~280 bytes each = ~140 KB)\r\n   - Support all debug primitives: lines, spheres, arrows, text, billboards\r\n\r\n3. WHEN compiled in RELEASE mode THEN the system SHALL:\r\n   - Provide stub implementation (no-op)\r\n   - Compile out all debug queue overhead (`#if defined(_DEBUG)`)\r\n\r\n### Requirement 5: SOLID Module Separation - Renderer/Resource\r\n\r\n**User Story:** As an engine architect, I want Renderer and Resource modules to follow Single Responsibility Principle, so that each module has a clear, focused purpose and can be maintained independently.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN migrating Shader loading THEN the system SHALL:\r\n   - Move `CreateOrGetShaderFromFile()` from Renderer to ResourceSubsystem\r\n   - Move `GetShaderForFileName()` from Renderer to ResourceCache\r\n   - Move `CreateShader()` logic to `ShaderLoader` class\r\n   - Keep DirectX shader compilation in Renderer (render API responsibility)\r\n\r\n2. WHEN migrating BitmapFont loading THEN the system SHALL:\r\n   - Move `CreateOrGetBitmapFontFromFile()` from Renderer to ResourceSubsystem\r\n   - Move `GetBitMapFontForFileName()` from Renderer to ResourceCache\r\n   - Move font loading logic to `FontLoader` class\r\n\r\n3. WHEN migration is complete THEN Renderer SHALL:\r\n   - Have ZERO file I/O operations (no `fopen`, `std::ifstream`)\r\n   - Have ZERO resource caching logic (no `std::vector<Texture*>`, etc.)\r\n   - Focus exclusively on: DirectX API wrapping, rendering pipeline, shader binding, state management\r\n\r\n4. WHEN migration is complete THEN ResourceSubsystem SHALL:\r\n   - Own ALL file loading operations (textures, shaders, fonts, models, audio)\r\n   - Own ALL resource caching and lifetime management\r\n   - Provide unified API: `CreateOrGetResource<T>(path)` for all resource types\r\n\r\n### Requirement 6: Centralized Async Directory Structure\r\n\r\n**User Story:** As a developer navigating the codebase, I want all async infrastructure in one location, so that I can quickly find and understand the architecture without searching across multiple directories.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN organizing async infrastructure THEN the system SHALL create:\r\n   ```\r\n   Engine/Core/Async/\r\n   ├── README.md                      ← Architecture documentation\r\n   ├── CommandQueueBase.hpp           ← Template base class\r\n   ├── CommandQueueBase.cpp           ← Common implementation\r\n   ├── Commands/                      ← Command structures\r\n   │   ├── RenderCommand.hpp\r\n   │   ├── DebugRenderCommand.hpp\r\n   │   ├── AudioCommand.hpp\r\n   │   ├── ResourceCommand.hpp\r\n   │   └── CallbackData.hpp\r\n   └── Queues/                        ← Queue specializations\r\n       ├── RenderCommandQueue.hpp     (~20 lines)\r\n       ├── AudioCommandQueue.hpp      (~15 lines)\r\n       ├── ResourceCommandQueue.hpp   (~20 lines)\r\n       ├── DebugRenderCommandQueue.hpp (~25 lines)\r\n       └── CallbackQueue.hpp          (~20 lines)\r\n   ```\r\n\r\n2. WHEN migrating existing queues THEN the system SHALL:\r\n   - Move `RenderCommandQueue` from `Engine/Renderer/` to `Engine/Core/Async/Queues/`\r\n   - Move `CallbackQueue` from `Engine/Core/` to `Engine/Core/Async/Queues/`\r\n   - Move `RenderCommand` from `Engine/Renderer/` to `Engine/Core/Async/Commands/`\r\n   - Move `CallbackData` from `Engine/Core/` to `Engine/Core/Async/Commands/`\r\n   - Update all `#include` paths project-wide\r\n\r\n3. WHEN reviewing directory structure THEN the developer SHALL:\r\n   - See all async infrastructure in single directory tree\r\n   - Understand command vs queue separation at a glance\r\n   - Find <10 files total (not 20+ files scattered)\r\n\r\n## Non-Functional Requirements\r\n\r\n### Code Architecture and Modularity\r\n\r\n#### Single Responsibility Principle (SOLID - S)\r\n- **Renderer Module**: DirectX API wrapping, rendering pipeline, shader binding, draw calls\r\n- **Resource Module**: File I/O, resource loading, caching, lifetime management\r\n- **Async Module**: Lock-free queues, command submission, callback delivery\r\n\r\n#### Open/Closed Principle (SOLID - O)\r\n- **CommandQueueBase**: Extensible via inheritance, closed for modification\r\n- **Virtual Hooks**: Subclasses extend behavior without modifying base template\r\n\r\n#### Dependency Inversion Principle (SOLID - D)\r\n- **ResourceSubsystem**: Core module has ZERO dependency on Script module\r\n- **Optional Injection**: Command queues injected via `SetCommandQueue(queue)` if scripting enabled\r\n- **Conditional Compilation**: `#if ENGINE_SCRIPTING_ENABLED` prevents hard dependencies\r\n\r\n### Performance\r\n\r\n1. **Queue Operations**:\r\n   - Submit latency: <0.5ms (lock-free, no blocking)\r\n   - Consume latency: O(n) where n = commands per frame\r\n   - Memory overhead: <200 KB total for all queues\r\n\r\n2. **Template Instantiation**:\r\n   - Zero runtime overhead vs handwritten queues\r\n   - Compiler optimization SHALL inline template code\r\n   - Binary size increase: <50 KB total\r\n\r\n3. **Backward Compatibility**:\r\n   - Existing C++ APIs SHALL maintain identical performance\r\n   - ResourceSubsystem sync/async APIs unchanged\r\n   - Renderer rendering performance unaffected\r\n\r\n### Reliability\r\n\r\n1. **Backpressure Handling**:\r\n   - Full queue SHALL return `false` from `Submit()` (non-blocking)\r\n   - System SHALL log warnings when queues are >80% full\r\n   - Commands SHALL be dropped gracefully with error logging\r\n\r\n2. **Thread Safety**:\r\n   - SPSC queues guarantee thread safety (single producer, single consumer)\r\n   - Memory ordering SHALL prevent data races\r\n   - No locks, no deadlocks, no priority inversion\r\n\r\n3. **Crash Isolation**:\r\n   - JavaScript resource loading errors SHALL NOT crash C++\r\n   - Audio loading failures SHALL return error via callback\r\n   - Render thread SHALL continue if resource loading fails\r\n\r\n### Maintainability\r\n\r\n1. **Code Duplication Elimination**:\r\n   - Eliminate ~800 lines of duplicate queue code\r\n   - Reduce to 1 base template + 5 specializations (<150 lines total)\r\n\r\n2. **Documentation**:\r\n   - `Engine/Core/Async/README.md` SHALL document architecture\r\n   - Each queue SHALL have usage examples in header comments\r\n   - CLAUDE.md files SHALL be updated with new structure\r\n\r\n3. **Testing**:\r\n   - Validate queue refactoring preserves behavior (no regressions)\r\n   - Test async resource loading from JavaScript\r\n   - Test async audio playback from JavaScript\r\n   - Benchmark performance (ensure <5% variance)\r\n\r\n### Usability\r\n\r\n1. **Developer Experience**:\r\n   - Adding new queue type SHALL require <30 lines of code\r\n   - Clear error messages when queues are full\r\n   - Consistent API across all async subsystems\r\n\r\n2. **Debugging**:\r\n   - Queue statistics exposed: `GetTotalSubmitted()`, `GetTotalConsumed()`\r\n   - Approximate queue size for monitoring\r\n   - Virtual `OnQueueFull()` hook for custom logging\r\n\r\n## Success Metrics\r\n\r\n1. **Code Quality**:\r\n   - Eliminate 800+ lines of duplicate queue code ✅\r\n   - All async subsystems use unified pattern ✅\r\n   - SOLID principles validated (no Renderer file I/O) ✅\r\n\r\n2. **Performance**:\r\n   - Zero regression in existing benchmarks ✅\r\n   - Audio/Resource async operations non-blocking ✅\r\n   - Queue operations <0.5ms latency ✅\r\n\r\n3. **Architecture**:\r\n   - ProtogameJS3D becomes proven template ✅\r\n   - DaemonAgent can start from clean architecture ✅\r\n   - Future queue types trivial to add (<30 lines) ✅\r\n",
  "fileStats": {
    "size": 13504,
    "lines": 285,
    "lastModified": "2025-11-30T12:07:21.034Z"
  },
  "comments": []
}