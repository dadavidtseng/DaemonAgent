{
  "id": "snapshot_1763463593170_1q7tlmuqt",
  "approvalId": "approval_1763463593161_bnxx5jzye",
  "approvalTitle": "Design Document - C++/JavaScript Decoupling Architecture",
  "version": 1,
  "timestamp": "2025-11-18T10:59:53.169Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document: C++/JavaScript Decoupling Architecture (Phase 1-4)\r\n\r\n## Overview\r\n\r\nThis design implements the complete Phase 1-4 roadmap for C++/JavaScript decoupling in ProtogameJS3D's dual-language game engine. The goal is to achieve true thread independence where C++ rendering (main thread) and JavaScript game logic (worker thread) run at independent speeds with fully asynchronous bidirectional communication.\r\n\r\n**Current State (Phase 1 - Complete ✅)**:\r\n- Async infrastructure: EntityStateBuffer, CameraStateBuffer, RenderCommandQueue\r\n- JavaScript → C++ async via lock-free SPSC queue\r\n- M4-T8 refactoring: Entity/Camera systems in Engine repository\r\n\r\n**Target State (Phase 2-4 - This Design)**:\r\n- **Phase 2**: JavaScript on worker thread, async C++→JS callbacks via CallbackQueue\r\n- **Phase 3**: Error recovery and exception handling for robustness\r\n- **Phase 4**: Dirty tracking optimization to reduce SwapBuffers() cost from O(n) to O(d)\r\n- **Additional**: Remove vertexBufferHandle from EntityState, formal documentation\r\n\r\n**Architecture Philosophy**:\r\n- **Lock-Free Hot Paths**: No locks during entity updates or rendering\r\n- **Brief Locked Synchronization**: Only during buffer swap (< 100µs)\r\n- **Fault Isolation**: JavaScript errors don't crash C++, C++ errors don't corrupt JavaScript\r\n- **Incremental Implementation**: Each phase builds on previous, independently testable\r\n\r\n## Steering Document Alignment\r\n\r\n### Technical Standards\r\n\r\n**Thread Safety Standards**:\r\n- SPSC queue pattern for single-producer/single-consumer communication\r\n- Cache-line separation to prevent false sharing (64-byte alignment)\r\n- Atomic operations with appropriate memory ordering (acquire/release semantics)\r\n- No blocking operations in hot paths\r\n\r\n**Performance Standards**:\r\n- C++ rendering: Maintain 60+ FPS regardless of JavaScript performance\r\n- Queue operations: < 1µs per operation\r\n- SwapBuffers: < 100µs with dirty tracking (Phase 4)\r\n- Memory overhead: < 2× for double-buffering\r\n\r\n**Code Quality Standards**:\r\n- C++20 features with full conformance\r\n- RAII patterns for resource management\r\n- Exception safety guarantees (basic or strong)\r\n- Professional documentation with design rationales\r\n\r\n### Project Structure\r\n\r\n**Engine Repository** (`C:\\p4\\Personal\\SD\\Engine\\`):\r\n- Core systems: `Code/Engine/Core/` - StateBuffer, CallbackQueue (new), thread utilities\r\n- Entity management: `Code/Engine/Entity/` - EntityAPI, EntityStateBuffer\r\n- Rendering: `Code/Engine/Renderer/` - CameraAPI, RenderCommandQueue\r\n- Script integration: `Code/Engine/Script/` - V8Subsystem, IJSGameLogicContext\r\n\r\n**Game Repository** (`C:\\p4\\Personal\\SD\\ProtogameJS3D\\`):\r\n- Application: `Code/Game/Framework/` - App.cpp, RenderResourceManager (new)\r\n- Game logic: `Code/Game/Gameplay/` - Game.cpp, JavaScriptWorkerThread (new)\r\n- JavaScript: `Run/Data/Scripts/` - EntityAPI.js, CameraAPI.js, JSEngine.js\r\n\r\n## Code Reuse Analysis\r\n\r\n### Existing Components to Leverage\r\n\r\n**RenderCommandQueue Pattern** (`Engine/Renderer/RenderCommandQueue.hpp`):\r\n- Lock-free SPSC ring buffer implementation\r\n- Cache-line separated atomic indices (m_head, m_tail)\r\n- Template-based processor pattern (`ConsumeAll<ProcessorFunc>`)\r\n- **Reuse**: Duplicate this pattern for CallbackQueue (JS→C++ and C++→JS use same architecture)\r\n- **Extension**: Add error reporting fields to callback commands\r\n\r\n**StateBuffer Template** (`Engine/Core/StateBuffer.hpp`):\r\n- Generic double-buffering with front/back separation\r\n- SwapBuffers() with full O(n) copy\r\n- Thread-safe access pattern: GetFrontBuffer() read-only, GetBackBuffer() write-only\r\n- **Reuse**: Add dirty tracking fields without breaking existing API\r\n- **Extension**: MarkDirty(EntityID), GetDirtyEntities(), dirty-only swap\r\n\r\n**EntityAPI/CameraAPI Pattern** (`Engine/Entity/EntityAPI.hpp`):\r\n- RenderCommand submission via SubmitCommand()\r\n- Callback management via m_pendingCallbacks map\r\n- JavaScript binding via EntityScriptInterface\r\n- **Reuse**: Change ExecutePendingCallbacks() to use CallbackQueue instead of direct execution\r\n- **Extension**: Add error reporting when callbacks fail\r\n\r\n**V8Subsystem** (`Engine/Script/V8Subsystem.cpp`):\r\n- V8 isolate management\r\n- JavaScript execution via ExecuteCommand()\r\n- Module loading infrastructure\r\n- **Reuse**: Add V8::Locker for worker thread isolation\r\n- **Extension**: Worker thread isolate creation and management\r\n\r\n### Integration Points\r\n\r\n**Game::Update() → Worker Thread** (`Code/Game/Gameplay/Game.cpp`):\r\n- Currently: Calls `UpdateJS()` on main thread (line 68-74)\r\n- Target: Spawn worker thread, call `UpdateJSWorkerThread()` on worker\r\n- Integration: Replace direct V8 execution with thread signaling\r\n\r\n**App::ProcessRenderCommands() → RenderResourceManager** (`Code/Game/Framework/App.cpp`):\r\n- Currently: Writes vertexBufferHandle to EntityState\r\n- Target: Store vertexBufferHandle in RenderResourceManager\r\n- Integration: Map EntityID → vertexBufferHandle in C++ only\r\n\r\n**EntityAPI::ExecutePendingCallbacks() → CallbackQueue** (`Engine/Entity/EntityAPI.cpp`):\r\n- Currently: Directly executes callbacks, blocking C++ thread\r\n- Target: Enqueue callbacks to CallbackQueue for async processing\r\n- Integration: JavaScript dequeues and executes during update loop\r\n\r\n**JavaScript Update Loop** (`Run/Data/Scripts/JSEngine.js`):\r\n- Currently: Processes entity updates, renders\r\n- Target: Add callback processing at start of update loop\r\n- Integration: `while (let cb = CallbackQueue.dequeue()) { executeCallback(cb); }`\r\n\r\n## Architecture\r\n\r\n### High-Level Thread Model\r\n\r\n```mermaid\r\ngraph TD\r\n    subgraph \"Main Thread (C++ Rendering)\"\r\n        A[App::Update]\r\n        B[ProcessRenderCommands]\r\n        C[Render Entities]\r\n        D[SwapBuffers]\r\n        E[ExecutePendingCallbacks]\r\n\r\n        A --> B\r\n        B --> C\r\n        C --> D\r\n        D --> A\r\n        B --> E\r\n    end\r\n\r\n    subgraph \"Worker Thread (JavaScript Logic)\"\r\n        F[Game::UpdateJSWorkerThread]\r\n        G[Process Callbacks from C++]\r\n        H[JavaScript Game Logic]\r\n        I[Submit RenderCommands to C++]\r\n\r\n        F --> G\r\n        G --> H\r\n        H --> I\r\n        I --> F\r\n    end\r\n\r\n    subgraph \"Shared State (Lock-Free)\"\r\n        J[RenderCommandQueue<br/>JS→C++]\r\n        K[CallbackQueue<br/>C++→JS]\r\n        L[EntityStateBuffer<br/>Front: C++ reads<br/>Back: C++ writes]\r\n    end\r\n\r\n    I -.->|Submit| J\r\n    J -.->|Consume| B\r\n    E -.->|Enqueue| K\r\n    K -.->|Dequeue| G\r\n    D -.->|Swap| L\r\n    F -.->|Read| L\r\n\r\n    style A fill:#e1f5e1\r\n    style F fill:#e1f5ff\r\n    style J fill:#fff4e6\r\n    style K fill:#fff4e6\r\n    style L fill:#ffe6e6\r\n```\r\n\r\n### Modular Design Principles\r\n\r\n**Single File Responsibility**:\r\n- `CallbackQueue.hpp/cpp`: Lock-free SPSC queue for callbacks only\r\n- `JavaScriptWorkerThread.hpp/cpp`: Worker thread lifecycle management only\r\n- `RenderResourceManager.hpp/cpp`: Render resource (vertex buffers, textures) management only\r\n- `StateBuffer.hpp`: Dirty tracking logic isolated in template class\r\n\r\n**Component Isolation**:\r\n- CallbackQueue independent of V8 (testable without JavaScript)\r\n- StateBuffer dirty tracking backward-compatible (optional optimization)\r\n- RenderResourceManager separate from EntityState (clean abstraction)\r\n\r\n**Service Layer Separation**:\r\n- **Data Layer**: StateBuffer, RenderResourceManager (pure state management)\r\n- **Communication Layer**: RenderCommandQueue, CallbackQueue (async messaging)\r\n- **Execution Layer**: Game, App, EntityAPI (business logic)\r\n\r\n### Phase 2: Worker Thread Architecture\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant MT as Main Thread\r\n    participant WT as Worker Thread\r\n    participant RCQ as RenderCommandQueue\r\n    participant CBQ as CallbackQueue\r\n    participant ESB as EntityStateBuffer\r\n\r\n    Note over MT,WT: Frame N Begins\r\n\r\n    MT->>MT: App::Update()\r\n    MT->>RCQ: ConsumeAll(ProcessRenderCommands)\r\n\r\n    par Async Execution\r\n        MT->>MT: CreateVertexBuffer(mesh)\r\n        MT->>CBQ: Enqueue(callback, entityId)\r\n        MT->>ESB: Write to BackBuffer\r\n    and\r\n        WT->>WT: UpdateJSWorkerThread()\r\n        WT->>CBQ: Dequeue callbacks\r\n        WT->>WT: Execute JS callbacks\r\n        WT->>WT: JSEngine.update(deltaTime)\r\n        WT->>ESB: Read FrontBuffer\r\n        WT->>RCQ: Submit(RenderCommand)\r\n    end\r\n\r\n    MT->>MT: Render entities\r\n    MT->>ESB: SwapBuffers()\r\n\r\n    Note over MT,WT: Frame N Ends\r\n```\r\n\r\n### Phase 3: Error Recovery Architecture\r\n\r\n```mermaid\r\nflowchart TD\r\n    A[SwapBuffers Called] --> B{Validate BackBuffer}\r\n    B -->|Valid| C[Copy Back→Front]\r\n    B -->|Invalid| D[Log Error]\r\n    D --> E[Skip Swap, Use Stale Front]\r\n    C --> F{Exception Thrown?}\r\n    F -->|No| G[Swap Pointers]\r\n    F -->|Yes| H[Catch Exception]\r\n    H --> I[Log Error]\r\n    I --> E\r\n    G --> J[Swap Complete]\r\n\r\n    K[JavaScript Update] --> L{Try Execute}\r\n    L -->|Success| M[Continue]\r\n    L -->|Exception| N[HandleJSException]\r\n    N --> O[Log Error + Stack Trace]\r\n    O --> P[Don't Crash C++]\r\n    P --> M\r\n\r\n    Q[Callback Execution] --> R{Try Execute}\r\n    R -->|Success| S[Continue]\r\n    R -->|Error| T[Create ErrorCallback]\r\n    T --> U[Report to C++]\r\n    U --> V[Log Error]\r\n    V --> S\r\n\r\n    style D fill:#ffe6e6\r\n    style H fill:#ffe6e6\r\n    style N fill:#ffe6e6\r\n    style T fill:#ffe6e6\r\n```\r\n\r\n### Phase 4: Dirty Tracking Optimization\r\n\r\n```mermaid\r\nflowchart LR\r\n    A[EntityAPI::UpdatePosition] --> B[Submit RenderCommand]\r\n    B --> C[ProcessRenderCommands]\r\n    C --> D[Update BackBuffer]\r\n    D --> E[MarkDirty entityId]\r\n\r\n    F[SwapBuffers Called] --> G{Check DirtySet}\r\n    G -->|Empty| H[No Copy Needed]\r\n    G -->|Has Dirty| I[For Each Dirty ID]\r\n    I --> J[Copy Single Entity]\r\n    J --> K[Clear DirtySet]\r\n    K --> L[Swap Pointers]\r\n\r\n    style E fill:#e1f5ff\r\n    style I fill:#fff4e6\r\n    style J fill:#e1f5e1\r\n```\r\n\r\n## Components and Interfaces\r\n\r\n### Component 1: CallbackQueue (New)\r\n\r\n**Purpose**: Lock-free SPSC queue for async C++→JavaScript callback communication\r\n\r\n**File Location**: `C:\\p4\\Personal\\SD\\Engine\\Code\\Engine\\Core\\CallbackQueue.hpp`\r\n\r\n**Public Interface**:\r\n```cpp\r\nclass CallbackQueue {\r\npublic:\r\n    // Types\r\n    struct CallbackData {\r\n        CallbackID callbackId;        // Unique callback identifier\r\n        uint64_t   resultId;          // Entity/camera ID returned\r\n        std::string errorMessage;     // Error message if failed (empty = success)\r\n        CallbackType type;            // ENTITY_CREATED, CAMERA_CREATED, etc.\r\n    };\r\n\r\n    // Construction\r\n    explicit CallbackQueue(size_t capacity = DEFAULT_CAPACITY);\r\n    ~CallbackQueue();\r\n\r\n    // Producer API (C++ Main Thread)\r\n    bool Enqueue(CallbackData const& callback);\r\n    size_t GetApproximateSize() const;\r\n\r\n    // Consumer API (JavaScript Worker Thread)\r\n    template <typename ProcessorFunc>\r\n    void DequeueAll(ProcessorFunc&& processor);\r\n\r\n    // Monitoring\r\n    bool IsEmpty() const;\r\n    bool IsFull() const;\r\n    uint64_t GetTotalEnqueued() const;\r\n    uint64_t GetTotalDequeued() const;\r\n};\r\n```\r\n\r\n**Dependencies**:\r\n- `<atomic>` for lock-free indices\r\n- `<cstddef>` for size_t\r\n- Pattern copied from RenderCommandQueue.hpp\r\n\r\n**Reuses**:\r\n- Exact same SPSC ring buffer algorithm from RenderCommandQueue\r\n- Cache-line separation pattern (64-byte alignment)\r\n- Atomic memory ordering (acquire/release semantics)\r\n\r\n**Design Rationale**:\r\n- Separate class (not template) because callback data structure is fixed\r\n- Small data structure (40 bytes: 8+8+32+4 with padding)\r\n- DEFAULT_CAPACITY = 100 (callbacks are infrequent, 1-10 per frame)\r\n\r\n---\r\n\r\n### Component 2: JavaScriptWorkerThread (New)\r\n\r\n**Purpose**: Manages JavaScript worker thread lifecycle and V8 isolate\r\n\r\n**File Location**: `C:\\p4\\Personal\\SD\\ProtogameJS3D\\Code\\Game\\Gameplay\\JavaScriptWorkerThread.hpp`\r\n\r\n**Public Interface**:\r\n```cpp\r\nclass JavaScriptWorkerThread {\r\npublic:\r\n    // Construction\r\n    JavaScriptWorkerThread(\r\n        ScriptSubsystem* scriptSubsystem,\r\n        EntityStateBuffer* entityBuffer,\r\n        CameraStateBuffer* cameraBuffer,\r\n        RenderCommandQueue* renderQueue,\r\n        CallbackQueue* callbackQueue\r\n    );\r\n    ~JavaScriptWorkerThread();\r\n\r\n    // Thread Control\r\n    void Start();                    // Spawn worker thread\r\n    void Stop();                     // Signal stop and join thread\r\n    bool IsRunning() const;          // Check if thread is active\r\n\r\n    // Execution Loop (runs on worker thread)\r\n    void WorkerThreadLoop();         // Main loop, called by std::thread\r\n\r\n    // Statistics\r\n    uint64_t GetTotalUpdates() const;\r\n    float GetAverageUpdateTime() const;\r\n\r\nprivate:\r\n    // Thread Management\r\n    std::thread m_workerThread;\r\n    std::atomic<bool> m_stopRequested{false};\r\n    std::atomic<bool> m_isRunning{false};\r\n\r\n    // Subsystem References (not owned)\r\n    ScriptSubsystem* m_scriptSubsystem;\r\n    EntityStateBuffer* m_entityBuffer;\r\n    CameraStateBuffer* m_cameraBuffer;\r\n    RenderCommandQueue* m_renderQueue;\r\n    CallbackQueue* m_callbackQueue;\r\n\r\n    // V8 Isolate (worker thread only)\r\n    v8::Isolate* m_isolate = nullptr;\r\n\r\n    // Statistics\r\n    std::atomic<uint64_t> m_totalUpdates{0};\r\n    RunningAverage<float, 60> m_updateTimes;  // Rolling average\r\n};\r\n```\r\n\r\n**Dependencies**:\r\n- `<thread>` for std::thread\r\n- `<atomic>` for stop signaling\r\n- V8 headers for isolate management\r\n- ScriptSubsystem for JavaScript execution\r\n\r\n**Reuses**:\r\n- ScriptSubsystem::ExecuteCommand() for JavaScript invocation\r\n- Existing EntityStateBuffer::GetFrontBuffer() read-only access\r\n- Existing RenderCommandQueue::Submit() for JS→C++ commands\r\n\r\n**Design Rationale**:\r\n- Owns std::thread lifetime (RAII pattern)\r\n- References buffers/queues via pointers (not owned)\r\n- Separate V8 isolate for thread safety (V8::Locker)\r\n- Graceful shutdown via atomic stop flag\r\n\r\n---\r\n\r\n### Component 3: RenderResourceManager (New)\r\n\r\n**Purpose**: Manages render-specific resources (vertex buffers, textures) separate from EntityState\r\n\r\n**File Location**: `C:\\p4\\Personal\\SD\\ProtogameJS3D\\Code\\Game\\Framework\\RenderResourceManager.hpp`\r\n\r\n**Public Interface**:\r\n```cpp\r\nclass RenderResourceManager {\r\npublic:\r\n    // Resource Assignment\r\n    void AssignVertexBuffer(EntityID entityId, int vertexBufferHandle);\r\n    void AssignTexture(EntityID entityId, int textureHandle);\r\n\r\n    // Resource Retrieval\r\n    int GetVertexBuffer(EntityID entityId) const;\r\n    int GetTexture(EntityID entityId) const;\r\n    bool HasVertexBuffer(EntityID entityId) const;\r\n    bool HasTexture(EntityID entityId) const;\r\n\r\n    // Resource Cleanup\r\n    void RemoveEntity(EntityID entityId);\r\n    void Clear();\r\n\r\n    // Monitoring\r\n    size_t GetEntityCount() const;\r\n\r\nprivate:\r\n    std::unordered_map<EntityID, int> m_vertexBuffers;  // EntityID → VBO handle\r\n    std::unordered_map<EntityID, int> m_textures;       // EntityID → Texture handle\r\n\r\n    mutable std::mutex m_mutex;  // Thread safety (if needed)\r\n};\r\n```\r\n\r\n**Dependencies**:\r\n- `<unordered_map>` for EntityID → handle mapping\r\n- `Engine/Entity/EntityID.hpp` for EntityID type\r\n\r\n**Reuses**:\r\n- EntityID type from existing Entity system\r\n- std::unordered_map pattern from EntityStateMap\r\n\r\n**Design Rationale**:\r\n- C++ only (JavaScript never accesses)\r\n- Separates render resources from game state (Single Responsibility)\r\n- Allows EntityState to be pure game data\r\n- Fast O(1) lookup during rendering\r\n\r\n---\r\n\r\n### Component 4: StateBuffer with Dirty Tracking (Modified)\r\n\r\n**Purpose**: Extend existing StateBuffer with optional dirty tracking optimization\r\n\r\n**File Location**: `C:\\p4\\Personal\\SD\\Engine\\Code\\Engine\\Core\\StateBuffer.hpp`\r\n\r\n**New Public Interface** (additions only):\r\n```cpp\r\ntemplate <typename TStateContainer>\r\nclass StateBuffer {\r\npublic:\r\n    // ... existing methods ...\r\n\r\n    // Dirty Tracking (Phase 4)\r\n    void MarkDirty(typename TStateContainer::key_type const& key);\r\n    void ClearDirtyTracking();\r\n    bool IsDirtyTrackingEnabled() const;\r\n    void EnableDirtyTracking(bool enable);\r\n\r\n    // Statistics\r\n    size_t GetDirtyCount() const;\r\n    float GetAverageDirtyRatio() const;  // dirty / total entities\r\n\r\nprivate:\r\n    // Dirty tracking state\r\n    std::unordered_set<typename TStateContainer::key_type> m_dirtyKeys;\r\n    bool m_dirtyTrackingEnabled = false;\r\n\r\n    // Statistics\r\n    RunningAverage<float, 60> m_dirtyRatios;  // Last 60 frames\r\n};\r\n```\r\n\r\n**Dependencies**:\r\n- `<unordered_set>` for dirty key tracking\r\n- Existing TStateContainer::key_type (EntityID or std::string)\r\n\r\n**Reuses**:\r\n- Existing SwapBuffers() algorithm\r\n- Existing double-buffer storage (m_bufferA, m_bufferB)\r\n\r\n**Design Rationale**:\r\n- Backward compatible (dirty tracking optional, disabled by default)\r\n- No performance impact when disabled\r\n- Significant win when enabled: O(d) vs O(n) where d << n\r\n- Statistics help validate optimization effectiveness\r\n\r\n---\r\n\r\n### Component 5: EntityAPI Callback Integration (Modified)\r\n\r\n**Purpose**: Change ExecutePendingCallbacks() to use CallbackQueue\r\n\r\n**File Location**: `C:\\p4\\Personal\\SD\\Engine\\Code\\Engine\\Entity\\EntityAPI.cpp`\r\n\r\n**Modified Method**:\r\n```cpp\r\n// Current (Phase 1) - Synchronous blocking\r\nvoid EntityAPI::ExecutePendingCallbacks() {\r\n    for (auto& [callbackId, pending] : m_pendingCallbacks) {\r\n        if (pending.ready) {\r\n            ExecuteCallback(callbackId, pending.resultId);  // ← Blocks C++ thread\r\n            pending.executed = true;\r\n        }\r\n    }\r\n    // Cleanup executed callbacks\r\n    std::erase_if(m_pendingCallbacks, [](auto const& pair) {\r\n        return pair.second.executed;\r\n    });\r\n}\r\n\r\n// Target (Phase 2) - Async queue\r\nvoid EntityAPI::ExecutePendingCallbacks(CallbackQueue* callbackQueue) {\r\n    for (auto& [callbackId, pending] : m_pendingCallbacks) {\r\n        if (pending.ready) {\r\n            CallbackQueue::CallbackData data{\r\n                .callbackId = callbackId,\r\n                .resultId = pending.resultId,\r\n                .errorMessage = pending.errorMsg,\r\n                .type = CallbackType::ENTITY_CREATED\r\n            };\r\n\r\n            bool enqueued = callbackQueue->Enqueue(data);  // ← Never blocks\r\n            if (!enqueued) {\r\n                LogWarning(\"CallbackQueue full - dropped callback %llu\", callbackId);\r\n            }\r\n\r\n            pending.executed = true;\r\n        }\r\n    }\r\n    // Cleanup executed callbacks\r\n    std::erase_if(m_pendingCallbacks, [](auto const& pair) {\r\n        return pair.second.executed;\r\n    });\r\n}\r\n```\r\n\r\n**Dependencies**:\r\n- CallbackQueue pointer (passed from App)\r\n- Existing m_pendingCallbacks map\r\n\r\n**Reuses**:\r\n- Existing callback ID management\r\n- Existing PendingCallback structure\r\n\r\n**Design Rationale**:\r\n- Minimal change to existing code\r\n- Non-blocking enqueue operation\r\n- Graceful degradation if queue full (log warning, continue)\r\n\r\n---\r\n\r\n### Component 6: JavaScript Callback Processing (Modified)\r\n\r\n**Purpose**: Add callback dequeue and execution to JavaScript update loop\r\n\r\n**File Location**: `C:\\p4\\Personal\\SD\\ProtogameJS3D\\Run\\Data\\Scripts\\JSEngine.js`\r\n\r\n**New Code**:\r\n```javascript\r\n// At start of JSEngine.update()\r\nJSEngine.update = function(deltaTime) {\r\n    // Phase 2: Process callbacks from C++\r\n    if (typeof globalThis.CallbackQueue !== 'undefined') {\r\n        while (true) {\r\n            let callback = CallbackQueue.dequeue();\r\n            if (!callback) break;  // Queue empty\r\n\r\n            try {\r\n                executeCallback(callback.callbackId, callback.resultId, callback.errorMessage);\r\n            } catch (e) {\r\n                console.error('Callback execution failed:', e);\r\n                // Don't propagate - continue processing other callbacks\r\n            }\r\n        }\r\n    }\r\n\r\n    // Existing update logic\r\n    // ...\r\n};\r\n\r\nfunction executeCallback(callbackId, resultId, errorMessage) {\r\n    // Find callback in pending map\r\n    let callbackFunc = g_pendingCallbacks.get(callbackId);\r\n    if (!callbackFunc) {\r\n        console.warn('Callback not found:', callbackId);\r\n        return;\r\n    }\r\n\r\n    // Execute callback\r\n    if (errorMessage && errorMessage.length > 0) {\r\n        console.error('C++ reported error:', errorMessage);\r\n        // Call callback with error\r\n        if (callbackFunc.errorHandler) {\r\n            callbackFunc.errorHandler(errorMessage);\r\n        }\r\n    } else {\r\n        // Call callback with result\r\n        callbackFunc(resultId);\r\n    }\r\n\r\n    // Cleanup\r\n    g_pendingCallbacks.delete(callbackId);\r\n}\r\n```\r\n\r\n**Dependencies**:\r\n- Native CallbackQueue binding (exposed by V8Subsystem)\r\n- Existing g_pendingCallbacks map\r\n\r\n**Reuses**:\r\n- Existing callback registration pattern\r\n- Existing error handling conventions\r\n\r\n**Design Rationale**:\r\n- Process callbacks before game logic (callbacks may affect state)\r\n- Try-catch prevents callback errors from stopping update loop\r\n- Graceful handling of missing callbacks (log warning, continue)\r\n\r\n## Data Models\r\n\r\n### Model 1: CallbackData\r\n\r\n**Purpose**: Data structure for C++→JavaScript callback messages\r\n\r\n```cpp\r\nstruct CallbackData {\r\n    CallbackID   callbackId;      // uint64_t: Unique callback identifier\r\n    uint64_t     resultId;        // EntityID or CameraID returned from C++\r\n    std::string  errorMessage;    // Empty = success, non-empty = error description\r\n    CallbackType type;            // enum: ENTITY_CREATED, CAMERA_CREATED, RESOURCE_LOADED\r\n};\r\n\r\nenum class CallbackType : uint8_t {\r\n    ENTITY_CREATED,\r\n    CAMERA_CREATED,\r\n    RESOURCE_LOADED,\r\n    GENERIC\r\n};\r\n```\r\n\r\n**Size**: ~40 bytes (8+8+24+4 with padding)\r\n\r\n**Thread Safety**: Immutable after construction, copied into queue\r\n\r\n**Design Rationale**:\r\n- CallbackID matches JavaScript callback registration\r\n- resultId is 53-bit safe for JavaScript Number type\r\n- errorMessage allows detailed error reporting\r\n- CallbackType enables type-specific handling\r\n\r\n---\r\n\r\n### Model 2: EntityState (Modified)\r\n\r\n**Purpose**: Pure game state structure (render resources removed)\r\n\r\n```cpp\r\n// Before (Phase 1)\r\nstruct EntityState {\r\n    Vec3        position;           // ✅ Game state\r\n    EulerAngles orientation;        // ✅ Game state\r\n    Rgba8       color;              // ✅ Game state\r\n    float       radius;             // ✅ Game state\r\n    std::string meshType;           // ⚠️ Configuration\r\n    bool        isActive;           // ✅ Game state\r\n    int         vertexBufferHandle; // ❌ C++ render resource\r\n    std::string cameraType;         // ⚠️ Configuration\r\n};\r\n\r\n// After (Phase 2+)\r\nstruct EntityState {\r\n    Vec3        position;           // ✅ Game state\r\n    EulerAngles orientation;        // ✅ Game state\r\n    Rgba8       color;              // ✅ Game state\r\n    float       radius;             // ✅ Game state\r\n    std::string meshType;           // ✅ Configuration\r\n    bool        isActive;           // ✅ Game state\r\n    std::string cameraType;         // ✅ Configuration\r\n    // vertexBufferHandle moved to RenderResourceManager\r\n};\r\n```\r\n\r\n**Size Reduction**: 72 bytes → 68 bytes (4 byte savings per entity)\r\n\r\n**Design Rationale**:\r\n- EntityState visible to JavaScript (pure game data only)\r\n- Render resources hidden in RenderResourceManager (C++ only)\r\n- Cleaner separation of concerns (Single Responsibility)\r\n\r\n---\r\n\r\n### Model 3: DirtySet (Phase 4)\r\n\r\n**Purpose**: Track which entities were modified this frame\r\n\r\n```cpp\r\ntemplate <typename TStateContainer>\r\nclass StateBuffer {\r\nprivate:\r\n    std::unordered_set<typename TStateContainer::key_type> m_dirtyKeys;\r\n    bool m_dirtyTrackingEnabled = false;\r\n};\r\n```\r\n\r\n**For EntityStateBuffer**: `std::unordered_set<EntityID>`\r\n**For CameraStateBuffer**: `std::unordered_set<std::string>`\r\n\r\n**Memory Overhead**: 8 bytes per dirty entity + hash table overhead\r\n\r\n**Design Rationale**:\r\n- Fast O(1) insert for MarkDirty()\r\n- Fast O(d) iteration during SwapBuffers()\r\n- Clear after swap (reuse for next frame)\r\n\r\n## Error Handling\r\n\r\n### Error Scenario 1: SwapBuffers() Copy Fails\r\n\r\n**Description**: std::unordered_map copy assignment throws (out of memory, etc.)\r\n\r\n**Handling**:\r\n```cpp\r\nvoid StateBuffer::SwapBuffers() {\r\n    try {\r\n        std::lock_guard lock(m_swapMutex);\r\n\r\n        // Validate before swap\r\n        if (!ValidateStateBuffer(m_backBuffer)) {\r\n            LogError(\"Back buffer validation failed - skipping swap\");\r\n            return;  // Keep using old front buffer\r\n        }\r\n\r\n        // Copy with exception safety\r\n        *m_frontBuffer = *m_backBuffer;\r\n        std::swap(m_frontBuffer, m_backBuffer);\r\n        ++m_totalSwaps;\r\n    }\r\n    catch (std::exception const& e) {\r\n        LogError(\"SwapBuffers failed: %s\", e.what());\r\n        // Don't propagate - renderer uses stale front buffer\r\n        // Game continues with last known good state\r\n    }\r\n}\r\n\r\nbool StateBuffer::ValidateStateBuffer(TStateContainer const* buffer) const {\r\n    if (!buffer) return false;\r\n    if (buffer->size() > MAX_ENTITIES) {\r\n        LogError(\"Buffer size exceeds limit: %zu > %zu\", buffer->size(), MAX_ENTITIES);\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n```\r\n\r\n**User Impact**: One frame renders with stale state, then recovers\r\n\r\n**Recovery**: Next frame's swap may succeed, system self-heals\r\n\r\n---\r\n\r\n### Error Scenario 2: JavaScript Exception During Update\r\n\r\n**Description**: JavaScript code throws error (null reference, type error, etc.)\r\n\r\n**Handling**:\r\n```cpp\r\nvoid Game::UpdateJSWorkerThread(float deltaTime, EntityStateBuffer* entityBuffer,\r\n                                 RenderCommandQueue* commandQueue) {\r\n    v8::Isolate* isolate = v8::Isolate::GetCurrent();\r\n    v8::HandleScope handleScope(isolate);\r\n    v8::TryCatch tryCatch(isolate);\r\n\r\n    // Execute JavaScript update\r\n    String command = StringFormat(\"globalThis.JSEngine.update(%f);\", deltaTime);\r\n    bool success = g_scriptSubsystem->ExecuteCommand(command);\r\n\r\n    if (!success || tryCatch.HasCaught()) {\r\n        HandleJSException(tryCatch);\r\n        // Continue execution - C++ rendering unaffected\r\n    }\r\n}\r\n\r\nvoid Game::HandleJSException(v8::TryCatch& tryCatch) {\r\n    v8::Isolate* isolate = v8::Isolate::GetCurrent();\r\n    v8::String::Utf8Value exception(isolate, tryCatch.Exception());\r\n    v8::Local<v8::Message> message = tryCatch.Message();\r\n\r\n    // Extract error details\r\n    String errorMsg(*exception);\r\n    String filename = \"unknown\";\r\n    int linenum = 0;\r\n\r\n    if (!message.IsEmpty()) {\r\n        v8::String::Utf8Value filenameUtf8(isolate, message->GetScriptResourceName());\r\n        filename = *filenameUtf8;\r\n        linenum = message->GetLineNumber(isolate->GetCurrentContext()).FromMaybe(0);\r\n    }\r\n\r\n    // Log detailed error\r\n    LogError(\"JavaScript Exception: %s\", errorMsg.c_str());\r\n    LogError(\"  at %s:%d\", filename.c_str(), linenum);\r\n\r\n    // Optional: Send error to telemetry system\r\n    // g_telemetry->ReportJavaScriptError(errorMsg, filename, linenum);\r\n\r\n    // Don't crash - game continues with last valid state\r\n}\r\n```\r\n\r\n**User Impact**: JavaScript logic pauses for one frame, C++ rendering continues\r\n\r\n**Recovery**: Next frame JavaScript may succeed, or error persists (logged repeatedly)\r\n\r\n---\r\n\r\n### Error Scenario 3: CallbackQueue Full\r\n\r\n**Description**: C++ enqueues callbacks faster than JavaScript processes them\r\n\r\n**Handling**:\r\n```cpp\r\nvoid EntityAPI::ExecutePendingCallbacks(CallbackQueue* callbackQueue) {\r\n    for (auto& [callbackId, pending] : m_pendingCallbacks) {\r\n        if (pending.ready) {\r\n            CallbackQueue::CallbackData data{/* ... */};\r\n\r\n            bool enqueued = callbackQueue->Enqueue(data);\r\n            if (!enqueued) {\r\n                // Queue full - drop callback and log warning\r\n                LogWarning(\"CallbackQueue full (capacity: %zu) - dropped callback %llu\",\r\n                           callbackQueue->GetCapacity(), callbackId);\r\n\r\n                // Optional: Send error callback to JavaScript\r\n                CallbackQueue::CallbackData errorData{\r\n                    .callbackId = callbackId,\r\n                    .resultId = 0,\r\n                    .errorMessage = \"CallbackQueue full - callback dropped\",\r\n                    .type = pending.type\r\n                };\r\n                // Try to enqueue error (may also fail if queue full)\r\n                callbackQueue->Enqueue(errorData);\r\n            }\r\n\r\n            pending.executed = true;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**User Impact**: Callback not executed, JavaScript may wait indefinitely for result\r\n\r\n**Mitigation**: Increase CallbackQueue capacity (default 100 → 500)\r\n\r\n**Detection**: Monitor GetApproximateSize(), alert if > 80% capacity\r\n\r\n---\r\n\r\n### Error Scenario 4: Worker Thread Deadlock\r\n\r\n**Description**: Mutex timeout or circular wait between main and worker threads\r\n\r\n**Handling**:\r\n```cpp\r\nvoid JavaScriptWorkerThread::Stop() {\r\n    // Signal stop\r\n    m_stopRequested.store(true, std::memory_order_release);\r\n\r\n    // Join with timeout\r\n    constexpr auto TIMEOUT = std::chrono::seconds(5);\r\n\r\n    if (m_workerThread.joinable()) {\r\n        auto start = std::chrono::steady_clock::now();\r\n\r\n        while (m_isRunning.load(std::memory_order_acquire)) {\r\n            std::this_thread::sleep_for(std::chrono::milliseconds(100));\r\n\r\n            auto elapsed = std::chrono::steady_clock::now() - start;\r\n            if (elapsed > TIMEOUT) {\r\n                LogError(\"Worker thread deadlock detected - timeout after 5s\");\r\n                LogError(\"Forcing thread termination (unsafe)\");\r\n\r\n                // Last resort: detach thread (memory leak, but prevent hang)\r\n                m_workerThread.detach();\r\n                return;\r\n            }\r\n        }\r\n\r\n        m_workerThread.join();\r\n    }\r\n}\r\n```\r\n\r\n**User Impact**: Application may hang on shutdown, or force terminate worker\r\n\r\n**Prevention**: No nested locks, brief locked sections only, timeout detection\r\n\r\n---\r\n\r\n### Error Scenario 5: Dirty Tracking Desync\r\n\r\n**Description**: Entity marked dirty but not in backBuffer, or vice versa\r\n\r\n**Handling**:\r\n```cpp\r\nvoid StateBuffer::SwapBuffers() {\r\n    std::lock_guard lock(m_swapMutex);\r\n\r\n    if (m_dirtyTrackingEnabled) {\r\n        // Validate dirty set before copying\r\n        for (auto const& dirtyKey : m_dirtyKeys) {\r\n            if (m_backBuffer->find(dirtyKey) == m_backBuffer->end()) {\r\n                LogWarning(\"Dirty key not in backBuffer: %llu - removing from dirty set\", dirtyKey);\r\n                m_dirtyKeys.erase(dirtyKey);\r\n            }\r\n        }\r\n\r\n        // Copy only dirty entities\r\n        for (auto const& dirtyKey : m_dirtyKeys) {\r\n            auto it = m_backBuffer->find(dirtyKey);\r\n            if (it != m_backBuffer->end()) {\r\n                (*m_frontBuffer)[dirtyKey] = it->second;\r\n            } else {\r\n                // Entity deleted - remove from front buffer\r\n                m_frontBuffer->erase(dirtyKey);\r\n            }\r\n        }\r\n\r\n        m_dirtyKeys.clear();\r\n    } else {\r\n        // Full copy fallback (always correct)\r\n        *m_frontBuffer = *m_backBuffer;\r\n    }\r\n\r\n    std::swap(m_frontBuffer, m_backBuffer);\r\n    ++m_totalSwaps;\r\n}\r\n```\r\n\r\n**User Impact**: Entity may render with stale state for one frame\r\n\r\n**Recovery**: Self-cleaning logic removes invalid dirty keys\r\n\r\n**Validation**: Add debug mode that compares dirty-copy vs full-copy results\r\n\r\n## Testing Strategy\r\n\r\n### Unit Testing\r\n\r\n**CallbackQueue Tests** (`Engine/Tests/Core/CallbackQueueTests.cpp`):\r\n```cpp\r\nTEST(CallbackQueue, EnqueueDequeue) {\r\n    CallbackQueue queue(10);\r\n\r\n    CallbackQueue::CallbackData data{1, 42, \"\", CallbackType::ENTITY_CREATED};\r\n    EXPECT_TRUE(queue.Enqueue(data));\r\n    EXPECT_EQ(queue.GetApproximateSize(), 1);\r\n\r\n    bool processed = false;\r\n    queue.DequeueAll([&](CallbackQueue::CallbackData const& cb) {\r\n        EXPECT_EQ(cb.callbackId, 1);\r\n        EXPECT_EQ(cb.resultId, 42);\r\n        processed = true;\r\n    });\r\n\r\n    EXPECT_TRUE(processed);\r\n    EXPECT_TRUE(queue.IsEmpty());\r\n}\r\n\r\nTEST(CallbackQueue, BackpressureWhenFull) {\r\n    CallbackQueue queue(2);\r\n\r\n    CallbackQueue::CallbackData data{1, 0, \"\", CallbackType::GENERIC};\r\n\r\n    EXPECT_TRUE(queue.Enqueue(data));  // 1st succeeds\r\n    EXPECT_TRUE(queue.Enqueue(data));  // 2nd succeeds (full)\r\n    EXPECT_FALSE(queue.Enqueue(data)); // 3rd fails (backpressure)\r\n}\r\n```\r\n\r\n**StateBuffer Dirty Tracking Tests** (`Engine/Tests/Core/StateBufferTests.cpp`):\r\n```cpp\r\nTEST(StateBuffer, DirtyTrackingReducesCopies) {\r\n    using TestMap = std::unordered_map<uint64_t, int>;\r\n    StateBuffer<TestMap> buffer;\r\n    buffer.EnableDirtyTracking(true);\r\n\r\n    // Create 1000 entities in back buffer\r\n    auto* backBuffer = buffer.GetBackBuffer();\r\n    for (uint64_t i = 0; i < 1000; ++i) {\r\n        (*backBuffer)[i] = static_cast<int>(i);\r\n    }\r\n\r\n    // Swap (full copy first time)\r\n    buffer.SwapBuffers();\r\n\r\n    // Mark only 10 entities dirty\r\n    backBuffer = buffer.GetBackBuffer();\r\n    for (uint64_t i = 0; i < 10; ++i) {\r\n        (*backBuffer)[i] = 999;\r\n        buffer.MarkDirty(i);\r\n    }\r\n\r\n    // Swap (should only copy 10 entities)\r\n    auto startTime = std::chrono::high_resolution_clock::now();\r\n    buffer.SwapBuffers();\r\n    auto endTime = std::chrono::high_resolution_clock::now();\r\n\r\n    // Verify front buffer has updated values\r\n    auto const* frontBuffer = buffer.GetFrontBuffer();\r\n    for (uint64_t i = 0; i < 10; ++i) {\r\n        EXPECT_EQ(frontBuffer->at(i), 999);\r\n    }\r\n\r\n    // Performance should be much better than full copy\r\n    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(endTime - startTime);\r\n    EXPECT_LT(duration.count(), 100);  // < 100µs for 10 entities\r\n}\r\n```\r\n\r\n**RenderResourceManager Tests** (`Game/Tests/Framework/RenderResourceManagerTests.cpp`):\r\n```cpp\r\nTEST(RenderResourceManager, AssignAndRetrieve) {\r\n    RenderResourceManager manager;\r\n\r\n    EntityID id = 42;\r\n    int vboHandle = 123;\r\n\r\n    manager.AssignVertexBuffer(id, vboHandle);\r\n    EXPECT_TRUE(manager.HasVertexBuffer(id));\r\n    EXPECT_EQ(manager.GetVertexBuffer(id), vboHandle);\r\n}\r\n\r\nTEST(RenderResourceManager, RemoveEntityCleansUp) {\r\n    RenderResourceManager manager;\r\n\r\n    manager.AssignVertexBuffer(42, 123);\r\n    manager.AssignTexture(42, 456);\r\n\r\n    manager.RemoveEntity(42);\r\n\r\n    EXPECT_FALSE(manager.HasVertexBuffer(42));\r\n    EXPECT_FALSE(manager.HasTexture(42));\r\n}\r\n```\r\n\r\n### Integration Testing\r\n\r\n**Worker Thread JavaScript Execution** (`Integration/WorkerThreadTests.cpp`):\r\n```cpp\r\nTEST(Integration, JavaScriptRunsOnWorkerThread) {\r\n    // Setup\r\n    Game game;\r\n    EntityStateBuffer entityBuffer;\r\n    RenderCommandQueue renderQueue;\r\n    CallbackQueue callbackQueue;\r\n    JavaScriptWorkerThread worker(&g_scriptSubsystem, &entityBuffer,\r\n                                    nullptr, &renderQueue, &callbackQueue);\r\n\r\n    // Start worker thread\r\n    worker.Start();\r\n\r\n    // Main thread continues independently\r\n    for (int frame = 0; frame < 60; ++frame) {\r\n        // Simulate C++ rendering at 60 FPS\r\n        std::this_thread::sleep_for(std::chrono::milliseconds(16));\r\n        entityBuffer.SwapBuffers();\r\n    }\r\n\r\n    // Verify worker thread executed updates\r\n    EXPECT_GT(worker.GetTotalUpdates(), 0);\r\n\r\n    // Stop worker thread\r\n    worker.Stop();\r\n    EXPECT_FALSE(worker.IsRunning());\r\n}\r\n```\r\n\r\n**Callback Round-Trip** (`Integration/CallbackRoundTripTests.cpp`):\r\n```cpp\r\nTEST(Integration, CallbackRoundTrip) {\r\n    // JavaScript creates entity\r\n    String jsCode = R\"(\r\n        EntityAPI.createMesh('cube', {x: 0, y: 0, z: 0}, 1.0,\r\n                             {r: 255, g: 0, b: 0, a: 255},\r\n                             function(entityId) {\r\n                                 globalThis.testEntityId = entityId;\r\n                             });\r\n    )\";\r\n\r\n    g_scriptSubsystem->ExecuteCommand(jsCode);\r\n\r\n    // C++ processes command\r\n    g_app->ProcessRenderCommands();\r\n\r\n    // C++ enqueues callback\r\n    g_entityAPI->ExecutePendingCallbacks(&g_callbackQueue);\r\n\r\n    // JavaScript processes callback\r\n    g_game->UpdateJSWorkerThread(0.016f, &g_entityBuffer, &g_renderQueue);\r\n\r\n    // Verify JavaScript received entityId\r\n    v8::Local<v8::Value> result = GetGlobalProperty(\"testEntityId\");\r\n    EXPECT_TRUE(result->IsNumber());\r\n    EXPECT_GT(result->NumberValue(), 0);\r\n}\r\n```\r\n\r\n### End-to-End Testing\r\n\r\n**Full Frame Execution** (`E2E/FullFrameTests.cpp`):\r\n```cpp\r\nTEST(E2E, CompleteFrameExecution) {\r\n    // Frame N\r\n\r\n    // 1. Worker thread: JavaScript updates entities\r\n    g_workerThread->WorkerThreadLoop();  // One iteration\r\n\r\n    // 2. Main thread: Process render commands\r\n    g_app->ProcessRenderCommands();\r\n\r\n    // 3. Main thread: Enqueue callbacks\r\n    g_entityAPI->ExecutePendingCallbacks(&g_callbackQueue);\r\n\r\n    // 4. Main thread: Render\r\n    g_app->Render();\r\n\r\n    // 5. Main thread: Swap buffers\r\n    g_entityBuffer->SwapBuffers();\r\n\r\n    // Verify no crashes, no deadlocks, frame completes < 16ms\r\n}\r\n```\r\n\r\n**Error Recovery** (`E2E/ErrorRecoveryTests.cpp`):\r\n```cpp\r\nTEST(E2E, JavaScriptErrorDoesNotCrashCPP) {\r\n    // Execute JavaScript code that throws\r\n    String jsCode = \"throw new Error('Intentional test error');\";\r\n\r\n    // Should not crash, should log error\r\n    EXPECT_NO_FATAL_FAILURE({\r\n        g_scriptSubsystem->ExecuteCommand(jsCode);\r\n    });\r\n\r\n    // C++ rendering continues\r\n    EXPECT_NO_THROW({\r\n        g_app->Render();\r\n    });\r\n}\r\n\r\nTEST(E2E, SwapBuffersFailureDoesNotCrash) {\r\n    // Inject failure into SwapBuffers (mock)\r\n    g_entityBuffer->InjectFailure(true);\r\n\r\n    // Should not crash, should log error\r\n    EXPECT_NO_FATAL_FAILURE({\r\n        g_entityBuffer->SwapBuffers();\r\n    });\r\n\r\n    // Next frame may succeed\r\n    g_entityBuffer->InjectFailure(false);\r\n    EXPECT_NO_THROW({\r\n        g_entityBuffer->SwapBuffers();\r\n    });\r\n}\r\n```\r\n\r\n### Performance Benchmarks\r\n\r\n**Dirty Tracking Benchmark** (`Benchmarks/DirtyTrackingBenchmark.cpp`):\r\n```cpp\r\nBENCHMARK(SwapBuffers_FullCopy_1000Entities) {\r\n    StateBuffer<EntityStateMap> buffer;\r\n    buffer.EnableDirtyTracking(false);\r\n\r\n    // Setup 1000 entities\r\n    SetupEntities(buffer.GetBackBuffer(), 1000);\r\n\r\n    // Measure swap time\r\n    auto start = std::chrono::high_resolution_clock::now();\r\n    buffer.SwapBuffers();\r\n    auto end = std::chrono::high_resolution_clock::now();\r\n\r\n    return std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();\r\n}\r\n\r\nBENCHMARK(SwapBuffers_DirtyOnly_10Entities) {\r\n    StateBuffer<EntityStateMap> buffer;\r\n    buffer.EnableDirtyTracking(true);\r\n\r\n    // Setup 1000 entities, mark 10 dirty\r\n    SetupEntities(buffer.GetBackBuffer(), 1000);\r\n    buffer.SwapBuffers();  // First swap (full copy)\r\n\r\n    MarkEntitiesDirty(buffer, 10);\r\n\r\n    // Measure swap time (should be much faster)\r\n    auto start = std::chrono::high_resolution_clock::now();\r\n    buffer.SwapBuffers();\r\n    auto end = std::chrono::high_resolution_clock::now();\r\n\r\n    return std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();\r\n}\r\n\r\n// Expected Results:\r\n// FullCopy_1000Entities: ~500-1000µs\r\n// DirtyOnly_10Entities: ~20-50µs (10-20x faster)\r\n```\r\n\r\n### Thread Safety Validation\r\n\r\n**ThreadSanitizer Tests**:\r\n```bash\r\n# Build with ThreadSanitizer\r\ncmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DENABLE_TSAN=ON ..\r\nmake\r\n\r\n# Run tests under TSan\r\n./ProtogameJS3D_Tests --gtest_filter=Integration.*\r\n\r\n# Expected: No data race warnings\r\n# Common issues to watch for:\r\n# - Double-checked locking without acquire/release\r\n# - Missing atomic operations on shared flags\r\n# - False sharing between m_head and m_tail\r\n```\r\n\r\n**Lock-Free Progress Guarantee Tests**:\r\n```cpp\r\nTEST(ThreadSafety, QueueNeverBlocks) {\r\n    RenderCommandQueue queue;\r\n\r\n    std::atomic<bool> producerBlocked{false};\r\n    std::atomic<bool> consumerBlocked{false};\r\n\r\n    // Producer thread\r\n    std::thread producer([&]() {\r\n        for (int i = 0; i < 10000; ++i) {\r\n            auto start = std::chrono::steady_clock::now();\r\n\r\n            RenderCommand cmd{/*...*/};\r\n            queue.Submit(cmd);\r\n\r\n            auto elapsed = std::chrono::steady_clock::now() - start;\r\n            if (elapsed > std::chrono::milliseconds(10)) {\r\n                producerBlocked.store(true);\r\n            }\r\n        }\r\n    });\r\n\r\n    // Consumer thread\r\n    std::thread consumer([&]() {\r\n        for (int i = 0; i < 100; ++i) {\r\n            auto start = std::chrono::steady_clock::now();\r\n\r\n            queue.ConsumeAll([](auto const&) {});\r\n\r\n            auto elapsed = std::chrono::steady_clock::now() - start;\r\n            if (elapsed > std::chrono::milliseconds(10)) {\r\n                consumerBlocked.store(true);\r\n            }\r\n\r\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\r\n        }\r\n    });\r\n\r\n    producer.join();\r\n    consumer.join();\r\n\r\n    EXPECT_FALSE(producerBlocked.load());\r\n    EXPECT_FALSE(consumerBlocked.load());\r\n}\r\n```\r\n\r\n## Performance Targets\r\n\r\n### Phase 2 Targets\r\n\r\n| Metric | Target | Measurement |\r\n|--------|--------|-------------|\r\n| C++ Frame Rate | 60+ FPS | Stable, no drops when JS slows |\r\n| JS Update Rate | 30-60 FPS | Independent of C++ |\r\n| Callback Latency | < 1 frame | C++ enqueue → JS execute |\r\n| Queue Submit Time | < 1µs | RenderCommandQueue::Submit() |\r\n| Worker Thread Startup | < 100ms | Thread spawn + V8 isolate |\r\n\r\n### Phase 3 Targets\r\n\r\n| Metric | Target | Measurement |\r\n|--------|--------|-------------|\r\n| JS Error Recovery | 100% | No C++ crashes from JS errors |\r\n| SwapBuffers Error Recovery | 100% | Graceful degradation |\r\n| Callback Error Reporting | 100% | Errors reported to C++ |\r\n| Deadlock Detection | < 5s timeout | Detect and log hangs |\r\n\r\n### Phase 4 Targets\r\n\r\n| Metric | Target | Measurement |\r\n|--------|--------|-------------|\r\n| SwapBuffers Time (10 dirty) | < 50µs | 10 entities dirty out of 1000 |\r\n| SwapBuffers Time (100 dirty) | < 100µs | 100 entities dirty out of 1000 |\r\n| Dirty Ratio (typical) | < 10% | Average dirty entities per frame |\r\n| Memory Overhead | < 1KB | DirtySet storage |\r\n\r\n## Implementation Phases\r\n\r\n### Phase 2.1: CallbackQueue Implementation (4-6h)\r\n\r\n**Files to Create**:\r\n- `Engine/Code/Engine/Core/CallbackQueue.hpp`\r\n- `Engine/Code/Engine/Core/CallbackQueue.cpp`\r\n- `Engine/Tests/Core/CallbackQueueTests.cpp`\r\n\r\n**Acceptance Criteria**:\r\n- Enqueue/Dequeue work correctly\r\n- Thread-safe (passes TSan)\r\n- Backpressure when full\r\n- Unit tests pass\r\n\r\n### Phase 2.2: EntityAPI/CameraAPI Integration (2-3h)\r\n\r\n**Files to Modify**:\r\n- `Engine/Code/Engine/Entity/EntityAPI.cpp`\r\n- `Engine/Code/Engine/Renderer/CameraAPI.cpp`\r\n\r\n**Changes**:\r\n- Add `CallbackQueue*` parameter to ExecutePendingCallbacks()\r\n- Change direct callback execution to Enqueue()\r\n- Add backpressure logging\r\n\r\n**Acceptance Criteria**:\r\n- Callbacks enqueued instead of executed\r\n- No blocking on C++ thread\r\n- Integration tests pass\r\n\r\n### Phase 2.3: JavaScriptWorkerThread Implementation (6-8h)\r\n\r\n**Files to Create**:\r\n- `Game/Code/Game/Gameplay/JavaScriptWorkerThread.hpp`\r\n- `Game/Code/Game/Gameplay/JavaScriptWorkerThread.cpp`\r\n- `Game/Tests/Gameplay/JavaScriptWorkerThreadTests.cpp`\r\n\r\n**Acceptance Criteria**:\r\n- Worker thread spawns successfully\r\n- V8 isolate created on worker thread\r\n- UpdateJSWorkerThread() executes JavaScript\r\n- Graceful shutdown with stop signal\r\n- No deadlocks\r\n\r\n### Phase 2.4: JavaScript Callback Processing (3-4h)\r\n\r\n**Files to Modify**:\r\n- `Run/Data/Scripts/JSEngine.js`\r\n- `Run/Data/Scripts/interfaces/EntityAPI.js`\r\n- `Run/Data/Scripts/interfaces/CameraAPI.js`\r\n\r\n**Changes**:\r\n- Add CallbackQueue.dequeue() at start of update\r\n- Implement executeCallback() function\r\n- Add error handling for callback failures\r\n\r\n**Acceptance Criteria**:\r\n- Callbacks dequeued and executed\r\n- Errors logged, don't crash update loop\r\n- Round-trip tests pass\r\n\r\n### Phase 3.1: SwapBuffers Error Handling (2-3h)\r\n\r\n**Files to Modify**:\r\n- `Engine/Code/Engine/Core/StateBuffer.hpp`\r\n\r\n**Changes**:\r\n- Add ValidateStateBuffer() method\r\n- Wrap copy in try-catch\r\n- Add error logging\r\n\r\n**Acceptance Criteria**:\r\n- Exceptions caught and logged\r\n- Stale front buffer used on failure\r\n- No crashes\r\n\r\n### Phase 3.2: HandleJSException Implementation (3-4h)\r\n\r\n**Files to Modify**:\r\n- `Game/Code/Game/Gameplay/Game.cpp`\r\n\r\n**Changes**:\r\n- Implement HandleJSException() method\r\n- Add v8::TryCatch around JavaScript execution\r\n- Extract error details (message, stack trace, line number)\r\n\r\n**Acceptance Criteria**:\r\n- JavaScript errors logged with details\r\n- C++ continues execution\r\n- Error recovery tests pass\r\n\r\n### Phase 4.1: Dirty Tracking Implementation (4-6h)\r\n\r\n**Files to Modify**:\r\n- `Engine/Code/Engine/Core/StateBuffer.hpp`\r\n- `Engine/Tests/Core/StateBufferTests.cpp`\r\n\r\n**Changes**:\r\n- Add m_dirtyKeys, m_dirtyTrackingEnabled\r\n- Implement MarkDirty(), EnableDirtyTracking()\r\n- Modify SwapBuffers() to use dirty-only copy\r\n\r\n**Acceptance Criteria**:\r\n- Dirty tracking works correctly\r\n- Backward compatible (optional)\r\n- Unit tests pass\r\n- Benchmarks show 10-20x speedup\r\n\r\n### Phase 4.2: ProcessRenderCommands Integration (2-3h)\r\n\r\n**Files to Modify**:\r\n- `Game/Code/Game/Framework/App.cpp`\r\n\r\n**Changes**:\r\n- Call entityBuffer->MarkDirty(entityId) after updates\r\n- Enable dirty tracking: entityBuffer->EnableDirtyTracking(true)\r\n\r\n**Acceptance Criteria**:\r\n- Entities marked dirty on update\r\n- Integration tests pass\r\n- No visual artifacts\r\n\r\n### Phase 5: Remove vertexBufferHandle (4-5h)\r\n\r\n**Files to Create**:\r\n- `Game/Code/Game/Framework/RenderResourceManager.hpp`\r\n- `Game/Code/Game/Framework/RenderResourceManager.cpp`\r\n\r\n**Files to Modify**:\r\n- `Engine/Code/Engine/Entity/EntityState.hpp`\r\n- `Game/Code/Game/Framework/App.cpp`\r\n\r\n**Changes**:\r\n- Remove vertexBufferHandle from EntityState\r\n- Create RenderResourceManager with EntityID → VBO mapping\r\n- Update ProcessRenderCommands() to use RenderResourceManager\r\n\r\n**Acceptance Criteria**:\r\n- EntityState size reduced\r\n- Rendering works correctly\r\n- All tests pass\r\n\r\n### Documentation: AsyncArchitecturePhases.md (2-3h)\r\n\r\n**Files to Create**:\r\n- `Docs/architecture/AsyncArchitecturePhases.md`\r\n\r\n**Content**:\r\n- Phase 1: Infrastructure (completed)\r\n- Phase 2: Worker thread execution\r\n- Phase 3: Error recovery\r\n- Phase 4: Performance optimization\r\n- Diagrams, code examples, trade-offs\r\n\r\n**Acceptance Criteria**:\r\n- All phases documented\r\n- Diagrams included\r\n- Code examples accurate\r\n- Design rationales explained\r\n\r\n## Total Estimated Time\r\n\r\n- **Phase 2**: 15-21 hours\r\n- **Phase 3**: 5-7 hours\r\n- **Phase 4**: 6-9 hours\r\n- **Phase 5**: 4-5 hours\r\n- **Documentation**: 2-3 hours\r\n\r\n**Total**: 32-45 hours (across all phases)\r\n\r\n## Risk Mitigation Summary\r\n\r\n1. **V8 Thread Safety**: Use V8::Locker, one isolate per thread\r\n2. **Deadlock**: Timeout detection, no nested locks\r\n3. **Performance Regression**: Benchmark at each phase, keep fallbacks\r\n4. **Dirty Tracking Bugs**: Debug mode with full-copy validation\r\n5. **Queue Overflow**: Monitor size, alert at 80%, increase capacity\r\n\r\n## Success Metrics\r\n\r\n- ✅ C++ rendering: 60+ FPS stable (independent of JavaScript)\r\n- ✅ JavaScript worker thread: Runs independently at 30-60 FPS\r\n- ✅ No synchronous blocking: All communication via queues\r\n- ✅ Error isolation: JavaScript errors don't crash C++\r\n- ✅ Dirty tracking: 10-20x speedup for typical workloads (< 10% dirty)\r\n- ✅ All tests pass: Unit, integration, E2E\r\n- ✅ ThreadSanitizer clean: No data races detected\r\n- ✅ Documentation complete: AsyncArchitecturePhases.md\r\n",
  "fileStats": {
    "size": 47593,
    "lines": 1508,
    "lastModified": "2025-11-18T10:59:42.939Z"
  },
  "comments": []
}