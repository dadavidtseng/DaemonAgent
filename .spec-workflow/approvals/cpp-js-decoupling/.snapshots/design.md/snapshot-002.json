{
  "id": "snapshot_1763474547270_qvuyyk0ba",
  "approvalId": "approval_1763473569883_k5rqc336i",
  "approvalTitle": "Design Document for C++/JavaScript Decoupling (Phase 1-4)",
  "version": 2,
  "timestamp": "2025-11-18T14:02:27.270Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: C++/JavaScript Decoupling Architecture (Phase 1-4)\r\n\r\n## Overview\r\n\r\nThis design implements the complete Phase 1-4 roadmap for C++/JavaScript decoupling in ProtogameJS3D's dual-language game engine. The goal is to achieve true thread independence where C++ rendering (main thread) and JavaScript game logic (worker thread) run at independent speeds with fully asynchronous bidirectional communication.\r\n\r\n**Current State (Phase 1 - Complete ✅)**:\r\n- Async infrastructure: EntityStateBuffer, CameraStateBuffer, RenderCommandQueue\r\n- JavaScript → C++ async via lock-free SPSC queue\r\n- M4-T8 refactoring: Entity/Camera systems in Engine repository\r\n\r\n**Target State (Phase 2-4 - This Design)**:\r\n- **Phase 2**: JavaScript on worker thread, async C++→JS callbacks via CallbackQueue\r\n- **Phase 3**: Error recovery and exception handling for robustness\r\n- **Phase 4**: Dirty tracking optimization to reduce SwapBuffers() cost from O(n) to O(d)\r\n- **Additional**: Remove vertexBufferHandle from EntityState, formal documentation\r\n\r\n**Architecture Philosophy**:\r\n- **Lock-Free Hot Paths**: No locks during entity updates or rendering\r\n- **Brief Locked Synchronization**: Only during buffer swap (< 100µs)\r\n- **Fault Isolation**: JavaScript errors don't crash C++, C++ errors don't corrupt JavaScript\r\n- **Incremental Implementation**: Each phase builds on previous, independently testable\r\n\r\n## Steering Document Alignment\r\n\r\n### Technical Standards\r\n\r\n**Thread Safety Standards**:\r\n- SPSC queue pattern for single-producer/single-consumer communication\r\n- Cache-line separation to prevent false sharing (64-byte alignment)\r\n- Atomic operations with appropriate memory ordering (acquire/release semantics)\r\n- No blocking operations in hot paths\r\n\r\n**Performance Standards**:\r\n- C++ rendering: Maintain 60+ FPS regardless of JavaScript performance\r\n- Queue operations: < 1µs per operation\r\n- SwapBuffers: < 100µs with dirty tracking (Phase 4)\r\n- Memory overhead: < 2× for double-buffering\r\n\r\n**Code Quality Standards**:\r\n- C++20 features with full conformance\r\n- RAII patterns for resource management\r\n- Exception safety guarantees (basic or strong)\r\n- Professional documentation with design rationales\r\n\r\n### Project Structure\r\n\r\n**Engine Repository** (`C:\\p4\\Personal\\SD\\Engine\\`):\r\n- Core systems: `Code/Engine/Core/` - StateBuffer, CallbackQueue (new), thread utilities\r\n- Entity management: `Code/Engine/Entity/` - EntityAPI, EntityStateBuffer\r\n- Rendering: `Code/Engine/Renderer/` - CameraAPI, RenderCommandQueue\r\n- Script integration: `Code/Engine/Script/` - V8Subsystem, IJSGameLogicContext\r\n\r\n**Game Repository** (`C:\\p4\\Personal\\SD\\ProtogameJS3D\\`):\r\n- Application: `Code/Game/Framework/` - App.cpp, JSGameLogicJob (modified for CallbackQueue), RenderResourceManager (new)\r\n- Game logic: `Code/Game/Gameplay/` - Game.cpp (wire up TriggerNextFrame())\r\n- JavaScript: `Run/Data/Scripts/` - EntityAPI.js, CameraAPI.js, JSEngine.js (callback processing)\r\n\r\n## Code Reuse Analysis\r\n\r\n### Existing Components to Leverage\r\n\r\n**RenderCommandQueue Pattern** (`Engine/Renderer/RenderCommandQueue.hpp`):\r\n- Lock-free SPSC ring buffer implementation\r\n- Cache-line separated atomic indices (m_head, m_tail)\r\n- Template-based processor pattern (`ConsumeAll<ProcessorFunc>`)\r\n- **Reuse**: Duplicate this pattern for CallbackQueue (JS→C++ and C++→JS use same architecture)\r\n- **Extension**: Add error reporting fields to callback commands\r\n\r\n**StateBuffer Template** (`Engine/Core/StateBuffer.hpp`):\r\n- Generic double-buffering with front/back separation\r\n- SwapBuffers() with full O(n) copy\r\n- Thread-safe access pattern: GetFrontBuffer() read-only, GetBackBuffer() write-only\r\n- **Reuse**: Add dirty tracking fields without breaking existing API\r\n- **Extension**: MarkDirty(EntityID), GetDirtyEntities(), dirty-only swap\r\n\r\n**EntityAPI/CameraAPI Pattern** (`Engine/Entity/EntityAPI.hpp`):\r\n- RenderCommand submission via SubmitCommand()\r\n- Callback management via m_pendingCallbacks map\r\n- JavaScript binding via EntityScriptInterface\r\n- **Reuse**: Change ExecutePendingCallbacks() to use CallbackQueue instead of direct execution\r\n- **Extension**: Add error reporting when callbacks fail\r\n\r\n**V8Subsystem** (`Engine/Script/V8Subsystem.cpp`):\r\n- V8 isolate management\r\n- JavaScript execution via ExecuteCommand()\r\n- Module loading infrastructure\r\n- **Reuse**: Add V8::Locker for worker thread isolation\r\n- **Extension**: Worker thread isolate creation and management\r\n\r\n### Integration Points\r\n\r\n**Game::Update() → Worker Thread** (`Code/Game/Gameplay/Game.cpp`):\r\n- Currently: Calls `UpdateJS()` on main thread (line 68-74)\r\n- Target: Spawn worker thread, call `UpdateJSWorkerThread()` on worker\r\n- Integration: Replace direct V8 execution with thread signaling\r\n\r\n**App::ProcessRenderCommands() → RenderResourceManager** (`Code/Game/Framework/App.cpp`):\r\n- Currently: Writes vertexBufferHandle to EntityState\r\n- Target: Store vertexBufferHandle in RenderResourceManager\r\n- Integration: Map EntityID → vertexBufferHandle in C++ only\r\n\r\n**EntityAPI::ExecutePendingCallbacks() → CallbackQueue** (`Engine/Entity/EntityAPI.cpp`):\r\n- Currently: Directly executes callbacks, blocking C++ thread\r\n- Target: Enqueue callbacks to CallbackQueue for async processing\r\n- Integration: JavaScript dequeues and executes during update loop\r\n\r\n**JavaScript Update Loop** (`Run/Data/Scripts/JSEngine.js`):\r\n- Currently: Processes entity updates, renders\r\n- Target: Add callback processing at start of update loop\r\n- Integration: `while (let cb = CallbackQueue.dequeue()) { executeCallback(cb); }`\r\n\r\n## Architecture\r\n\r\n### Ownership Model\r\n\r\n**Critical Design Principle**: Clear ownership and dependency injection pattern\r\n\r\n| Component | Owner | Lifetime | Injection Target |\r\n|-----------|-------|----------|------------------|\r\n| **RenderCommandQueue** | App | App::Startup() → App::Shutdown() | JSGameLogicJob (producer), App (consumer) |\r\n| **CallbackQueue** | App | App::Startup() → App::Shutdown() | EntityAPI (producer), JSGameLogicJob (consumer via JS bindings) |\r\n| **EntityStateBuffer** | App | App::Startup() → App::Shutdown() | App (writer), JSGameLogicJob (reader) |\r\n| **JSGameLogicJob** | App | App::Startup() → App::Shutdown() | Owns worker thread |\r\n| **EntityAPI** | App | App::Startup() → App::Shutdown() | Receives queue pointers |\r\n\r\n**Ownership Pattern**:\r\n```cpp\r\nclass App {\r\nprivate:\r\n    // Infrastructure (owned by App)\r\n    RenderCommandQueue* m_renderCommandQueue = nullptr;  // JS→C++ commands\r\n    CallbackQueue* m_callbackQueue = nullptr;            // C++→JS callbacks\r\n    EntityStateBuffer* m_entityStateBuffer = nullptr;    // Double-buffered state\r\n\r\n    // Components (owned by App, receive pointers)\r\n    JSGameLogicJob* m_jsGameLogicJob = nullptr;          // Worker thread job\r\n    EntityAPI* m_entityAPI = nullptr;                    // Entity management\r\n\r\n    // App creates all infrastructure, injects into components\r\n    void Startup() {\r\n        m_renderCommandQueue = new RenderCommandQueue(QUEUE_CAPACITY);\r\n        m_callbackQueue = new CallbackQueue(CALLBACK_CAPACITY);\r\n        m_entityStateBuffer = new EntityStateBuffer();\r\n\r\n        m_jsGameLogicJob = new JSGameLogicJob(m_game, m_renderCommandQueue,\r\n                                               m_entityStateBuffer, m_callbackQueue);\r\n        m_entityAPI = new EntityAPI(m_renderCommandQueue, m_callbackQueue);\r\n    }\r\n};\r\n```\r\n\r\n**JavaScript Access Pattern**:\r\n- **JavaScript owns**: `g_pendingCallbacks` Map (pure JavaScript data structure)\r\n- **JavaScript accesses** (via V8 bindings): `CallbackQueue.dequeue()` → calls C++ CallbackQueue::Dequeue()\r\n- **Analogy**: JavaScript is a CLIENT of C++ queue infrastructure, not an owner\r\n\r\n```javascript\r\n// JavaScript side (Run/Data/Scripts/JSEngine.js)\r\nconst g_pendingCallbacks = new Map();  // ← JavaScript owns this Map\r\n\r\nJSEngine.update = function(deltaTime) {\r\n    // Access C++ queue via V8 binding\r\n    while (true) {\r\n        let callback = CallbackQueue.dequeue();  // ← V8 binding to C++ CallbackQueue\r\n        if (!callback) break;\r\n\r\n        // Lookup callback in JavaScript-owned Map\r\n        let callbackFunc = g_pendingCallbacks.get(callback.callbackId);\r\n        if (callbackFunc) {\r\n            callbackFunc(callback.resultId);\r\n            g_pendingCallbacks.delete(callback.callbackId);\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n**Three Layers**:\r\n1. **C++ Infrastructure Layer**: App owns queues (RenderCommandQueue, CallbackQueue)\r\n2. **V8 Binding Layer**: V8Subsystem exposes C++ methods to JavaScript\r\n3. **JavaScript Usage Layer**: JavaScript code calls bindings, owns callback Map\r\n\r\n### High-Level Thread Model\r\n\r\nThis section shows how the three core independence principles are achieved through architecture:\r\n\r\n1. **No Waiting**: Lock-free SPSC queues enable non-blocking communication\r\n2. **Different Speeds**: Independent thread loops allow C++ 60 FPS, JS variable 30-60 FPS\r\n3. **Crash Isolation**: Double-buffering enables C++ to use last good state if JS crashes\r\n\r\n#### Architecture Diagram\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph App[\"App (Owns Infrastructure)\"]\r\n        RCQ[\"RenderCommandQueue\r\n(SPSC Lock-Free)\"]\r\n        CBQ[\"CallbackQueue\r\n(SPSC Lock-Free)\"]\r\n        ESB[\"EntityStateBuffer\r\n(Double-Buffered)\"]\r\n    end\r\n\r\n    subgraph MainThread[\"Main Thread (C++ Rendering)\"]\r\n        AppUpdate[App::Update]\r\n        ProcessCmds[ProcessRenderCommands]\r\n        EntityAPI[EntityAPI]\r\n        Render[Render Entities]\r\n        SwapBuffers[SwapBuffers]\r\n    end\r\n\r\n    subgraph WorkerThread[\"Worker Thread (JS Logic)\"]\r\n        JSJob[JSGameLogicJob::Execute]\r\n        ProcessCB[Process Callbacks]\r\n        JSUpdate[JSEngine.update]\r\n        SubmitCmds[Submit Commands]\r\n    end\r\n\r\n    subgraph JSRuntime[\"JavaScript Runtime\"]\r\n        JSCallbacks[g_pendingCallbacks Map]\r\n        CallbackBinding[\"CallbackQueue.dequeue\r\n(V8 Binding)\"]\r\n    end\r\n\r\n    %% Ownership (App creates, injects into components)\r\n    App -.->|creates & owns| RCQ\r\n    App -.->|creates & owns| CBQ\r\n    App -.->|creates & owns| ESB\r\n    App -.->|injects pointers| JSJob\r\n    App -.->|injects pointers| EntityAPI\r\n\r\n    %% Main Thread Flow\r\n    AppUpdate --> ProcessCmds\r\n    ProcessCmds -->|ConsumeAll| RCQ\r\n    ProcessCmds --> EntityAPI\r\n    EntityAPI -->|Enqueue callbacks| CBQ\r\n    ProcessCmds --> Render\r\n    Render --> SwapBuffers\r\n    SwapBuffers -->|Swap front/back| ESB\r\n\r\n    %% Worker Thread Flow\r\n    JSJob --> ProcessCB\r\n    ProcessCB -->|Dequeue via binding| CallbackBinding\r\n    CallbackBinding -->|Dequeue| CBQ\r\n    ProcessCB -->|Lookup by ID| JSCallbacks\r\n    ProcessCB --> JSUpdate\r\n    JSUpdate --> SubmitCmds\r\n    SubmitCmds -->|Submit| RCQ\r\n    JSUpdate -->|Read FrontBuffer| ESB\r\n\r\n    %% JavaScript owns callbacks\r\n    JSRuntime -.->|JavaScript owns| JSCallbacks\r\n\r\n    style App fill:#ffe6e6\r\n    style RCQ fill:#fff4e6\r\n    style CBQ fill:#fff4e6\r\n    style ESB fill:#fff4e6\r\n    style MainThread fill:#e1f5e1\r\n    style WorkerThread fill:#e1f5ff\r\n    style JSRuntime fill:#f0e6ff\r\n```\r\n\r\n**Key Architectural Principles**:\r\n- **App owns all infrastructure**: RenderCommandQueue, CallbackQueue, EntityStateBuffer\r\n- **Dependency injection**: App passes queue pointers to JSGameLogicJob and EntityAPI\r\n- **JavaScript is a client**: Accesses C++ queues via V8 bindings, owns callback Map\r\n- **Symmetry**: Both queues use identical lock-free SPSC pattern\r\n\r\n#### Sequence Diagram (Complete Frame Execution)\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant MT as Main Thread\r\n    participant RCQ as RenderCommandQueue\r\n    participant CBQ as CallbackQueue\r\n    participant ESB as EntityStateBuffer\r\n    participant WT as Worker Thread\r\n    participant JSMap as g_pendingCallbacks\r\n\r\n    Note over MT,JSMap: Frame N Begins\r\n\r\n    par Independent Execution\r\n        Note over MT: C++ Main Thread\r\n        MT->>RCQ: ConsumeAll\r\n        activate RCQ\r\n        RCQ-->>MT: Commands\r\n        deactivate RCQ\r\n\r\n        MT->>MT: Create vertex buffers\r\n        MT->>CBQ: Enqueue callback\r\n        activate CBQ\r\n        Note right of CBQ: Lock-free\r\n        deactivate CBQ\r\n\r\n        MT->>ESB: Write BackBuffer\r\n        MT->>MT: Render entities\r\n        MT->>ESB: SwapBuffers\r\n        activate ESB\r\n        Note right of ESB: Copy and swap\r\n        deactivate ESB\r\n\r\n    and\r\n        Note over WT,JSMap: JS Worker Thread\r\n        WT->>CBQ: Dequeue callbacks\r\n        activate CBQ\r\n        CBQ-->>WT: CallbackData\r\n        deactivate CBQ\r\n\r\n        WT->>JSMap: get callback\r\n        activate JSMap\r\n        JSMap-->>WT: function\r\n        deactivate JSMap\r\n\r\n        WT->>WT: Execute callback\r\n        WT->>JSMap: delete callback\r\n\r\n        WT->>ESB: Read FrontBuffer\r\n        activate ESB\r\n        ESB-->>WT: Entity state\r\n        deactivate ESB\r\n\r\n        WT->>WT: JSEngine.update\r\n        WT->>WT: Game logic\r\n\r\n        WT->>RCQ: Submit command\r\n        activate RCQ\r\n        Note right of RCQ: Lock-free\r\n        deactivate RCQ\r\n    end\r\n\r\n    Note over MT,JSMap: Frame N Ends\r\n\r\n    Note over MT,JSMap: Crash Isolation Example\r\n\r\n    par JavaScript Crashes\r\n        MT->>RCQ: ConsumeAll\r\n        MT->>MT: Render last state\r\n        MT->>ESB: SwapBuffers\r\n        Note right of MT: C++ continues\r\n\r\n    and\r\n        WT->>WT: JS throws error\r\n        activate WT\r\n        Note right of WT: TryCatch handles\r\n        WT->>WT: Continue\r\n        deactivate WT\r\n        Note right of WT: JS recovers\r\n    end\r\n```\r\n\r\n**Key Sequence Features**:\r\n- **Parallel Execution**: Main thread and worker thread run independently\r\n- **Lock-Free Communication**: All queue operations use atomics (no waiting)\r\n- **Brief Synchronization**: Only SwapBuffers() uses mutex (< 100µs)\r\n- **Crash Isolation**: C++ continues rendering if JavaScript throws error\r\n- **Callback Round-Trip**: C++ enqueues callback ID → JS looks up function in Map → executes\r\n\r\n### Modular Design Principles\r\n\r\n**Single File Responsibility**:\r\n- `CallbackQueue.hpp/cpp`: Lock-free SPSC queue for callbacks only\r\n- `JavaScriptWorkerThread.hpp/cpp`: Worker thread lifecycle management only\r\n- `RenderResourceManager.hpp/cpp`: Render resource (vertex buffers, textures) management only\r\n- `StateBuffer.hpp`: Dirty tracking logic isolated in template class\r\n\r\n**Component Isolation**:\r\n- CallbackQueue independent of V8 (testable without JavaScript)\r\n- StateBuffer dirty tracking backward-compatible (optional optimization)\r\n- RenderResourceManager separate from EntityState (clean abstraction)\r\n\r\n**Service Layer Separation**:\r\n- **Data Layer**: StateBuffer, RenderResourceManager (pure state management)\r\n- **Communication Layer**: RenderCommandQueue, CallbackQueue (async messaging)\r\n- **Execution Layer**: Game, App, EntityAPI (business logic)\r\n\r\n### Phase 2: Worker Thread Architecture\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant MT as Main Thread\r\n    participant WT as Worker Thread\r\n    participant RCQ as RenderCommandQueue\r\n    participant CBQ as CallbackQueue\r\n    participant ESB as EntityStateBuffer\r\n\r\n    Note over MT,WT: Frame N Begins\r\n\r\n    MT->>MT: App::Update()\r\n    MT->>RCQ: ConsumeAll(ProcessRenderCommands)\r\n\r\n    par Async Execution\r\n        MT->>MT: CreateVertexBuffer(mesh)\r\n        MT->>CBQ: Enqueue(callback, entityId)\r\n        MT->>ESB: Write to BackBuffer\r\n    and\r\n        WT->>WT: UpdateJSWorkerThread()\r\n        WT->>CBQ: Dequeue callbacks\r\n        WT->>WT: Execute JS callbacks\r\n        WT->>WT: JSEngine.update(deltaTime)\r\n        WT->>ESB: Read FrontBuffer\r\n        WT->>RCQ: Submit(RenderCommand)\r\n    end\r\n\r\n    MT->>MT: Render entities\r\n    MT->>ESB: SwapBuffers()\r\n\r\n    Note over MT,WT: Frame N Ends\r\n```\r\n\r\n### Phase 3: Error Recovery Architecture\r\n\r\n```mermaid\r\nflowchart TD\r\n    A[SwapBuffers Called] --> B{Validate BackBuffer}\r\n    B -->|Valid| C[Copy Back→Front]\r\n    B -->|Invalid| D[Log Error]\r\n    D --> E[Skip Swap, Use Stale Front]\r\n    C --> F{Exception Thrown?}\r\n    F -->|No| G[Swap Pointers]\r\n    F -->|Yes| H[Catch Exception]\r\n    H --> I[Log Error]\r\n    I --> E\r\n    G --> J[Swap Complete]\r\n\r\n    K[JavaScript Update] --> L{Try Execute}\r\n    L -->|Success| M[Continue]\r\n    L -->|Exception| N[HandleJSException]\r\n    N --> O[Log Error + Stack Trace]\r\n    O --> P[Don't Crash C++]\r\n    P --> M\r\n\r\n    Q[Callback Execution] --> R{Try Execute}\r\n    R -->|Success| S[Continue]\r\n    R -->|Error| T[Create ErrorCallback]\r\n    T --> U[Report to C++]\r\n    U --> V[Log Error]\r\n    V --> S\r\n\r\n    style D fill:#ffe6e6\r\n    style H fill:#ffe6e6\r\n    style N fill:#ffe6e6\r\n    style T fill:#ffe6e6\r\n```\r\n\r\n### Phase 4: Dirty Tracking Optimization\r\n\r\n```mermaid\r\nflowchart LR\r\n    A[EntityAPI::UpdatePosition] --> B[Submit RenderCommand]\r\n    B --> C[ProcessRenderCommands]\r\n    C --> D[Update BackBuffer]\r\n    D --> E[MarkDirty entityId]\r\n\r\n    F[SwapBuffers Called] --> G{Check DirtySet}\r\n    G -->|Empty| H[No Copy Needed]\r\n    G -->|Has Dirty| I[For Each Dirty ID]\r\n    I --> J[Copy Single Entity]\r\n    J --> K[Clear DirtySet]\r\n    K --> L[Swap Pointers]\r\n\r\n    style E fill:#e1f5ff\r\n    style I fill:#fff4e6\r\n    style J fill:#e1f5e1\r\n```\r\n\r\n## Components and Interfaces\r\n\r\n### Component 1: CallbackQueue (New)\r\n\r\n**Purpose**: Lock-free SPSC queue for async C++→JavaScript callback communication\r\n\r\n**File Location**: `C:\\p4\\Personal\\SD\\Engine\\Code\\Engine\\Core\\CallbackQueue.hpp`\r\n\r\n**Public Interface**:\r\n```cpp\r\nclass CallbackQueue {\r\npublic:\r\n    // Types\r\n    struct CallbackData {\r\n        CallbackID callbackId;        // Unique callback identifier\r\n        uint64_t   resultId;          // Entity/camera ID returned\r\n        std::string errorMessage;     // Error message if failed (empty = success)\r\n        CallbackType type;            // ENTITY_CREATED, CAMERA_CREATED, etc.\r\n    };\r\n\r\n    // Construction\r\n    explicit CallbackQueue(size_t capacity = DEFAULT_CAPACITY);\r\n    ~CallbackQueue();\r\n\r\n    // Producer API (C++ Main Thread)\r\n    bool Enqueue(CallbackData const& callback);\r\n    size_t GetApproximateSize() const;\r\n\r\n    // Consumer API (JavaScript Worker Thread)\r\n    template <typename ProcessorFunc>\r\n    void DequeueAll(ProcessorFunc&& processor);\r\n\r\n    // Monitoring\r\n    bool IsEmpty() const;\r\n    bool IsFull() const;\r\n    uint64_t GetTotalEnqueued() const;\r\n    uint64_t GetTotalDequeued() const;\r\n};\r\n```\r\n\r\n**Dependencies**:\r\n- `<atomic>` for lock-free indices\r\n- `<cstddef>` for size_t\r\n- Pattern copied from RenderCommandQueue.hpp\r\n\r\n**Reuses**:\r\n- Exact same SPSC ring buffer algorithm from RenderCommandQueue\r\n- Cache-line separation pattern (64-byte alignment)\r\n- Atomic memory ordering (acquire/release semantics)\r\n\r\n**Design Rationale**:\r\n- Separate class (not template) because callback data structure is fixed\r\n- Small data structure (40 bytes: 8+8+32+4 with padding)\r\n- DEFAULT_CAPACITY = 100 (callbacks are infrequent, 1-10 per frame)\r\n\r\n---\r\n\r\n### Component 2: Activate Existing JSGameLogicJob (Modified)\r\n\r\n**Purpose**: Wire up existing worker thread infrastructure (no new component needed)\r\n\r\n**File Location**: `C:\\p4\\Personal\\SD\\ProtogameJS3D\\Code\\Game\\Framework\\JSGameLogicJob.hpp` (already exists)\r\n\r\n**Key Discovery**: JSGameLogicJob already implements complete worker thread infrastructure from Phase 1:\r\n- Continuous worker thread execution loop (`Execute()` method)\r\n- V8 isolate management (m_isolate member)\r\n- Frame synchronization (m_frameRequested, m_frameComplete atomics)\r\n- Graceful shutdown (m_shutdownRequested, RequestShutdown())\r\n- Access to RenderCommandQueue and EntityStateBuffer\r\n\r\n**Existing Interface** (no changes needed):\r\n```cpp\r\nclass JSGameLogicJob : public Job {\r\npublic:\r\n    JSGameLogicJob(IJSGameLogicContext* context, RenderCommandQueue* commandQueue,\r\n                   EntityStateBuffer* entityBuffer);\r\n\r\n    void Execute() override;         // Worker thread loop (already implemented)\r\n    void TriggerNextFrame();         // Signal next frame\r\n    bool IsFrameComplete() const;    // Check frame completion\r\n    void RequestShutdown();          // Graceful shutdown\r\n\r\nprivate:\r\n    IJSGameLogicContext* m_context;          // JavaScript execution context\r\n    RenderCommandQueue* m_commandQueue;      // JS→C++ command queue\r\n    EntityStateBuffer* m_entityBuffer;       // Entity state double-buffer\r\n    std::atomic<bool> m_frameRequested;\r\n    std::atomic<bool> m_frameComplete;\r\n    std::atomic<bool> m_shutdownRequested;\r\n    v8::Isolate* m_isolate;                  // Worker thread V8 isolate\r\n};\r\n```\r\n\r\n**Phase 2 Changes Required**:\r\n1. **Add CallbackQueue pointer** to constructor:\r\n   ```cpp\r\n   JSGameLogicJob(IJSGameLogicContext* context, RenderCommandQueue* commandQueue,\r\n                  EntityStateBuffer* entityBuffer, CallbackQueue* callbackQueue);\r\n   ```\r\n\r\n2. **Wire up in App.cpp**:\r\n   ```cpp\r\n   // In App::Startup()\r\n   m_callbackQueue = new CallbackQueue(DEFAULT_CALLBACK_CAPACITY);\r\n   m_jsGameLogicJob = new JSGameLogicJob(m_game, m_renderCommandQueue,\r\n                                          m_entityStateBuffer, m_callbackQueue);\r\n   ```\r\n\r\n3. **Activate in Game::Update()**:\r\n   ```cpp\r\n   // Currently: UpdateJS() executes on main thread\r\n   // Target: TriggerNextFrame() activates worker thread\r\n   void Game::Update() {\r\n       if (m_jsGameLogicJob) {\r\n           m_jsGameLogicJob->TriggerNextFrame();  // Signal worker to execute frame\r\n       }\r\n   }\r\n   ```\r\n\r\n**Design Rationale**:\r\n- **Reuse over rewrite**: Phase 1 already built complete worker thread infrastructure\r\n- **Minimal changes**: Just add CallbackQueue parameter and wire up existing code\r\n- **Proven pattern**: JSGameLogicJob already tested with RenderCommandQueue\r\n- **Consistent architecture**: Same dependency injection pattern for CallbackQueue\r\n\r\n**Design Notes from JSGameLogicJob.hpp**:\r\n> \"Solution A (Chosen): Maintains V8 isolate state across frames, lower overhead, simpler error recovery\"\r\n\r\nThis choice validates our approach - continuous worker thread with persistent isolate is optimal.\r\n\r\n---\r\n\r\n### Component 3: RenderResourceManager (New)\r\n\r\n**Purpose**: Manages render-specific resources (vertex buffers, textures) separate from EntityState\r\n\r\n**File Location**: `C:\\p4\\Personal\\SD\\ProtogameJS3D\\Code\\Game\\Framework\\RenderResourceManager.hpp`\r\n\r\n**Public Interface**:\r\n```cpp\r\nclass RenderResourceManager {\r\npublic:\r\n    // Resource Assignment\r\n    void AssignVertexBuffer(EntityID entityId, int vertexBufferHandle);\r\n    void AssignTexture(EntityID entityId, int textureHandle);\r\n\r\n    // Resource Retrieval\r\n    int GetVertexBuffer(EntityID entityId) const;\r\n    int GetTexture(EntityID entityId) const;\r\n    bool HasVertexBuffer(EntityID entityId) const;\r\n    bool HasTexture(EntityID entityId) const;\r\n\r\n    // Resource Cleanup\r\n    void RemoveEntity(EntityID entityId);\r\n    void Clear();\r\n\r\n    // Monitoring\r\n    size_t GetEntityCount() const;\r\n\r\nprivate:\r\n    std::unordered_map<EntityID, int> m_vertexBuffers;  // EntityID → VBO handle\r\n    std::unordered_map<EntityID, int> m_textures;       // EntityID → Texture handle\r\n\r\n    mutable std::mutex m_mutex;  // Thread safety (if needed)\r\n};\r\n```\r\n\r\n**Dependencies**:\r\n- `<unordered_map>` for EntityID → handle mapping\r\n- `Engine/Entity/EntityID.hpp` for EntityID type\r\n\r\n**Reuses**:\r\n- EntityID type from existing Entity system\r\n- std::unordered_map pattern from EntityStateMap\r\n\r\n**Design Rationale**:\r\n- C++ only (JavaScript never accesses)\r\n- Separates render resources from game state (Single Responsibility)\r\n- Allows EntityState to be pure game data\r\n- Fast O(1) lookup during rendering\r\n\r\n---\r\n\r\n### Component 4: StateBuffer with Dirty Tracking (Modified)\r\n\r\n**Purpose**: Extend existing StateBuffer with optional dirty tracking optimization\r\n\r\n**File Location**: `C:\\p4\\Personal\\SD\\Engine\\Code\\Engine\\Core\\StateBuffer.hpp`\r\n\r\n**New Public Interface** (additions only):\r\n```cpp\r\ntemplate <typename TStateContainer>\r\nclass StateBuffer {\r\npublic:\r\n    // ... existing methods ...\r\n\r\n    // Dirty Tracking (Phase 4)\r\n    void MarkDirty(typename TStateContainer::key_type const& key);\r\n    void ClearDirtyTracking();\r\n    bool IsDirtyTrackingEnabled() const;\r\n    void EnableDirtyTracking(bool enable);\r\n\r\n    // Statistics\r\n    size_t GetDirtyCount() const;\r\n    float GetAverageDirtyRatio() const;  // dirty / total entities\r\n\r\nprivate:\r\n    // Dirty tracking state\r\n    std::unordered_set<typename TStateContainer::key_type> m_dirtyKeys;\r\n    bool m_dirtyTrackingEnabled = false;\r\n\r\n    // Statistics\r\n    RunningAverage<float, 60> m_dirtyRatios;  // Last 60 frames\r\n};\r\n```\r\n\r\n**Dependencies**:\r\n- `<unordered_set>` for dirty key tracking\r\n- Existing TStateContainer::key_type (EntityID or std::string)\r\n\r\n**Reuses**:\r\n- Existing SwapBuffers() algorithm\r\n- Existing double-buffer storage (m_bufferA, m_bufferB)\r\n\r\n**Design Rationale**:\r\n- Backward compatible (dirty tracking optional, disabled by default)\r\n- No performance impact when disabled\r\n- Significant win when enabled: O(d) vs O(n) where d << n\r\n- Statistics help validate optimization effectiveness\r\n\r\n---\r\n\r\n### Component 5: EntityAPI Callback Integration (Modified)\r\n\r\n**Purpose**: Change ExecutePendingCallbacks() to enqueue callback IDs (not execute callbacks directly)\r\n\r\n**File Location**: `C:\\p4\\Personal\\SD\\Engine\\Code\\Engine\\Entity\\EntityAPI.cpp`\r\n\r\n**Key Design Decision**: JavaScript owns callbacks, C++ only passes callback IDs\r\n\r\n**Callback Ownership Clarification**:\r\n- **JavaScript Owns**: `g_pendingCallbacks` Map<callbackId, function> in JavaScript\r\n- **C++ Stores**: Only callback IDs (uint64_t), NOT v8::Function objects\r\n- **Benefits**: Thread safety (no v8::Function across frames), cleaner separation\r\n\r\n**Modified Method**:\r\n```cpp\r\n// Current (Phase 1) - Synchronous blocking\r\nvoid EntityAPI::ExecutePendingCallbacks() {\r\n    for (auto& [callbackId, pending] : m_pendingCallbacks) {\r\n        if (pending.ready) {\r\n            ExecuteCallback(callbackId, pending.resultId);  // ← Blocks C++ thread\r\n            pending.executed = true;\r\n        }\r\n    }\r\n    // Cleanup executed callbacks\r\n    std::erase_if(m_pendingCallbacks, [](auto const& pair) {\r\n        return pair.second.executed;\r\n    });\r\n}\r\n\r\n// Target (Phase 2) - Async queue with callback IDs only\r\nvoid EntityAPI::ExecutePendingCallbacks(CallbackQueue* callbackQueue) {\r\n    for (auto& [callbackId, pending] : m_pendingCallbacks) {\r\n        if (pending.ready) {\r\n            // C++ sends only callback ID, not callback function\r\n            CallbackQueue::CallbackData data{\r\n                .callbackId = callbackId,         // ← ID only\r\n                .resultId = pending.resultId,\r\n                .errorMessage = pending.errorMsg,\r\n                .type = CallbackType::ENTITY_CREATED\r\n            };\r\n\r\n            bool enqueued = callbackQueue->Enqueue(data);  // ← Never blocks\r\n            if (!enqueued) {\r\n                LogWarning(\"CallbackQueue full - dropped callback %llu\", callbackId);\r\n            }\r\n\r\n            pending.executed = true;\r\n        }\r\n    }\r\n    // Cleanup executed callbacks\r\n    std::erase_if(m_pendingCallbacks, [](auto const& pair) {\r\n        return pair.second.executed;\r\n    });\r\n}\r\n```\r\n\r\n**JavaScript Callback Registration Pattern**:\r\n```javascript\r\n// EntityAPI.js\r\nlet g_callbackIdCounter = 0;\r\nconst g_pendingCallbacks = new Map();  // JavaScript owns this\r\n\r\nEntityAPI.createMesh = function(meshType, position, radius, color, callback) {\r\n    // Generate unique callback ID\r\n    const callbackId = ++g_callbackIdCounter;\r\n\r\n    // JavaScript stores callback function\r\n    g_pendingCallbacks.set(callbackId, callback);  // ← JS owns callback\r\n\r\n    // C++ receives only the ID\r\n    cppEntityAPI.createMesh(meshType, position, radius, color, callbackId);\r\n};\r\n\r\n// Later, when C++ enqueues callback...\r\nJSEngine.update = function(deltaTime) {\r\n    while (true) {\r\n        let callback = CallbackQueue.dequeue();  // C++ sends callback ID + resultId\r\n        if (!callback) break;\r\n\r\n        // JavaScript looks up callback function by ID\r\n        let callbackFunc = g_pendingCallbacks.get(callback.callbackId);\r\n        if (callbackFunc) {\r\n            callbackFunc(callback.resultId);           // Execute JS function\r\n            g_pendingCallbacks.delete(callback.callbackId);  // Cleanup\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n**Dependencies**:\r\n- CallbackQueue pointer (passed from App)\r\n- Existing m_pendingCallbacks map (stores IDs and status, not v8::Function)\r\n\r\n**Reuses**:\r\n- Existing callback ID management\r\n- Existing PendingCallback structure\r\n\r\n**Design Rationale**:\r\n- **Thread Safety**: C++ never stores v8::Function (avoids cross-thread V8 issues)\r\n- **Clean Separation**: JavaScript manages function lifecycle, C++ just routes IDs\r\n- **Non-blocking**: Enqueue operation never blocks C++ thread\r\n- **Graceful Degradation**: If queue full, log warning and continue\r\n\r\n---\r\n\r\n### Component 6: JavaScript Callback Processing (Modified)\r\n\r\n**Purpose**: Add callback dequeue and execution to JavaScript update loop\r\n\r\n**File Location**: `C:\\p4\\Personal\\SD\\ProtogameJS3D\\Run\\Data\\Scripts\\JSEngine.js`\r\n\r\n**New Code**:\r\n```javascript\r\n// At start of JSEngine.update()\r\nJSEngine.update = function(deltaTime) {\r\n    // Phase 2: Process callbacks from C++\r\n    if (typeof globalThis.CallbackQueue !== 'undefined') {\r\n        while (true) {\r\n            let callback = CallbackQueue.dequeue();\r\n            if (!callback) break;  // Queue empty\r\n\r\n            try {\r\n                executeCallback(callback.callbackId, callback.resultId, callback.errorMessage);\r\n            } catch (e) {\r\n                console.error('Callback execution failed:', e);\r\n                // Don't propagate - continue processing other callbacks\r\n            }\r\n        }\r\n    }\r\n\r\n    // Existing update logic\r\n    // ...\r\n};\r\n\r\nfunction executeCallback(callbackId, resultId, errorMessage) {\r\n    // Find callback in pending map\r\n    let callbackFunc = g_pendingCallbacks.get(callbackId);\r\n    if (!callbackFunc) {\r\n        console.warn('Callback not found:', callbackId);\r\n        return;\r\n    }\r\n\r\n    // Execute callback\r\n    if (errorMessage && errorMessage.length > 0) {\r\n        console.error('C++ reported error:', errorMessage);\r\n        // Call callback with error\r\n        if (callbackFunc.errorHandler) {\r\n            callbackFunc.errorHandler(errorMessage);\r\n        }\r\n    } else {\r\n        // Call callback with result\r\n        callbackFunc(resultId);\r\n    }\r\n\r\n    // Cleanup\r\n    g_pendingCallbacks.delete(callbackId);\r\n}\r\n```\r\n\r\n**Dependencies**:\r\n- Native CallbackQueue binding (exposed by V8Subsystem)\r\n- Existing g_pendingCallbacks map\r\n\r\n**Reuses**:\r\n- Existing callback registration pattern\r\n- Existing error handling conventions\r\n\r\n**Design Rationale**:\r\n- Process callbacks before game logic (callbacks may affect state)\r\n- Try-catch prevents callback errors from stopping update loop\r\n- Graceful handling of missing callbacks (log warning, continue)\r\n\r\n## Data Models\r\n\r\n### Model 1: CallbackData\r\n\r\n**Purpose**: Data structure for C++→JavaScript callback messages\r\n\r\n```cpp\r\nstruct CallbackData {\r\n    CallbackID   callbackId;      // uint64_t: Unique callback identifier\r\n    uint64_t     resultId;        // EntityID or CameraID returned from C++\r\n    std::string  errorMessage;    // Empty = success, non-empty = error description\r\n    CallbackType type;            // enum: ENTITY_CREATED, CAMERA_CREATED, RESOURCE_LOADED\r\n};\r\n\r\nenum class CallbackType : uint8_t {\r\n    ENTITY_CREATED,\r\n    CAMERA_CREATED,\r\n    RESOURCE_LOADED,\r\n    GENERIC\r\n};\r\n```\r\n\r\n**Size**: ~40 bytes (8+8+24+4 with padding)\r\n\r\n**Thread Safety**: Immutable after construction, copied into queue\r\n\r\n**Design Rationale**:\r\n- CallbackID matches JavaScript callback registration\r\n- resultId is 53-bit safe for JavaScript Number type\r\n- errorMessage allows detailed error reporting\r\n- CallbackType enables type-specific handling\r\n\r\n---\r\n\r\n### Model 2: EntityState (Modified)\r\n\r\n**Purpose**: Pure game state structure (render resources removed)\r\n\r\n```cpp\r\n// Before (Phase 1)\r\nstruct EntityState {\r\n    Vec3        position;           // ✅ Game state\r\n    EulerAngles orientation;        // ✅ Game state\r\n    Rgba8       color;              // ✅ Game state\r\n    float       radius;             // ✅ Game state\r\n    std::string meshType;           // ⚠️ Configuration\r\n    bool        isActive;           // ✅ Game state\r\n    int         vertexBufferHandle; // ❌ C++ render resource\r\n    std::string cameraType;         // ⚠️ Configuration\r\n};\r\n\r\n// After (Phase 2+)\r\nstruct EntityState {\r\n    Vec3        position;           // ✅ Game state\r\n    EulerAngles orientation;        // ✅ Game state\r\n    Rgba8       color;              // ✅ Game state\r\n    float       radius;             // ✅ Game state\r\n    std::string meshType;           // ✅ Configuration\r\n    bool        isActive;           // ✅ Game state\r\n    std::string cameraType;         // ✅ Configuration\r\n    // vertexBufferHandle moved to RenderResourceManager\r\n};\r\n```\r\n\r\n**Size Reduction**: 72 bytes → 68 bytes (4 byte savings per entity)\r\n\r\n**Design Rationale**:\r\n- EntityState visible to JavaScript (pure game data only)\r\n- Render resources hidden in RenderResourceManager (C++ only)\r\n- Cleaner separation of concerns (Single Responsibility)\r\n\r\n---\r\n\r\n### Model 3: DirtySet (Phase 4)\r\n\r\n**Purpose**: Track which entities were modified this frame\r\n\r\n```cpp\r\ntemplate <typename TStateContainer>\r\nclass StateBuffer {\r\nprivate:\r\n    std::unordered_set<typename TStateContainer::key_type> m_dirtyKeys;\r\n    bool m_dirtyTrackingEnabled = false;\r\n};\r\n```\r\n\r\n**For EntityStateBuffer**: `std::unordered_set<EntityID>`\r\n**For CameraStateBuffer**: `std::unordered_set<std::string>`\r\n\r\n**Memory Overhead**: 8 bytes per dirty entity + hash table overhead\r\n\r\n**Design Rationale**:\r\n- Fast O(1) insert for MarkDirty()\r\n- Fast O(d) iteration during SwapBuffers()\r\n- Clear after swap (reuse for next frame)\r\n\r\n## Error Handling\r\n\r\n### Error Scenario 1: SwapBuffers() Copy Fails\r\n\r\n**Description**: std::unordered_map copy assignment throws (out of memory, etc.)\r\n\r\n**Handling**:\r\n```cpp\r\nvoid StateBuffer::SwapBuffers() {\r\n    try {\r\n        std::lock_guard lock(m_swapMutex);\r\n\r\n        // Validate before swap\r\n        if (!ValidateStateBuffer(m_backBuffer)) {\r\n            LogError(\"Back buffer validation failed - skipping swap\");\r\n            return;  // Keep using old front buffer\r\n        }\r\n\r\n        // Copy with exception safety\r\n        *m_frontBuffer = *m_backBuffer;\r\n        std::swap(m_frontBuffer, m_backBuffer);\r\n        ++m_totalSwaps;\r\n    }\r\n    catch (std::exception const& e) {\r\n        LogError(\"SwapBuffers failed: %s\", e.what());\r\n        // Don't propagate - renderer uses stale front buffer\r\n        // Game continues with last known good state\r\n    }\r\n}\r\n\r\nbool StateBuffer::ValidateStateBuffer(TStateContainer const* buffer) const {\r\n    if (!buffer) return false;\r\n    if (buffer->size() > MAX_ENTITIES) {\r\n        LogError(\"Buffer size exceeds limit: %zu > %zu\", buffer->size(), MAX_ENTITIES);\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n```\r\n\r\n**User Impact**: One frame renders with stale state, then recovers\r\n\r\n**Recovery**: Next frame's swap may succeed, system self-heals\r\n\r\n---\r\n\r\n### Error Scenario 2: JavaScript Exception During Update\r\n\r\n**Description**: JavaScript code throws error (null reference, type error, etc.)\r\n\r\n**Handling**:\r\n```cpp\r\nvoid Game::UpdateJSWorkerThread(float deltaTime, EntityStateBuffer* entityBuffer,\r\n                                 RenderCommandQueue* commandQueue) {\r\n    v8::Isolate* isolate = v8::Isolate::GetCurrent();\r\n    v8::HandleScope handleScope(isolate);\r\n    v8::TryCatch tryCatch(isolate);\r\n\r\n    // Execute JavaScript update\r\n    String command = StringFormat(\"globalThis.JSEngine.update(%f);\", deltaTime);\r\n    bool success = g_scriptSubsystem->ExecuteCommand(command);\r\n\r\n    if (!success || tryCatch.HasCaught()) {\r\n        HandleJSException(tryCatch);\r\n        // Continue execution - C++ rendering unaffected\r\n    }\r\n}\r\n\r\nvoid Game::HandleJSException(v8::TryCatch& tryCatch) {\r\n    v8::Isolate* isolate = v8::Isolate::GetCurrent();\r\n    v8::String::Utf8Value exception(isolate, tryCatch.Exception());\r\n    v8::Local<v8::Message> message = tryCatch.Message();\r\n\r\n    // Extract error details\r\n    String errorMsg(*exception);\r\n    String filename = \"unknown\";\r\n    int linenum = 0;\r\n\r\n    if (!message.IsEmpty()) {\r\n        v8::String::Utf8Value filenameUtf8(isolate, message->GetScriptResourceName());\r\n        filename = *filenameUtf8;\r\n        linenum = message->GetLineNumber(isolate->GetCurrentContext()).FromMaybe(0);\r\n    }\r\n\r\n    // Log detailed error\r\n    LogError(\"JavaScript Exception: %s\", errorMsg.c_str());\r\n    LogError(\"  at %s:%d\", filename.c_str(), linenum);\r\n\r\n    // Optional: Send error to telemetry system\r\n    // g_telemetry->ReportJavaScriptError(errorMsg, filename, linenum);\r\n\r\n    // Don't crash - game continues with last valid state\r\n}\r\n```\r\n\r\n**User Impact**: JavaScript logic pauses for one frame, C++ rendering continues\r\n\r\n**Recovery**: Next frame JavaScript may succeed, or error persists (logged repeatedly)\r\n\r\n---\r\n\r\n### Error Scenario 3: CallbackQueue Full\r\n\r\n**Description**: C++ enqueues callbacks faster than JavaScript processes them\r\n\r\n**Handling**:\r\n```cpp\r\nvoid EntityAPI::ExecutePendingCallbacks(CallbackQueue* callbackQueue) {\r\n    for (auto& [callbackId, pending] : m_pendingCallbacks) {\r\n        if (pending.ready) {\r\n            CallbackQueue::CallbackData data{/* ... */};\r\n\r\n            bool enqueued = callbackQueue->Enqueue(data);\r\n            if (!enqueued) {\r\n                // Queue full - drop callback and log warning\r\n                LogWarning(\"CallbackQueue full (capacity: %zu) - dropped callback %llu\",\r\n                           callbackQueue->GetCapacity(), callbackId);\r\n\r\n                // Optional: Send error callback to JavaScript\r\n                CallbackQueue::CallbackData errorData{\r\n                    .callbackId = callbackId,\r\n                    .resultId = 0,\r\n                    .errorMessage = \"CallbackQueue full - callback dropped\",\r\n                    .type = pending.type\r\n                };\r\n                // Try to enqueue error (may also fail if queue full)\r\n                callbackQueue->Enqueue(errorData);\r\n            }\r\n\r\n            pending.executed = true;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**User Impact**: Callback not executed, JavaScript may wait indefinitely for result\r\n\r\n**Mitigation**: Increase CallbackQueue capacity (default 100 → 500)\r\n\r\n**Detection**: Monitor GetApproximateSize(), alert if > 80% capacity\r\n\r\n---\r\n\r\n### Error Scenario 4: Worker Thread Deadlock\r\n\r\n**Description**: Mutex timeout or circular wait between main and worker threads\r\n\r\n**Handling**:\r\n```cpp\r\nvoid JavaScriptWorkerThread::Stop() {\r\n    // Signal stop\r\n    m_stopRequested.store(true, std::memory_order_release);\r\n\r\n    // Join with timeout\r\n    constexpr auto TIMEOUT = std::chrono::seconds(5);\r\n\r\n    if (m_workerThread.joinable()) {\r\n        auto start = std::chrono::steady_clock::now();\r\n\r\n        while (m_isRunning.load(std::memory_order_acquire)) {\r\n            std::this_thread::sleep_for(std::chrono::milliseconds(100));\r\n\r\n            auto elapsed = std::chrono::steady_clock::now() - start;\r\n            if (elapsed > TIMEOUT) {\r\n                LogError(\"Worker thread deadlock detected - timeout after 5s\");\r\n                LogError(\"Forcing thread termination (unsafe)\");\r\n\r\n                // Last resort: detach thread (memory leak, but prevent hang)\r\n                m_workerThread.detach();\r\n                return;\r\n            }\r\n        }\r\n\r\n        m_workerThread.join();\r\n    }\r\n}\r\n```\r\n\r\n**User Impact**: Application may hang on shutdown, or force terminate worker\r\n\r\n**Prevention**: No nested locks, brief locked sections only, timeout detection\r\n\r\n---\r\n\r\n### Error Scenario 5: Dirty Tracking Desync\r\n\r\n**Description**: Entity marked dirty but not in backBuffer, or vice versa\r\n\r\n**Handling**:\r\n```cpp\r\nvoid StateBuffer::SwapBuffers() {\r\n    std::lock_guard lock(m_swapMutex);\r\n\r\n    if (m_dirtyTrackingEnabled) {\r\n        // Validate dirty set before copying\r\n        for (auto const& dirtyKey : m_dirtyKeys) {\r\n            if (m_backBuffer->find(dirtyKey) == m_backBuffer->end()) {\r\n                LogWarning(\"Dirty key not in backBuffer: %llu - removing from dirty set\", dirtyKey);\r\n                m_dirtyKeys.erase(dirtyKey);\r\n            }\r\n        }\r\n\r\n        // Copy only dirty entities\r\n        for (auto const& dirtyKey : m_dirtyKeys) {\r\n            auto it = m_backBuffer->find(dirtyKey);\r\n            if (it != m_backBuffer->end()) {\r\n                (*m_frontBuffer)[dirtyKey] = it->second;\r\n            } else {\r\n                // Entity deleted - remove from front buffer\r\n                m_frontBuffer->erase(dirtyKey);\r\n            }\r\n        }\r\n\r\n        m_dirtyKeys.clear();\r\n    } else {\r\n        // Full copy fallback (always correct)\r\n        *m_frontBuffer = *m_backBuffer;\r\n    }\r\n\r\n    std::swap(m_frontBuffer, m_backBuffer);\r\n    ++m_totalSwaps;\r\n}\r\n```\r\n\r\n**User Impact**: Entity may render with stale state for one frame\r\n\r\n**Recovery**: Self-cleaning logic removes invalid dirty keys\r\n\r\n**Validation**: Add debug mode that compares dirty-copy vs full-copy results\r\n\r\n## Testing Strategy\r\n\r\n### Unit Testing\r\n\r\n**CallbackQueue Tests** (`Engine/Tests/Core/CallbackQueueTests.cpp`):\r\n```cpp\r\nTEST(CallbackQueue, EnqueueDequeue) {\r\n    CallbackQueue queue(10);\r\n\r\n    CallbackQueue::CallbackData data{1, 42, \"\", CallbackType::ENTITY_CREATED};\r\n    EXPECT_TRUE(queue.Enqueue(data));\r\n    EXPECT_EQ(queue.GetApproximateSize(), 1);\r\n\r\n    bool processed = false;\r\n    queue.DequeueAll([&](CallbackQueue::CallbackData const& cb) {\r\n        EXPECT_EQ(cb.callbackId, 1);\r\n        EXPECT_EQ(cb.resultId, 42);\r\n        processed = true;\r\n    });\r\n\r\n    EXPECT_TRUE(processed);\r\n    EXPECT_TRUE(queue.IsEmpty());\r\n}\r\n\r\nTEST(CallbackQueue, BackpressureWhenFull) {\r\n    CallbackQueue queue(2);\r\n\r\n    CallbackQueue::CallbackData data{1, 0, \"\", CallbackType::GENERIC};\r\n\r\n    EXPECT_TRUE(queue.Enqueue(data));  // 1st succeeds\r\n    EXPECT_TRUE(queue.Enqueue(data));  // 2nd succeeds (full)\r\n    EXPECT_FALSE(queue.Enqueue(data)); // 3rd fails (backpressure)\r\n}\r\n```\r\n\r\n**StateBuffer Dirty Tracking Tests** (`Engine/Tests/Core/StateBufferTests.cpp`):\r\n```cpp\r\nTEST(StateBuffer, DirtyTrackingReducesCopies) {\r\n    using TestMap = std::unordered_map<uint64_t, int>;\r\n    StateBuffer<TestMap> buffer;\r\n    buffer.EnableDirtyTracking(true);\r\n\r\n    // Create 1000 entities in back buffer\r\n    auto* backBuffer = buffer.GetBackBuffer();\r\n    for (uint64_t i = 0; i < 1000; ++i) {\r\n        (*backBuffer)[i] = static_cast<int>(i);\r\n    }\r\n\r\n    // Swap (full copy first time)\r\n    buffer.SwapBuffers();\r\n\r\n    // Mark only 10 entities dirty\r\n    backBuffer = buffer.GetBackBuffer();\r\n    for (uint64_t i = 0; i < 10; ++i) {\r\n        (*backBuffer)[i] = 999;\r\n        buffer.MarkDirty(i);\r\n    }\r\n\r\n    // Swap (should only copy 10 entities)\r\n    auto startTime = std::chrono::high_resolution_clock::now();\r\n    buffer.SwapBuffers();\r\n    auto endTime = std::chrono::high_resolution_clock::now();\r\n\r\n    // Verify front buffer has updated values\r\n    auto const* frontBuffer = buffer.GetFrontBuffer();\r\n    for (uint64_t i = 0; i < 10; ++i) {\r\n        EXPECT_EQ(frontBuffer->at(i), 999);\r\n    }\r\n\r\n    // Performance should be much better than full copy\r\n    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(endTime - startTime);\r\n    EXPECT_LT(duration.count(), 100);  // < 100µs for 10 entities\r\n}\r\n```\r\n\r\n**RenderResourceManager Tests** (`Game/Tests/Framework/RenderResourceManagerTests.cpp`):\r\n```cpp\r\nTEST(RenderResourceManager, AssignAndRetrieve) {\r\n    RenderResourceManager manager;\r\n\r\n    EntityID id = 42;\r\n    int vboHandle = 123;\r\n\r\n    manager.AssignVertexBuffer(id, vboHandle);\r\n    EXPECT_TRUE(manager.HasVertexBuffer(id));\r\n    EXPECT_EQ(manager.GetVertexBuffer(id), vboHandle);\r\n}\r\n\r\nTEST(RenderResourceManager, RemoveEntityCleansUp) {\r\n    RenderResourceManager manager;\r\n\r\n    manager.AssignVertexBuffer(42, 123);\r\n    manager.AssignTexture(42, 456);\r\n\r\n    manager.RemoveEntity(42);\r\n\r\n    EXPECT_FALSE(manager.HasVertexBuffer(42));\r\n    EXPECT_FALSE(manager.HasTexture(42));\r\n}\r\n```\r\n\r\n### Integration Testing\r\n\r\n**Worker Thread JavaScript Execution** (`Integration/WorkerThreadTests.cpp`):\r\n```cpp\r\nTEST(Integration, JavaScriptRunsOnWorkerThread) {\r\n    // Setup\r\n    Game game;\r\n    EntityStateBuffer entityBuffer;\r\n    RenderCommandQueue renderQueue;\r\n    CallbackQueue callbackQueue;\r\n    JavaScriptWorkerThread worker(&g_scriptSubsystem, &entityBuffer,\r\n                                    nullptr, &renderQueue, &callbackQueue);\r\n\r\n    // Start worker thread\r\n    worker.Start();\r\n\r\n    // Main thread continues independently\r\n    for (int frame = 0; frame < 60; ++frame) {\r\n        // Simulate C++ rendering at 60 FPS\r\n        std::this_thread::sleep_for(std::chrono::milliseconds(16));\r\n        entityBuffer.SwapBuffers();\r\n    }\r\n\r\n    // Verify worker thread executed updates\r\n    EXPECT_GT(worker.GetTotalUpdates(), 0);\r\n\r\n    // Stop worker thread\r\n    worker.Stop();\r\n    EXPECT_FALSE(worker.IsRunning());\r\n}\r\n```\r\n\r\n**Callback Round-Trip** (`Integration/CallbackRoundTripTests.cpp`):\r\n```cpp\r\nTEST(Integration, CallbackRoundTrip) {\r\n    // JavaScript creates entity\r\n    String jsCode = R\"(\r\n        EntityAPI.createMesh('cube', {x: 0, y: 0, z: 0}, 1.0,\r\n                             {r: 255, g: 0, b: 0, a: 255},\r\n                             function(entityId) {\r\n                                 globalThis.testEntityId = entityId;\r\n                             });\r\n    )\";\r\n\r\n    g_scriptSubsystem->ExecuteCommand(jsCode);\r\n\r\n    // C++ processes command\r\n    g_app->ProcessRenderCommands();\r\n\r\n    // C++ enqueues callback\r\n    g_entityAPI->ExecutePendingCallbacks(&g_callbackQueue);\r\n\r\n    // JavaScript processes callback\r\n    g_game->UpdateJSWorkerThread(0.016f, &g_entityBuffer, &g_renderQueue);\r\n\r\n    // Verify JavaScript received entityId\r\n    v8::Local<v8::Value> result = GetGlobalProperty(\"testEntityId\");\r\n    EXPECT_TRUE(result->IsNumber());\r\n    EXPECT_GT(result->NumberValue(), 0);\r\n}\r\n```\r\n\r\n### End-to-End Testing\r\n\r\n**Full Frame Execution** (`E2E/FullFrameTests.cpp`):\r\n```cpp\r\nTEST(E2E, CompleteFrameExecution) {\r\n    // Frame N\r\n\r\n    // 1. Worker thread: JavaScript updates entities\r\n    g_workerThread->WorkerThreadLoop();  // One iteration\r\n\r\n    // 2. Main thread: Process render commands\r\n    g_app->ProcessRenderCommands();\r\n\r\n    // 3. Main thread: Enqueue callbacks\r\n    g_entityAPI->ExecutePendingCallbacks(&g_callbackQueue);\r\n\r\n    // 4. Main thread: Render\r\n    g_app->Render();\r\n\r\n    // 5. Main thread: Swap buffers\r\n    g_entityBuffer->SwapBuffers();\r\n\r\n    // Verify no crashes, no deadlocks, frame completes < 16ms\r\n}\r\n```\r\n\r\n**Error Recovery** (`E2E/ErrorRecoveryTests.cpp`):\r\n```cpp\r\nTEST(E2E, JavaScriptErrorDoesNotCrashCPP) {\r\n    // Execute JavaScript code that throws\r\n    String jsCode = \"throw new Error('Intentional test error');\";\r\n\r\n    // Should not crash, should log error\r\n    EXPECT_NO_FATAL_FAILURE({\r\n        g_scriptSubsystem->ExecuteCommand(jsCode);\r\n    });\r\n\r\n    // C++ rendering continues\r\n    EXPECT_NO_THROW({\r\n        g_app->Render();\r\n    });\r\n}\r\n\r\nTEST(E2E, SwapBuffersFailureDoesNotCrash) {\r\n    // Inject failure into SwapBuffers (mock)\r\n    g_entityBuffer->InjectFailure(true);\r\n\r\n    // Should not crash, should log error\r\n    EXPECT_NO_FATAL_FAILURE({\r\n        g_entityBuffer->SwapBuffers();\r\n    });\r\n\r\n    // Next frame may succeed\r\n    g_entityBuffer->InjectFailure(false);\r\n    EXPECT_NO_THROW({\r\n        g_entityBuffer->SwapBuffers();\r\n    });\r\n}\r\n```\r\n\r\n### Performance Benchmarks\r\n\r\n**Dirty Tracking Benchmark** (`Benchmarks/DirtyTrackingBenchmark.cpp`):\r\n```cpp\r\nBENCHMARK(SwapBuffers_FullCopy_1000Entities) {\r\n    StateBuffer<EntityStateMap> buffer;\r\n    buffer.EnableDirtyTracking(false);\r\n\r\n    // Setup 1000 entities\r\n    SetupEntities(buffer.GetBackBuffer(), 1000);\r\n\r\n    // Measure swap time\r\n    auto start = std::chrono::high_resolution_clock::now();\r\n    buffer.SwapBuffers();\r\n    auto end = std::chrono::high_resolution_clock::now();\r\n\r\n    return std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();\r\n}\r\n\r\nBENCHMARK(SwapBuffers_DirtyOnly_10Entities) {\r\n    StateBuffer<EntityStateMap> buffer;\r\n    buffer.EnableDirtyTracking(true);\r\n\r\n    // Setup 1000 entities, mark 10 dirty\r\n    SetupEntities(buffer.GetBackBuffer(), 1000);\r\n    buffer.SwapBuffers();  // First swap (full copy)\r\n\r\n    MarkEntitiesDirty(buffer, 10);\r\n\r\n    // Measure swap time (should be much faster)\r\n    auto start = std::chrono::high_resolution_clock::now();\r\n    buffer.SwapBuffers();\r\n    auto end = std::chrono::high_resolution_clock::now();\r\n\r\n    return std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();\r\n}\r\n\r\n// Expected Results:\r\n// FullCopy_1000Entities: ~500-1000µs\r\n// DirtyOnly_10Entities: ~20-50µs (10-20x faster)\r\n```\r\n\r\n### Thread Safety Validation\r\n\r\n**ThreadSanitizer Tests**:\r\n```bash\r\n# Build with ThreadSanitizer\r\ncmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DENABLE_TSAN=ON ..\r\nmake\r\n\r\n# Run tests under TSan\r\n./ProtogameJS3D_Tests --gtest_filter=Integration.*\r\n\r\n# Expected: No data race warnings\r\n# Common issues to watch for:\r\n# - Double-checked locking without acquire/release\r\n# - Missing atomic operations on shared flags\r\n# - False sharing between m_head and m_tail\r\n```\r\n\r\n**Lock-Free Progress Guarantee Tests**:\r\n```cpp\r\nTEST(ThreadSafety, QueueNeverBlocks) {\r\n    RenderCommandQueue queue;\r\n\r\n    std::atomic<bool> producerBlocked{false};\r\n    std::atomic<bool> consumerBlocked{false};\r\n\r\n    // Producer thread\r\n    std::thread producer([&]() {\r\n        for (int i = 0; i < 10000; ++i) {\r\n            auto start = std::chrono::steady_clock::now();\r\n\r\n            RenderCommand cmd{/*...*/};\r\n            queue.Submit(cmd);\r\n\r\n            auto elapsed = std::chrono::steady_clock::now() - start;\r\n            if (elapsed > std::chrono::milliseconds(10)) {\r\n                producerBlocked.store(true);\r\n            }\r\n        }\r\n    });\r\n\r\n    // Consumer thread\r\n    std::thread consumer([&]() {\r\n        for (int i = 0; i < 100; ++i) {\r\n            auto start = std::chrono::steady_clock::now();\r\n\r\n            queue.ConsumeAll([](auto const&) {});\r\n\r\n            auto elapsed = std::chrono::steady_clock::now() - start;\r\n            if (elapsed > std::chrono::milliseconds(10)) {\r\n                consumerBlocked.store(true);\r\n            }\r\n\r\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\r\n        }\r\n    });\r\n\r\n    producer.join();\r\n    consumer.join();\r\n\r\n    EXPECT_FALSE(producerBlocked.load());\r\n    EXPECT_FALSE(consumerBlocked.load());\r\n}\r\n```\r\n\r\n## Performance Targets\r\n\r\n### Phase 2 Targets\r\n\r\n| Metric | Target | Measurement |\r\n|--------|--------|-------------|\r\n| C++ Frame Rate | 60+ FPS | Stable, no drops when JS slows |\r\n| JS Update Rate | 30-60 FPS | Independent of C++ |\r\n| Callback Latency | < 1 frame | C++ enqueue → JS execute |\r\n| Queue Submit Time | < 1µs | RenderCommandQueue::Submit() |\r\n| Worker Thread Startup | < 100ms | Thread spawn + V8 isolate |\r\n\r\n### Phase 3 Targets\r\n\r\n| Metric | Target | Measurement |\r\n|--------|--------|-------------|\r\n| JS Error Recovery | 100% | No C++ crashes from JS errors |\r\n| SwapBuffers Error Recovery | 100% | Graceful degradation |\r\n| Callback Error Reporting | 100% | Errors reported to C++ |\r\n| Deadlock Detection | < 5s timeout | Detect and log hangs |\r\n\r\n### Phase 4 Targets\r\n\r\n| Metric | Target | Measurement |\r\n|--------|--------|-------------|\r\n| SwapBuffers Time (10 dirty) | < 50µs | 10 entities dirty out of 1000 |\r\n| SwapBuffers Time (100 dirty) | < 100µs | 100 entities dirty out of 1000 |\r\n| Dirty Ratio (typical) | < 10% | Average dirty entities per frame |\r\n| Memory Overhead | < 1KB | DirtySet storage |\r\n\r\n## Implementation Phases\r\n\r\n### Phase 2.1: CallbackQueue Implementation (4-6h)\r\n\r\n**Files to Create**:\r\n- `Engine/Code/Engine/Core/CallbackQueue.hpp`\r\n- `Engine/Code/Engine/Core/CallbackQueue.cpp`\r\n- `Engine/Tests/Core/CallbackQueueTests.cpp`\r\n\r\n**Acceptance Criteria**:\r\n- Enqueue/Dequeue work correctly\r\n- Thread-safe (passes TSan)\r\n- Backpressure when full\r\n- Unit tests pass\r\n\r\n### Phase 2.2: EntityAPI/CameraAPI Integration (2-3h)\r\n\r\n**Files to Modify**:\r\n- `Engine/Code/Engine/Entity/EntityAPI.cpp`\r\n- `Engine/Code/Engine/Renderer/CameraAPI.cpp`\r\n\r\n**Changes**:\r\n- Add `CallbackQueue*` parameter to ExecutePendingCallbacks()\r\n- Change direct callback execution to Enqueue()\r\n- Add backpressure logging\r\n\r\n**Acceptance Criteria**:\r\n- Callbacks enqueued instead of executed\r\n- No blocking on C++ thread\r\n- Integration tests pass\r\n\r\n### Phase 2.3: Wire Up Existing JSGameLogicJob (2-3h)\r\n\r\n**Files to Modify**:\r\n- `Game/Code/Game/Framework/JSGameLogicJob.hpp`\r\n- `Game/Code/Game/Framework/JSGameLogicJob.cpp`\r\n- `Game/Code/Game/Framework/App.cpp`\r\n- `Game/Code/Game/Gameplay/Game.cpp`\r\n\r\n**Changes**:\r\n- Add `CallbackQueue*` parameter to JSGameLogicJob constructor\r\n- Pass CallbackQueue pointer when creating JSGameLogicJob in App::Startup()\r\n- Replace Game::UpdateJS() with TriggerNextFrame() call to activate worker thread\r\n- Store CallbackQueue pointer in JSGameLogicJob for JavaScript access\r\n\r\n**Acceptance Criteria**:\r\n- JSGameLogicJob receives CallbackQueue pointer via dependency injection\r\n- Worker thread executes JavaScript independently of main thread\r\n- TriggerNextFrame() activates JavaScript update loop\r\n- No deadlocks, graceful shutdown works correctly\r\n- Integration tests pass\r\n\r\n### Phase 2.4: JavaScript Callback Processing (3-4h)\r\n\r\n**Files to Modify**:\r\n- `Run/Data/Scripts/JSEngine.js`\r\n- `Run/Data/Scripts/interfaces/EntityAPI.js`\r\n- `Run/Data/Scripts/interfaces/CameraAPI.js`\r\n\r\n**Changes**:\r\n- Add CallbackQueue.dequeue() at start of update\r\n- Implement executeCallback() function\r\n- Add error handling for callback failures\r\n\r\n**Acceptance Criteria**:\r\n- Callbacks dequeued and executed\r\n- Errors logged, don't crash update loop\r\n- Round-trip tests pass\r\n\r\n### Phase 3.1: SwapBuffers Error Handling (2-3h)\r\n\r\n**Files to Modify**:\r\n- `Engine/Code/Engine/Core/StateBuffer.hpp`\r\n\r\n**Changes**:\r\n- Add ValidateStateBuffer() method\r\n- Wrap copy in try-catch\r\n- Add error logging\r\n\r\n**Acceptance Criteria**:\r\n- Exceptions caught and logged\r\n- Stale front buffer used on failure\r\n- No crashes\r\n\r\n### Phase 3.2: HandleJSException Implementation (3-4h)\r\n\r\n**Files to Modify**:\r\n- `Game/Code/Game/Gameplay/Game.cpp`\r\n\r\n**Changes**:\r\n- Implement HandleJSException() method\r\n- Add v8::TryCatch around JavaScript execution\r\n- Extract error details (message, stack trace, line number)\r\n\r\n**Acceptance Criteria**:\r\n- JavaScript errors logged with details\r\n- C++ continues execution\r\n- Error recovery tests pass\r\n\r\n### Phase 4.1: Dirty Tracking Implementation (4-6h)\r\n\r\n**Files to Modify**:\r\n- `Engine/Code/Engine/Core/StateBuffer.hpp`\r\n- `Engine/Tests/Core/StateBufferTests.cpp`\r\n\r\n**Changes**:\r\n- Add m_dirtyKeys, m_dirtyTrackingEnabled\r\n- Implement MarkDirty(), EnableDirtyTracking()\r\n- Modify SwapBuffers() to use dirty-only copy\r\n\r\n**Acceptance Criteria**:\r\n- Dirty tracking works correctly\r\n- Backward compatible (optional)\r\n- Unit tests pass\r\n- Benchmarks show 10-20x speedup\r\n\r\n### Phase 4.2: ProcessRenderCommands Integration (2-3h)\r\n\r\n**Files to Modify**:\r\n- `Game/Code/Game/Framework/App.cpp`\r\n\r\n**Changes**:\r\n- Call entityBuffer->MarkDirty(entityId) after updates\r\n- Enable dirty tracking: entityBuffer->EnableDirtyTracking(true)\r\n\r\n**Acceptance Criteria**:\r\n- Entities marked dirty on update\r\n- Integration tests pass\r\n- No visual artifacts\r\n\r\n### Phase 5: Remove vertexBufferHandle (4-5h)\r\n\r\n**Files to Create**:\r\n- `Game/Code/Game/Framework/RenderResourceManager.hpp`\r\n- `Game/Code/Game/Framework/RenderResourceManager.cpp`\r\n\r\n**Files to Modify**:\r\n- `Engine/Code/Engine/Entity/EntityState.hpp`\r\n- `Game/Code/Game/Framework/App.cpp`\r\n\r\n**Changes**:\r\n- Remove vertexBufferHandle from EntityState\r\n- Create RenderResourceManager with EntityID → VBO mapping\r\n- Update ProcessRenderCommands() to use RenderResourceManager\r\n\r\n**Acceptance Criteria**:\r\n- EntityState size reduced\r\n- Rendering works correctly\r\n- All tests pass\r\n\r\n### Documentation: AsyncArchitecturePhases.md (2-3h)\r\n\r\n**Files to Create**:\r\n- `Docs/architecture/AsyncArchitecturePhases.md`\r\n\r\n**Content**:\r\n- Phase 1: Infrastructure (completed)\r\n- Phase 2: Worker thread execution\r\n- Phase 3: Error recovery\r\n- Phase 4: Performance optimization\r\n- Diagrams, code examples, trade-offs\r\n\r\n**Acceptance Criteria**:\r\n- All phases documented\r\n- Diagrams included\r\n- Code examples accurate\r\n- Design rationales explained\r\n\r\n## Total Estimated Time\r\n\r\n- **Phase 2**: 11-16 hours (reduced from 15-21h by reusing JSGameLogicJob)\r\n- **Phase 3**: 5-7 hours\r\n- **Phase 4**: 6-9 hours\r\n- **Phase 5**: 4-5 hours\r\n- **Documentation**: 2-3 hours\r\n\r\n**Total**: 28-40 hours (across all phases)\r\n\r\n**Time Savings**: 4-5 hours saved by reusing existing JSGameLogicJob infrastructure instead of creating new JavaScriptWorkerThread component\r\n\r\n## Risk Mitigation Summary\r\n\r\n1. **V8 Thread Safety**: Use V8::Locker, one isolate per thread\r\n2. **Deadlock**: Timeout detection, no nested locks\r\n3. **Performance Regression**: Benchmark at each phase, keep fallbacks\r\n4. **Dirty Tracking Bugs**: Debug mode with full-copy validation\r\n5. **Queue Overflow**: Monitor size, alert at 80%, increase capacity\r\n\r\n## Success Metrics\r\n\r\n- ✅ C++ rendering: 60+ FPS stable (independent of JavaScript)\r\n- ✅ JavaScript worker thread: Runs independently at 30-60 FPS\r\n- ✅ No synchronous blocking: All communication via queues\r\n- ✅ Error isolation: JavaScript errors don't crash C++\r\n- ✅ Dirty tracking: 10-20x speedup for typical workloads (< 10% dirty)\r\n- ✅ All tests pass: Unit, integration, E2E\r\n- ✅ ThreadSanitizer clean: No data races detected\r\n- ✅ Documentation complete: AsyncArchitecturePhases.md\r\n",
  "fileStats": {
    "size": 58186,
    "lines": 1754,
    "lastModified": "2025-11-18T13:55:03.932Z"
  },
  "comments": []
}