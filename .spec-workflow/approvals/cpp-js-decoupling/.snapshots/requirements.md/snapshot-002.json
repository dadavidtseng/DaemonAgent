{
  "id": "snapshot_1763462437479_6pt6nblmb",
  "approvalId": "approval_1763462360841_gt9xzwnmu",
  "approvalTitle": "Requirements - C++/JavaScript Decoupling Architecture (Phase 1-4)",
  "version": 2,
  "timestamp": "2025-11-18T10:40:37.479Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements: C++/JavaScript Decoupling Architecture (Phase 1-4 Completion)\r\n\r\n## Spec Metadata\r\n- **Spec Name**: cpp-js-decoupling\r\n- **Created**: 2025-01-18\r\n- **Priority**: HIGH\r\n- **Type**: Architecture Implementation / Refactoring\r\n- **Estimated Hours**: 24-32h (across Phase 2-4)\r\n- **Dependencies**: Phase 1 already complete (M4-T8 async architecture)\r\n\r\n## User Story\r\n\r\n**As a** game engine developer,\r\n**I want to** complete the Phase 1-4 roadmap for C++/JavaScript decoupling,\r\n**So that** C++ and JavaScript can run at independent speeds in their own game loops with proper async communication.\r\n\r\n## Background and Architecture Goals\r\n\r\n### Current State (Phase 1 - Complete ✅)\r\n- Async infrastructure in place (EntityStateBuffer, CameraStateBuffer, RenderCommandQueue)\r\n- JavaScript → C++ communication uses lock-free SPSC queue\r\n- Double-buffering prevents corruption when entity counts change\r\n- M4-T8 refactoring: Entity/Camera systems moved to Engine repository\r\n\r\n### Problems with Current Implementation\r\n1. **JavaScript executes on main thread** via `UpdateJS()`, not worker thread via `UpdateJSWorkerThread()`\r\n2. **C++ → JavaScript callbacks are synchronous**, blocking C++ thread (no JavaScript callback queue)\r\n3. **Full O(n) copy every frame** in `SwapBuffers()` regardless of dirty entities\r\n4. **vertexBufferHandle pollutes EntityState** - C++ render resource in shared state structure\r\n5. **No error recovery** in SwapBuffers() or callback execution\r\n6. **No formal phase documentation** - phases exist only as scattered code comments\r\n\r\n### Architecture Goal\r\nAchieve true decoupling where:\r\n- **C++ rendering thread** runs at 60+ FPS independently\r\n- **JavaScript worker thread** runs at game logic speed (30-60 FPS) independently\r\n- **Async communication both directions**: JS→C++ via RenderCommandQueue, C++→JS via CallbackQueue\r\n- **Optimized state synchronization** with dirty tracking instead of full copy\r\n- **Robust error handling** to prevent one thread from crashing the other\r\n\r\n## Requirements\r\n\r\n### FR-1: Phase 2 - Worker Thread JavaScript Execution\r\n**Given** JavaScript currently executes on main thread,\r\n**When** implementing Phase 2,\r\n**Then** JavaScript shall execute on dedicated worker thread via `UpdateJSWorkerThread()`.\r\n\r\n**Acceptance Criteria**:\r\n- Create `JavaScriptWorkerThread` class managing V8 isolate on worker thread\r\n- Replace `Game::UpdateJS()` call with `Game::UpdateJSWorkerThread()` invocation\r\n- Pass `EntityStateBuffer::GetFrontBuffer()` read-only access to worker thread\r\n- Pass `RenderCommandQueue` write access to worker thread for JS→C++ commands\r\n- Worker thread runs independent game loop (can be 30 FPS while C++ renders at 60 FPS)\r\n- Main thread never blocks on JavaScript execution\r\n- JavaScript execution time doesn't affect C++ frame rate\r\n\r\n**Technical Details**:\r\n```cpp\r\n// Current (Phase 1) - Main thread execution\r\nvoid Game::Update() {\r\n    UpdateJS();  // ← Blocks main thread\r\n    ProcessRenderCommands();\r\n}\r\n\r\n// Target (Phase 2) - Worker thread execution\r\nvoid Game::Update() {\r\n    // JavaScript runs independently on worker thread\r\n    ProcessRenderCommands();  // ← Never blocks on JS\r\n}\r\n\r\nvoid Game::UpdateJSWorkerThread() {\r\n    // Runs on worker thread\r\n    auto* frontBuffer = m_entityStateBuffer->GetFrontBuffer();  // Read-only\r\n    float deltaTime = ...;\r\n    ExecuteJavaScriptCommand(...);\r\n}\r\n```\r\n\r\n**Files to Modify**:\r\n- `C:\\p4\\Personal\\SD\\ProtogameJS3D\\Code\\Game\\Gameplay\\Game.cpp` - Connect UpdateJSWorkerThread()\r\n- `C:\\p4\\Personal\\SD\\ProtogameJS3D\\Code\\Game\\Gameplay\\Game.hpp` - Add JavaScriptWorkerThread member\r\n- `C:\\p4\\Personal\\SD\\ProtogameJS3D\\Code\\Game\\Framework\\App.cpp` - Remove UpdateJS() call\r\n- `C:\\p4\\Personal\\SD\\Engine\\Code\\Engine\\Core\\V8Subsystem.cpp` - Thread-safe V8 isolate management\r\n\r\n### FR-2: JavaScript Callback Queue (Async C++→JS Communication)\r\n**Given** C++ callbacks currently execute synchronously and block C++ thread,\r\n**When** implementing async callback mechanism,\r\n**Then** C++ shall enqueue callbacks into JavaScript's CallbackQueue for async processing.\r\n\r\n**Acceptance Criteria**:\r\n- Create `CallbackQueue` class using lock-free SPSC queue (similar to RenderCommandQueue)\r\n- C++ enqueues callbacks via `EnqueueCallback(callbackId, resultData)`\r\n- JavaScript dequeues and executes callbacks during its update loop\r\n- C++ never blocks waiting for callback execution\r\n- Callbacks execute on JavaScript worker thread, not main thread\r\n- Support for multiple callback types: entity creation, camera creation, resource loading\r\n- Error in callback doesn't crash C++ thread\r\n\r\n**Technical Details**:\r\n```cpp\r\n// Current (Phase 1) - Synchronous blocking\r\nvoid EntityAPI::ExecutePendingCallbacks() {\r\n    for (auto& [callbackId, pending] : m_pendingCallbacks) {\r\n        if (pending.ready) {\r\n            ExecuteCallback(callbackId, pending.resultId);  // ← Blocks C++ thread\r\n        }\r\n    }\r\n}\r\n\r\n// Target (Phase 2) - Async queue\r\nvoid EntityAPI::ExecutePendingCallbacks() {\r\n    for (auto& [callbackId, pending] : m_pendingCallbacks) {\r\n        if (pending.ready) {\r\n            CallbackData data{callbackId, pending.resultId, pending.errorMsg};\r\n            m_callbackQueue->Enqueue(data);  // ← Never blocks\r\n        }\r\n    }\r\n}\r\n\r\n// JavaScript side\r\nJSEngine.update = function(deltaTime) {\r\n    // Process callbacks from C++\r\n    while (let callback = CallbackQueue.dequeue()) {\r\n        executeCallback(callback.callbackId, callback.resultId);\r\n    }\r\n\r\n    // Normal game logic\r\n    // ...\r\n};\r\n```\r\n\r\n**Files to Create**:\r\n- `C:\\p4\\Personal\\SD\\Engine\\Code\\Engine\\Core\\CallbackQueue.hpp` - Lock-free SPSC queue for callbacks\r\n- `C:\\p4\\Personal\\SD\\Engine\\Code\\Engine\\Core\\CallbackQueue.cpp` - Implementation\r\n\r\n**Files to Modify**:\r\n- `C:\\p4\\Personal\\SD\\Engine\\Code\\Engine\\Entity\\EntityAPI.cpp` - Use CallbackQueue instead of direct execution\r\n- `C:\\p4\\Personal\\SD\\Engine\\Code\\Engine\\Renderer\\CameraAPI.cpp` - Use CallbackQueue instead of direct execution\r\n- `C:\\p4\\Personal\\SD\\ProtogameJS3D\\Run\\Data\\Scripts\\interfaces\\EntityAPI.js` - Dequeue and process callbacks\r\n- `C:\\p4\\Personal\\SD\\ProtogameJS3D\\Run\\Data\\Scripts\\interfaces\\CameraAPI.js` - Dequeue and process callbacks\r\n- `C:\\p4\\Personal\\SD\\ProtogameJS3D\\Run\\Data\\Scripts\\JSEngine.js` - Add callback processing in update loop\r\n\r\n### FR-3: Phase 3 - Error Recovery and Exception Handling\r\n**Given** current implementation has no error recovery,\r\n**When** implementing Phase 3,\r\n**Then** errors in one thread shall not crash the other thread.\r\n\r\n**Acceptance Criteria**:\r\n- Implement `Game::HandleJSException()` to catch and log JavaScript errors\r\n- Wrap `SwapBuffers()` with exception handling and validation\r\n- Add `ValidateStateBuffer()` to detect corruption before swap\r\n- JavaScript errors logged but don't crash C++ thread\r\n- C++ exceptions logged but don't corrupt JavaScript state\r\n- Failed callbacks reported back to C++ with error messages\r\n- Add mutex timeout detection to prevent deadlocks\r\n\r\n**Technical Details**:\r\n```cpp\r\n// Phase 3 - Error recovery\r\nvoid StateBuffer::SwapBuffers() {\r\n    try {\r\n        std::lock_guard lock(m_swapMutex);\r\n\r\n        // Validate before swap\r\n        if (!ValidateStateBuffer(m_backBuffer)) {\r\n            LogError(\"Back buffer validation failed - skipping swap\");\r\n            return;\r\n        }\r\n\r\n        *m_frontBuffer = *m_backBuffer;\r\n        std::swap(m_frontBuffer, m_backBuffer);\r\n        ++m_totalSwaps;\r\n    }\r\n    catch (std::exception const& e) {\r\n        LogError(\"SwapBuffers failed: %s\", e.what());\r\n        // Don't propagate - renderer can use stale front buffer\r\n    }\r\n}\r\n\r\nvoid Game::HandleJSException(v8::TryCatch& tryCatch) {\r\n    v8::String::Utf8Value exception(isolate, tryCatch.Exception());\r\n    v8::Local<v8::Message> message = tryCatch.Message();\r\n\r\n    // Log detailed error info\r\n    LogError(\"JavaScript Exception: %s\", *exception);\r\n    LogError(\"  at %s:%d\", *filename, linenum);\r\n\r\n    // Don't crash - continue game loop\r\n}\r\n```\r\n\r\n**Files to Modify**:\r\n- `C:\\p4\\Personal\\SD\\Engine\\Code\\Engine\\Core\\StateBuffer.hpp` - Add validation and error handling\r\n- `C:\\p4\\Personal\\SD\\ProtogameJS3D\\Code\\Game\\Gameplay\\Game.cpp` - Implement HandleJSException()\r\n- `C:\\p4\\Personal\\SD\\Engine\\Code\\Engine\\Core\\V8Subsystem.cpp` - Wrap all V8 calls with try-catch\r\n- `C:\\p4\\Personal\\SD\\Engine\\Code\\Engine\\Core\\CallbackQueue.cpp` - Add error reporting\r\n\r\n### FR-4: Phase 4 - Dirty Tracking Optimization\r\n**Given** current implementation copies all entities every frame (O(n)),\r\n**When** implementing Phase 4 optimization,\r\n**Then** only dirty entities shall be copied during SwapBuffers().\r\n\r\n**Acceptance Criteria**:\r\n- Add `std::unordered_set<EntityID> m_dirtyEntities` to track modified entities\r\n- `UpdateEntity()` operations mark entity as dirty\r\n- `SwapBuffers()` only copies dirty entities from back to front buffer\r\n- Reduce average swap time from O(n) to O(d) where d = dirty count\r\n- Maintain correctness - no stale data in front buffer\r\n- Add metrics: dirty entity count, swap time, copy count\r\n\r\n**Technical Details**:\r\n```cpp\r\n// Current (Phase 1) - Full copy O(n)\r\nvoid StateBuffer::SwapBuffers() {\r\n    std::lock_guard lock(m_swapMutex);\r\n    *m_frontBuffer = *m_backBuffer;  // Copies ALL entities\r\n    std::swap(m_frontBuffer, m_backBuffer);\r\n}\r\n\r\n// Target (Phase 4) - Dirty tracking O(d)\r\nvoid StateBuffer::SwapBuffers() {\r\n    std::lock_guard lock(m_swapMutex);\r\n\r\n    // Only copy dirty entities\r\n    for (EntityID dirtyId : m_dirtyEntities) {\r\n        auto it = m_backBuffer->find(dirtyId);\r\n        if (it != m_backBuffer->end()) {\r\n            (*m_frontBuffer)[dirtyId] = it->second;  // Copy single entity\r\n        } else {\r\n            m_frontBuffer->erase(dirtyId);  // Entity deleted\r\n        }\r\n    }\r\n\r\n    m_dirtyEntities.clear();\r\n    std::swap(m_frontBuffer, m_backBuffer);\r\n\r\n    // Metrics\r\n    m_avgDirtyCount.Add(m_dirtyEntities.size());\r\n}\r\n\r\nvoid StateBuffer::MarkDirty(EntityID id) {\r\n    m_dirtyEntities.insert(id);\r\n}\r\n```\r\n\r\n**Files to Modify**:\r\n- `C:\\p4\\Personal\\SD\\Engine\\Code\\Engine\\Core\\StateBuffer.hpp` - Add dirty tracking data structures\r\n- `C:\\p4\\Personal\\SD\\Engine\\Code\\Engine\\Core\\StateBuffer.cpp` - Implement dirty-only swap\r\n- `C:\\p4\\Personal\\SD\\ProtogameJS3D\\Code\\Game\\Framework\\App.cpp` - Mark entities dirty in ProcessRenderCommands()\r\n\r\n### FR-5: Remove vertexBufferHandle from EntityState\r\n**Given** vertexBufferHandle is C++ render resource in shared state,\r\n**When** refactoring entity state,\r\n**Then** render resources shall be separated from game state.\r\n\r\n**Acceptance Criteria**:\r\n- Create `RenderResourceManager` to store vertexBufferHandle separately\r\n- Map EntityID → vertexBufferHandle in C++ only\r\n- Remove `vertexBufferHandle` field from `EntityState` struct\r\n- JavaScript never sees or accesses render resources\r\n- `EntityState` contains only game-relevant data: position, orientation, color, radius, meshType\r\n\r\n**Technical Details**:\r\n```cpp\r\n// Current - Mixed concerns\r\nstruct EntityState {\r\n    Vec3 position;\r\n    EulerAngles orientation;\r\n    Rgba8 color;\r\n    float radius;\r\n    std::string meshType;\r\n    bool isActive;\r\n    int vertexBufferHandle;  // ❌ C++ render resource polluting shared state\r\n    std::string cameraType;\r\n};\r\n\r\n// Target - Clean separation\r\nstruct EntityState {\r\n    Vec3 position;           // ✅ Game state\r\n    EulerAngles orientation; // ✅ Game state\r\n    Rgba8 color;             // ✅ Game state\r\n    float radius;            // ✅ Game state\r\n    std::string meshType;    // ✅ Configuration\r\n    bool isActive;           // ✅ Game state\r\n    std::string cameraType;  // ✅ Configuration\r\n};\r\n\r\nclass RenderResourceManager {\r\n    std::unordered_map<EntityID, int> m_vertexBuffers;  // C++ only\r\n    std::unordered_map<EntityID, int> m_textures;       // C++ only\r\npublic:\r\n    void AssignVertexBuffer(EntityID id, int handle);\r\n    int GetVertexBuffer(EntityID id) const;\r\n};\r\n```\r\n\r\n**Files to Modify**:\r\n- `C:\\p4\\Personal\\SD\\Engine\\Code\\Engine\\Entity\\EntityState.hpp` - Remove vertexBufferHandle\r\n- `C:\\p4\\Personal\\SD\\ProtogameJS3D\\Code\\Game\\Framework\\App.hpp` - Add RenderResourceManager\r\n- `C:\\p4\\Personal\\SD\\ProtogameJS3D\\Code\\Game\\Framework\\App.cpp` - Use RenderResourceManager in ProcessRenderCommands()\r\n\r\n### FR-6: Formal Phase Documentation\r\n**Given** phases exist only as scattered code comments,\r\n**When** documenting the architecture,\r\n**Then** create formal phase documentation explaining the roadmap.\r\n\r\n**Acceptance Criteria**:\r\n- Create `Docs/architecture/AsyncArchitecturePhases.md` document\r\n- Document Phase 1: Async Infrastructure (✅ Complete)\r\n- Document Phase 2: Worker Thread Execution\r\n- Document Phase 3: Error Recovery\r\n- Document Phase 4: Performance Optimization\r\n- Include diagrams showing thread relationships\r\n- Include code examples for each phase\r\n- Explain trade-offs and design decisions\r\n\r\n**Files to Create**:\r\n- `C:\\p4\\Personal\\SD\\ProtogameJS3D\\Docs\\architecture\\AsyncArchitecturePhases.md` - Complete phase documentation\r\n\r\n## Non-Functional Requirements\r\n\r\n### NFR-1: Thread Safety\r\n**Given** C++ and JavaScript run on separate threads,\r\n**When** implementing decoupled architecture,\r\n**Then** all shared data structures shall be thread-safe.\r\n\r\n**Acceptance Criteria**:\r\n- No data races detected by ThreadSanitizer\r\n- Lock-free queues properly synchronized\r\n- StateBuffer swap uses std::mutex\r\n- Front buffer read-only for JavaScript thread\r\n- Back buffer write-only for C++ thread\r\n\r\n### NFR-2: Performance\r\n**Given** the goal is independent thread speeds,\r\n**When** measuring performance,\r\n**Then** C++ rendering shall maintain 60+ FPS regardless of JavaScript performance.\r\n\r\n**Acceptance Criteria**:\r\n- C++ rendering: 60+ FPS\r\n- JavaScript logic: 30-60 FPS (independent of C++)\r\n- Queue operations: < 1µs per operation\r\n- SwapBuffers with dirty tracking: < 100µs for 100 dirty entities\r\n- No frame drops when JavaScript slows down\r\n\r\n### NFR-3: Backward Compatibility\r\n**Given** existing JavaScript game code,\r\n**When** implementing Phase 2-4,\r\n**Then** existing JavaScript APIs shall remain compatible.\r\n\r\n**Acceptance Criteria**:\r\n- EntityAPI.js methods work unchanged\r\n- CameraAPI.js methods work unchanged\r\n- Callbacks work identically from JavaScript perspective\r\n- No breaking changes to game logic code\r\n\r\n### NFR-4: Testability\r\n**Given** complex multi-threaded architecture,\r\n**When** implementing Phase 2-4,\r\n**Then** components shall be testable in isolation.\r\n\r\n**Acceptance Criteria**:\r\n- CallbackQueue testable without V8\r\n- StateBuffer testable without JavaScript\r\n- RenderCommandQueue testable without rendering\r\n- Mock JavaScript worker for C++ testing\r\n- Mock C++ thread for JavaScript testing\r\n\r\n## Success Criteria\r\n\r\n### Phase 2 Success Criteria\r\n- [ ] JavaScript executes on worker thread via `UpdateJSWorkerThread()`\r\n- [ ] Main thread never calls `UpdateJS()`\r\n- [ ] JavaScript worker thread has independent game loop\r\n- [ ] C++ rendering maintains 60 FPS while JavaScript runs at 30 FPS\r\n- [ ] CallbackQueue implemented and used for all C++→JS callbacks\r\n- [ ] No synchronous callback execution blocking C++ thread\r\n\r\n### Phase 3 Success Criteria\r\n- [ ] `HandleJSException()` catches and logs JavaScript errors without crashing\r\n- [ ] `SwapBuffers()` has exception handling and validation\r\n- [ ] `ValidateStateBuffer()` detects corruption\r\n- [ ] Failed callbacks report errors back to C++\r\n- [ ] No deadlocks or mutex timeouts\r\n- [ ] Error recovery tested with intentional failures\r\n\r\n### Phase 4 Success Criteria\r\n- [ ] Dirty tracking implemented in StateBuffer\r\n- [ ] SwapBuffers() only copies dirty entities\r\n- [ ] Metrics show average dirty count << total entity count\r\n- [ ] SwapBuffers() time reduced by 50%+ for typical workloads\r\n- [ ] Correctness maintained - no stale data bugs\r\n\r\n### Phase 5 (vertexBufferHandle) Success Criteria\r\n- [ ] `vertexBufferHandle` removed from EntityState\r\n- [ ] RenderResourceManager created and used\r\n- [ ] JavaScript never accesses render resources\r\n- [ ] EntityState contains only game-relevant data\r\n- [ ] All rendering code uses RenderResourceManager\r\n\r\n### Documentation Success Criteria\r\n- [ ] `AsyncArchitecturePhases.md` document created\r\n- [ ] All 4 phases documented with code examples\r\n- [ ] Thread relationship diagrams included\r\n- [ ] Design trade-offs explained\r\n\r\n## Out of Scope\r\n\r\n- JavaScript multi-threading (JavaScript remains single-threaded)\r\n- C++ multi-threaded rendering (rendering remains on main thread)\r\n- Entity Component System (ECS) architecture\r\n- Network synchronization\r\n- Save/load system modifications\r\n- GPU-side optimizations\r\n\r\n## Dependencies\r\n\r\n**Required Systems** (already exist):\r\n- EntityStateBuffer, CameraStateBuffer (Phase 1 ✅)\r\n- RenderCommandQueue (Phase 1 ✅)\r\n- V8Subsystem with V8 isolate management (Phase 1 ✅)\r\n- EntityAPI, CameraAPI (Phase 1 ✅)\r\n\r\n**New Dependencies**:\r\n- `std::thread` support for worker thread\r\n- Lock-free queue library (already used for RenderCommandQueue)\r\n- C++20 features for thread safety\r\n\r\n## Risks and Mitigation\r\n\r\n**Risk 1: V8 Thread Safety (HIGH)**\r\n- **Description**: V8 isolates are not thread-safe by default\r\n- **Probability**: HIGH\r\n- **Mitigation**: Use V8 Locker API, one isolate per thread, no shared V8 objects\r\n- **Contingency**: If Locker causes performance issues, use message passing instead of shared isolates\r\n\r\n**Risk 2: Deadlock on Queues (MEDIUM)**\r\n- **Description**: Circular dependencies between RenderCommandQueue and CallbackQueue could deadlock\r\n- **Probability**: MEDIUM\r\n- **Mitigation**: Careful lock ordering, timeout detection, deadlock testing\r\n- **Contingency**: Add queue size limits and overflow handling\r\n\r\n**Risk 3: Phase 4 Complexity (MEDIUM)**\r\n- **Description**: Dirty tracking bugs could cause rendering artifacts\r\n- **Probability**: MEDIUM\r\n- **Mitigation**: Extensive testing, add debug mode with full copy for validation\r\n- **Contingency**: Keep full-copy mode as fallback option\r\n\r\n**Risk 4: Performance Regression (LOW)**\r\n- **Description**: Overhead of worker thread and queues could slow down system\r\n- **Probability**: LOW\r\n- **Mitigation**: Profile at each phase, benchmark against Phase 1 baseline\r\n- **Contingency**: Optimize queue operations, reduce lock contention\r\n\r\n## Implementation Order\r\n\r\n1. **Phase 2.1**: Implement CallbackQueue (independent, testable)\r\n2. **Phase 2.2**: Integrate CallbackQueue into EntityAPI/CameraAPI\r\n3. **Phase 2.3**: Create JavaScriptWorkerThread class\r\n4. **Phase 2.4**: Connect UpdateJSWorkerThread() and test worker execution\r\n5. **Phase 3.1**: Add SwapBuffers() error handling\r\n6. **Phase 3.2**: Implement HandleJSException()\r\n7. **Phase 3.3**: Add validation and recovery mechanisms\r\n8. **Phase 4.1**: Implement dirty tracking in StateBuffer\r\n9. **Phase 4.2**: Optimize SwapBuffers() to use dirty tracking\r\n10. **Phase 4.3**: Add metrics and validation\r\n11. **Phase 5**: Remove vertexBufferHandle and create RenderResourceManager\r\n12. **Documentation**: Create AsyncArchitecturePhases.md\r\n\r\n## Notes\r\n\r\n- This spec completes the architectural vision started in M4-T8\r\n- Phase 1 infrastructure is already complete and working\r\n- Phases 2-4 build incrementally on Phase 1\r\n- Each phase is independently testable\r\n- Worker thread execution (Phase 2) is the most critical change\r\n- Dirty tracking (Phase 4) provides the largest performance win\r\n- Error recovery (Phase 3) ensures production robustness\r\n",
  "fileStats": {
    "size": 19520,
    "lines": 479,
    "lastModified": "2025-11-18T10:39:11.334Z"
  },
  "comments": []
}