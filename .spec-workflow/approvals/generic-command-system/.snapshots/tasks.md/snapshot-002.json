{
  "id": "snapshot_1770737541346_fqmuhnx1y",
  "approvalId": "approval_1770733277822_o8yhmv8uv",
  "approvalTitle": "GenericCommand System - Implementation Tasks",
  "version": 2,
  "timestamp": "2026-02-10T15:32:21.346Z",
  "trigger": "revision_requested",
  "status": "pending",
  "content": "# Tasks: GenericCommand System\n\n## Phase 1: Core Data Structures (Foundation)\n\n- [ ] 1.1. Create GenericCommand structure definition\n  - File: `Engine/Code/Engine/Core/GenericCommand.hpp` (new)\n  - Define `GenericCommand` struct with: `String type`, `v8::Persistent<v8::Object> payload`, `String agentId`, `uint64_t timestamp`, `CallbackID callbackId`, `v8::Persistent<v8::Function> callback`\n  - Implement constructor, destructor (V8 handle disposal), copy constructor, assignment operator\n  - Purpose: Encapsulate command data with V8 payload and optional callback support\n  - _Leverage: Engine/Code/Engine/Core/CallbackData.hpp (CallbackID type), Engine/Code/Engine/Entity/EntityScriptInterface.hpp (V8 Persistent handle patterns)_\n  - _Requirements: Requirement 1 (Generic Command Structure)_\n  - _Prompt: Role: C++ Engine Developer specializing in V8 integration and RAII patterns | Task: Create GenericCommand.hpp defining the GenericCommand struct with V8 Persistent handles for payload and callback, following the same V8 handle lifecycle patterns used in EntityScriptInterface (copy via v8::Persistent copy constructor, dispose in destructor) | Restrictions: Must use RAII for V8 handle disposal, follow existing naming conventions (m_ prefix, PascalCase), include proper include guards, do not include V8 headers directly (use forward declarations where possible), struct size target ~400 bytes | Success: GenericCommand.hpp compiles independently, V8 handles properly managed (no leaks), copy semantics correct, destructor disposes handles, follows existing code style_\n\n- [ ] 1.2. Create HandlerResult structure with V8 conversion\n  - File: `Engine/Code/Engine/Core/HandlerResult.hpp` (new)\n  - File: `Engine/Code/Engine/Core/HandlerResult.cpp` (new)\n  - Define `HandlerResult` struct with: `std::unordered_map<String, std::any> data`, `String error`\n  - Implement factory methods: `HandlerResult::Success(data)`, `HandlerResult::Error(message)`\n  - Implement `toV8Object(v8::Isolate*)` for converting result to JavaScript object\n  - Purpose: Structured return values from handlers for callback delivery\n  - _Leverage: Engine/Code/Engine/Entity/EntityScriptInterface.cpp (V8 object creation patterns, ExtractVec3)_\n  - _Requirements: Requirement 7 (Async Callback Support)_\n  - _Prompt: Role: C++ Developer specializing in V8 API and type-erased containers | Task: Create HandlerResult with std::any-based data map, factory methods for success/error, and toV8Object() conversion that creates a JavaScript object from the data map, following V8 object creation patterns from EntityScriptInterface | Restrictions: Support common types in std::any (int, float, double, String, EntityID, Vec3), toV8Object must handle all supported types gracefully, error field empty means success, follow existing code style | Success: HandlerResult compiles, factory methods work correctly, toV8Object produces valid V8 objects, unsupported types in std::any logged as warnings (not crashes), follows existing patterns_\n\n- [ ] 1.3. Add GENERIC to CallbackType enum\n  - File: `Engine/Code/Engine/Core/CallbackData.hpp` (modify existing)\n  - Add `GENERIC` value to `CallbackType` enum after existing values\n  - Purpose: Enable CallbackQueue to carry GenericCommand callback results\n  - _Leverage: Engine/Code/Engine/Core/CallbackData.hpp (existing enum)_\n  - _Requirements: Requirement 7 (Async Callback Support)_\n  - _Prompt: Role: C++ Developer | Task: Add GENERIC value to the existing CallbackType enum in CallbackData.hpp | Restrictions: Add after existing values to preserve binary compatibility, add comment explaining purpose, do not modify existing enum values | Success: GENERIC added to enum, existing code unaffected, comment documents purpose_\n\n## Phase 2: Queue and Executor (Core Infrastructure)\n\n- [ ] 2.1. Create GenericCommandQueue inheriting CommandQueueBase\n  - File: `Engine/Code/Engine/Core/GenericCommandQueue.hpp` (new)\n  - File: `Engine/Code/Engine/Core/GenericCommandQueue.cpp` (new)\n  - Inherit from `CommandQueueBase<GenericCommand>` with DEFAULT_CAPACITY = 500\n  - Override `OnSubmit()` for optional logging, `OnQueueFull()` for backpressure warning\n  - Purpose: Lock-free SPSC queue for JS→Main thread command transport\n  - _Leverage: Engine/Code/Engine/Core/CommandQueueBase.hpp (template base), Engine/Code/Engine/Core/CallbackQueue.hpp (inheritance pattern)_\n  - _Requirements: Requirement 1 (Generic Command Structure), Requirement 6 (Performance)_\n  - _Prompt: Role: C++ Engine Developer with expertise in lock-free queues | Task: Create GenericCommandQueue inheriting from `CommandQueueBase<GenericCommand>` with capacity 500, overriding OnSubmit and OnQueueFull virtual hooks for logging, following the exact same pattern as CallbackQueue | Restrictions: Must be minimal code (template does heavy lifting), capacity 500 commands (~200KB), follow existing queue naming and style, include header documentation explaining capacity choice | Success: GenericCommandQueue compiles, inherits all SPSC functionality, OnQueueFull logs warning, capacity appropriate for 1000+ commands/sec at 60 FPS, code is concise (`<50` lines total)_\n\n- [ ] 2.2. Create GenericCommandExecutor with handler registry\n  - File: `Engine/Code/Engine/Core/GenericCommandExecutor.hpp` (new)\n  - File: `Engine/Code/Engine/Core/GenericCommandExecutor.cpp` (new)\n  - Implement handler registry: `std::unordered_map<String, HandlerFunc> m_handlers`\n  - Implement `RegisterHandler()`, `UnregisterHandler()`, `HasHandler()`, `GetRegisteredTypes()`\n  - Implement `ExecuteCommand()` with try-catch error handling and callback enqueue\n  - Implement `GenerateCallbackID()` and callback tracking via `m_pendingCallbacks`\n  - Constructor takes `CallbackQueue*` and `ScriptSubsystem*`\n  - Purpose: Handler registry and command execution with callback support\n  - _Leverage: Engine/Code/Engine/Core/CallbackQueue.hpp (callback enqueue), Engine/Code/Engine/Script/ScriptSubsystem.hpp (V8 context access)_\n  - _Requirements: Requirement 2 (Runtime Handler Registry), Requirement 7 (Async Callback Support)_\n  - _Prompt: Role: C++ Engine Developer specializing in command pattern and thread-safe registries | Task: Create GenericCommandExecutor with std::unordered_map handler registry, mutex-protected registration (worker thread), lock-free execution (main thread reads only), try-catch error handling in ExecuteCommand, and CallbackQueue integration for async result delivery | Restrictions: Mutex ONLY for RegisterHandler/UnregisterHandler (worker thread), ExecuteCommand must be lock-free (main thread), handler signature is `std::function<HandlerResult(v8::Local<v8::Object>)>`, callback enqueue follows EntityAPI::ExecutePendingCallbacks pattern, error in handler must not crash engine | Success: Handler registry works correctly, RegisterHandler thread-safe, ExecuteCommand lock-free on main thread, errors caught and logged, callbacks enqueued to CallbackQueue, unregistered command types logged as warnings_\n\n## Phase 3: JavaScript Bindings (V8 Bridge)\n\n- [ ] 3.1. Create GenericCommandScriptInterface\n  - File: `Engine/Code/Engine/Script/GenericCommandScriptInterface.hpp` (new)\n  - File: `Engine/Code/Engine/Script/GenericCommandScriptInterface.cpp` (new)\n  - Implement `IScriptableObject` interface: `InitializeMethodRegistry()`, `CallMethod()`, `GetAvailableMethods()`\n  - Implement `ExecuteSubmit()`: extract type, payload (v8::Object), agentId, optional callback; create GenericCommand; submit to queue\n  - Implement `ExecuteRegisterHandler()`: extract type and v8::Function; store as handler in executor\n  - Implement `ExecuteUnregisterHandler()`: remove handler by type\n  - Implement `ExecuteGetRegisteredTypes()`: return array of registered type strings\n  - Implement `ExecuteExecutePendingCallbacks()`: dequeue from CallbackQueue, execute JS callbacks\n  - Purpose: Single universal V8 bridge for all GenericCommand operations\n  - _Leverage: Engine/Code/Engine/Entity/EntityScriptInterface.hpp/.cpp (IScriptableObject pattern, ExtractCallback, ScriptMethodResult), Engine/Code/Engine/Core/CallbackQueueScriptInterface.cpp (dequeueAll pattern)_\n  - _Requirements: Requirement 3 (JavaScript CommandQueue API), Requirement 7 (Async Callback Support)_\n  - _Prompt: Role: C++ V8 Integration Developer specializing in JavaScript bindings | Task: Create GenericCommandScriptInterface implementing IScriptableObject with methods for submit, registerHandler, unregisterHandler, getRegisteredTypes, and executePendingCallbacks, following the exact patterns from EntityScriptInterface for V8 argument extraction and CallbackQueueScriptInterface for callback delivery | Restrictions: Must follow IScriptableObject interface exactly, validate all JS arguments before C++ calls, handle queue full gracefully (return false), callback extraction follows EntityScriptInterface::ExtractCallback pattern, executePendingCallbacks follows CallbackQueueScriptInterface::ExecuteDequeueAll pattern | Success: All 5 methods work correctly from JavaScript, V8 arguments validated, queue full returns false to JS, callbacks delivered correctly, follows existing ScriptInterface conventions, no V8 handle leaks_\n\n## Phase 4: JavaScript Facade and Engine Integration\n\n- [ ] 4.1. Create CommandQueue.js JavaScript facade\n  - File: `Run/Data/Scripts/CommandQueue.js` (new)\n  - Implement `CommandQueue` class with static methods: `submit()`, `registerHandler()`, `unregisterHandler()`, `getRegisteredTypes()`, `update()`\n  - Add client-side validation: payload must be object, handler must be function, type must be string\n  - Add `update()` method that calls `GenericCommandScriptInterface.executePendingCallbacks()`\n  - Purpose: Clean JavaScript API facade with validation and ergonomics\n  - _Leverage: Run/Data/Scripts/Interface/EntityAPI.js (facade pattern), Run/Data/Scripts/Interface/CameraAPI.js (facade pattern)_\n  - _Requirements: Requirement 3 (JavaScript CommandQueue API)_\n  - _Prompt: Role: JavaScript Developer specializing in API design and V8 engine integration | Task: Create CommandQueue.js facade class with static methods for submit, registerHandler, unregisterHandler, getRegisteredTypes, and update, following the same facade pattern as EntityAPI.js and CameraAPI.js, with client-side argument validation | Restrictions: Must validate arguments before calling C++ ScriptInterface (type safety), follow existing JS code style (ES6+ classes), update() must call executePendingCallbacks, include JSDoc comments for all methods, error messages must be descriptive | Success: CommandQueue.js provides clean API, validates arguments before C++ calls, update() processes callbacks, JSDoc documented, follows existing facade patterns, error messages help debugging_\n\n- [ ] 4.2. Integrate GenericCommand into App.hpp/App.cpp\n  - File: `Code/Game/Framework/App.hpp` (modify existing)\n  - File: `Code/Game/Framework/App.cpp` (modify existing)\n  - Add forward declarations and member pointers: `GenericCommandQueue*`, `GenericCommandExecutor*`, `GenericCommandScriptInterface`\n  - Initialize in constructor/startup: allocate queue, executor (with CallbackQueue and ScriptSubsystem), script interface\n  - Register GenericCommandScriptInterface with V8Subsystem\n  - Add `ProcessGenericCommands()` in `Update()`: `m_genericCommandQueue->ConsumeAll()` → `m_genericCommandExecutor->ExecuteCommand()`\n  - Add `m_genericCommandExecutor->ExecutePendingCallbacks(m_callbackQueue)` in Update()\n  - Cleanup in destructor\n  - Purpose: Wire GenericCommand system into the main application loop\n  - _Leverage: Code/Game/Framework/App.cpp (existing Update loop, ScriptInterface registration pattern)_\n  - _Requirements: Requirement 1-7 (all core requirements depend on App integration)_\n  - _Prompt: Role: C++ Application Developer specializing in game engine main loops | Task: Integrate GenericCommand system into App by adding member pointers, initialization, V8Subsystem registration, ProcessGenericCommands() call in Update() loop (after existing ProcessRenderCommands), callback enqueue, and cleanup in destructor, following the exact same patterns used for EntityAPI/CameraAPI integration | Restrictions: Must not break existing Update() flow, GenericCommand processing happens AFTER existing command processing, ScriptInterface registration follows existing pattern, destructor cleanup in reverse order of construction, null-check all pointers | Success: GenericCommand system fully wired into App, commands processed each frame, callbacks delivered, no impact on existing systems, clean startup/shutdown, follows existing integration patterns_\n\n- [ ] 4.3. Integrate CommandQueue.update() into JSEngine.js\n  - File: `Run/Data/Scripts/JSEngine.js` (modify existing)\n  - Add `CommandQueue.update()` call in the engine update loop\n  - Purpose: Ensure pending callbacks are processed each JavaScript frame\n  - _Leverage: Run/Data/Scripts/JSEngine.js (existing update loop structure)_\n  - _Requirements: Requirement 3 (JavaScript CommandQueue API), Requirement 7 (Async Callback Support)_\n  - _Prompt: Role: JavaScript Developer | Task: Add CommandQueue.update() call in JSEngine.js update loop to process pending callbacks each frame | Restrictions: Must be called after existing update logic, do not modify existing update flow, add import/require for CommandQueue.js if needed | Success: CommandQueue.update() called each frame, callbacks processed, existing update logic unaffected_\n\n## Phase 5: Safety, Monitoring, and Schema Validation\n\n- [ ] 5.1. Add rate limiting to GenericCommandExecutor\n  - File: `Engine/Code/Engine/Core/GenericCommandExecutor.hpp` (modify)\n  - File: `Engine/Code/Engine/Core/GenericCommandExecutor.cpp` (modify)\n  - Add per-agent rate limiting: `std::unordered_map<String, RateLimitState> m_agentRateLimits`\n  - Implement sliding 1-second window, 100 commands/second per agent (configurable)\n  - Return ERR_RATE_LIMITED when exceeded\n  - Purpose: Prevent agent abuse and protect engine stability\n  - _Leverage: Design document Section \"Safety Measures and Monitoring\"_\n  - _Requirements: Requirement 5 (Safety Measures and Monitoring)_\n  - _Prompt: Role: C++ Developer specializing in rate limiting and security | Task: Add per-agent rate limiting to GenericCommandExecutor using sliding window algorithm (1-second window, 100 commands/sec default), tracking submission counts per agentId | Restrictions: Rate limit check must be fast (`<1µs`), configurable limit, log rejections with agentId and command type, do not block main thread | Success: Rate limiting works correctly, excess commands rejected with ERR_RATE_LIMITED, per-agent tracking accurate, configurable threshold, minimal performance impact_\n\n- [ ] 5.2. Add command statistics and audit logging\n  - File: `Engine/Code/Engine/Core/GenericCommandExecutor.hpp` (modify)\n  - File: `Engine/Code/Engine/Core/GenericCommandExecutor.cpp` (modify)\n  - Add `GetStatistics()` returning per-agent counts: submitted, executed, failed, dropped\n  - Add audit trail logging: timestamp, agentId, command type, success/failure\n  - Purpose: Debugging and monitoring of command flow\n  - _Leverage: Design document Section \"Safety Measures and Monitoring\"_\n  - _Requirements: Requirement 5 (Safety Measures and Monitoring)_\n  - _Prompt: Role: C++ Developer specializing in monitoring and observability | Task: Add GetStatistics() method returning per-agent command counts and audit trail logging to GenericCommandExecutor | Restrictions: Statistics collection must be low-overhead, audit log format must be parseable (JSON), do not log payload contents (privacy/performance), log to existing engine logging system | Success: GetStatistics() returns accurate per-agent counts, audit trail logs all commands, logging overhead minimal, follows existing logging patterns_\n\n- [ ] 5.3. Add schema validation to CommandQueue.js\n  - File: `Run/Data/Scripts/CommandQueue.js` (modify)\n  - Implement `registerSchema(type, schemaDefinition)` for optional payload validation\n  - Implement `setValidationEnabled(boolean)` for global toggle\n  - Validate payloads against registered schemas before C++ submission\n  - Purpose: Catch payload errors early in JavaScript before crossing V8 bridge\n  - _Leverage: Design document Section \"Schema Validation Architecture\"_\n  - _Requirements: Requirement 3 (JavaScript CommandQueue API, acceptance criteria 3-4)_\n  - _Prompt: Role: JavaScript Developer specializing in validation and schema systems | Task: Add registerSchema() and setValidationEnabled() to CommandQueue.js, implementing declarative schema validation (type checking, required fields, defaults) that runs before C++ submission | Restrictions: Validation must be fast (~5-10us per command), schemas are optional (unregistered types skip validation), validation errors throw descriptive TypeError, support nested object schemas, bypass option for performance-critical paths | Success: Schema validation catches invalid payloads before C++ call, descriptive error messages, optional and bypassable, minimal performance impact, supports nested objects_\n\n## Phase 6: Configuration and Hot-Reload Support\n\n- [ ] 6.1. Add GenericCommand configuration to GameConfig.xml\n  - File: `Run/Data/GameConfig.xml` (modify existing)\n  - Add `<GenericCommandConfig>` section with: QueueCapacity, RateLimitPerAgent, EnableValidation\n  - Read configuration in App.cpp during initialization\n  - Purpose: Runtime-configurable GenericCommand parameters\n  - _Leverage: Run/Data/GameConfig.xml (existing config structure), Code/Game/Framework/App.cpp (existing config reading)_\n  - _Requirements: Requirement 5 (Safety Measures, configurable rate limit)_\n  - _Prompt: Role: C++ Developer | Task: Add GenericCommandConfig section to GameConfig.xml and read values in App.cpp during GenericCommand initialization | Restrictions: Follow existing XML config structure, provide sensible defaults if section missing, do not break existing config parsing | Success: Config values read correctly, defaults work when section absent, follows existing config patterns_\n\n- [ ] 6.2. Implement hot-reload handler re-registration\n  - File: `Engine/Code/Engine/Core/GenericCommandExecutor.hpp` (modify)\n  - File: `Engine/Code/Engine/Core/GenericCommandExecutor.cpp` (modify)\n  - Ensure `RegisterHandler()` atomically replaces existing handlers (same type)\n  - In-flight commands continue with old handler (no mid-execution replacement)\n  - Purpose: Support JavaScript hot-reload without losing command handling capability\n  - _Leverage: Engine/Code/Engine/Script/ScriptReloader.hpp (hot-reload system)_\n  - _Requirements: Requirement 3 (JavaScript CommandQueue API, acceptance criteria 9-10)_\n  - _Prompt: Role: C++ Developer specializing in thread-safe data structures | Task: Ensure RegisterHandler atomically replaces existing handlers for the same command type, with in-flight commands completing with the old handler | Restrictions: Mutex protects registration (worker thread only), ExecuteCommand reads handler once at start (no mid-execution replacement), log handler replacement for debugging | Success: Handler replacement is atomic, in-flight commands unaffected, hot-reload works correctly, replacement logged_\n\n## Phase 7: Testing and Documentation\n\n- [ ] 7.1. Write unit tests for GenericCommandQueue\n  - File: `Engine/Tests/GenericCommandQueueTests.cpp` (new)\n  - Test: Submit/ConsumeAll with GenericCommand, queue full backpressure, V8 handle lifecycle (copy/dispose), statistics tracking\n  - Purpose: Validate queue correctness with V8 payload commands\n  - _Requirements: Design document \"Testing Strategy\" section_\n  - _Prompt: Role: QA Engineer with expertise in C++ unit testing and V8 integration | Task: Create unit tests for GenericCommandQueue covering Submit/ConsumeAll operations, queue full behavior, V8 Persistent handle lifecycle (copy in Submit, dispose after ConsumeAll), and statistics tracking | Restrictions: Must test V8 handle refcount correctness, test queue full returns false, test empty queue ConsumeAll is no-op, use existing test framework | Success: All queue operations tested, V8 handle lifecycle verified (no leaks), backpressure tested, statistics accurate_\n\n- [ ] 7.2. Write unit tests for GenericCommandExecutor\n  - File: `Engine/Tests/GenericCommandExecutorTests.cpp` (new)\n  - Test: RegisterHandler/UnregisterHandler, ExecuteCommand with registered/unregistered types, handler exception catching, callback enqueue, rate limiting\n  - Purpose: Validate executor correctness and error handling\n  - _Requirements: Design document \"Testing Strategy\" section_\n  - _Prompt: Role: QA Engineer with expertise in C++ testing and mock objects | Task: Create unit tests for GenericCommandExecutor covering handler registration, command execution, unregistered type handling, exception catching, callback delivery, and rate limiting | Restrictions: Test both C++ and JavaScript handler types, verify error isolation (exception doesn't crash), verify callback enqueued correctly, test rate limiting threshold | Success: All executor operations tested, error isolation verified, callbacks delivered correctly, rate limiting works at threshold_\n\n- [ ] 7.3. Write integration test for end-to-end command flow\n  - File: `Engine/Tests/GenericCommandIntegrationTests.cpp` (new)\n  - Test: JavaScript submit → GenericCommandQueue → GenericCommandExecutor → handler execution → CallbackQueue → JavaScript callback\n  - Test: Hot-reload handler re-registration with in-flight commands\n  - Purpose: Validate complete command pipeline\n  - _Requirements: Design document \"End-to-End Testing\" section_\n  - _Prompt: Role: Integration Test Engineer | Task: Create integration tests validating the complete GenericCommand pipeline from JavaScript submission through handler execution to callback delivery, including hot-reload scenarios | Restrictions: Must test actual V8 execution (not mocked), test both fire-and-forget and callback patterns, test handler replacement during hot-reload, verify no memory leaks | Success: End-to-end pipeline works correctly, callbacks delivered with correct data, hot-reload tested, no memory leaks detected_\n\n- [ ] 7.4. Performance benchmark: Verify design targets\n  - File: `Engine/Tests/GenericCommandBenchmarks.cpp` (new)\n  - Benchmark: Submit latency (`<10us`), execution throughput (1000+ commands/frame), callback overhead (`<5us`), handler lookup (`<0.1us`)\n  - Test: Submit 1000 commands/frame for 60 frames without drops\n  - Purpose: Validate performance meets design requirements\n  - _Requirements: Requirement 6 (Performance Characteristics)_\n  - _Prompt: Role: Performance Engineer | Task: Create benchmarks measuring GenericCommand submission latency, execution throughput, callback overhead, and handler lookup time against design targets | Restrictions: Use consistent methodology (warm-up, iterations), measure p50/p95/p99 latencies, test sustained load (60 frames), document results | Success: Submission `<10us`, throughput 1000+/frame, callback `<5us`, handler lookup `<0.1us`, sustained load passes without drops_\n\n- [ ] 7.5. Update CLAUDE.md documentation\n  - File: `CLAUDE.md` (modify existing, root)\n  - File: `Run/Data/Scripts/CLAUDE.md` (modify existing)\n  - Update architecture diagrams to include GenericCommand system\n  - Document CommandQueue.js API in JavaScript module docs\n  - Add GenericCommand to module index\n  - Purpose: Maintain AI assistant context documentation\n  - _Requirements: Non-Functional Requirements (Documentation)_\n  - _Prompt: Role: Technical Writer | Task: Update CLAUDE.md files to document GenericCommand system architecture, CommandQueue.js API, and integration points | Restrictions: Follow existing CLAUDE.md format, update diagrams, add to module index, do not remove existing documentation | Success: CLAUDE.md accurately reflects new architecture, CommandQueue.js documented, diagrams updated_\n\n## Success Criteria Summary\n\n### Core Functionality\n- **Command Submission**: JavaScript can submit GenericCommands with V8 object payloads to C++ ✓\n- **Handler Registry**: C++ and JavaScript handlers can be registered/unregistered at runtime ✓\n- **Command Execution**: Main thread processes commands via registered handlers ✓\n- **Async Callbacks**: Optional callbacks delivered via existing CallbackQueue infrastructure ✓\n- **Hot-Reload**: Handler re-registration works correctly after JavaScript file reload ✓\n\n### Architecture Preservation\n- **Non-Blocking Threads**: JavaScript worker independent of C++ main thread (lock-free SPSC) ✓\n- **60 FPS Guarantee**: Main thread remains lock-free during command processing ✓\n- **V8 Bridge Consistency**: GenericCommandScriptInterface follows IScriptableObject pattern ✓\n- **Existing APIs Untouched**: EntityAPI, CameraAPI, StateBuffers unchanged ✓\n- **CallbackQueue Reused**: No new callback infrastructure (shared with existing APIs) ✓\n\n### Performance Targets\n- **Submission Latency**: < 10µs per command ✓\n- **Execution Throughput**: 1000+ commands/frame at 60 FPS ✓\n- **Callback Overhead**: < 5µs per callback enqueue ✓\n- **Handler Lookup**: O(1) hash map, < 0.1µs ✓\n- **Memory**: ~400 bytes/command, 200 KB queue capacity ✓\n\n### Safety and Monitoring\n- **Rate Limiting**: 100 commands/sec per agent (configurable) ✓\n- **Schema Validation**: Optional JavaScript-side payload validation ✓\n- **Audit Trail**: All commands logged with agentId, timestamp, type ✓\n- **Error Isolation**: Handler exceptions caught, logged, do not crash engine ✓\n\n### Testing\n- **Unit Tests**: Queue, Executor, HandlerResult tested ✓\n- **Integration Tests**: End-to-end pipeline validated ✓\n- **Performance Benchmarks**: All targets met ✓\n- **Hot-Reload Tests**: Handler re-registration validated ✓\n\n### Files Created (10 new)\n- `Engine/Code/Engine/Core/GenericCommand.hpp`\n- `Engine/Code/Engine/Core/GenericCommandQueue.hpp` + `.cpp`\n- `Engine/Code/Engine/Core/GenericCommandExecutor.hpp` + `.cpp`\n- `Engine/Code/Engine/Core/HandlerResult.hpp` + `.cpp`\n- `Engine/Code/Engine/Script/GenericCommandScriptInterface.hpp` + `.cpp`\n- `Run/Data/Scripts/CommandQueue.js`\n\n### Files Modified (4-5 existing)\n- `Engine/Code/Engine/Core/CallbackData.hpp` (add GENERIC to enum)\n- `Code/Game/Framework/App.hpp` + `App.cpp` (integration)\n- `Run/Data/Scripts/JSEngine.js` (CommandQueue.update() call)\n- `Run/Data/GameConfig.xml` (optional config section)\n",
  "fileStats": {
    "size": 26431,
    "lines": 252,
    "lastModified": "2026-02-10T14:20:54.578Z"
  },
  "comments": []
}