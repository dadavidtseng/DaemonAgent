{
  "id": "snapshot_1765551871750_8mqk2qce2",
  "approvalId": "approval_1765551871719_ofkhf6viz",
  "approvalTitle": "GenericCommand System Requirements",
  "version": 1,
  "timestamp": "2025-12-12T15:04:31.750Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Document\r\n\r\n## Introduction\r\n\r\nThe GenericCommand system provides a flexible, runtime-extensible command queue architecture for the ProtogameJS3D dual-language game engine. This feature enables AI agents to dynamically create and submit new command types from JavaScript without requiring C++ recompilation, supporting the vision of autonomous multi-agent game development.\r\n\r\nThe current typed command system (CallbackQueue, ResourceCommandQueue, RenderCommandQueue, AudioCommandQueue) requires C++ code changes for each new command type, limiting AI agent autonomy. The GenericCommand system removes this bottleneck while maintaining the engine's performance and thread-safety guarantees.\r\n\r\nThis is a **two-phase migration**: Phase 1 introduces GenericCommand alongside existing typed commands; Phase 2 migrates existing systems to GenericCommand and removes typed command infrastructure if successful.\r\n\r\n## Alignment with Product Vision\r\n\r\nThis feature directly supports ProtogameJS3D's core vision as outlined in the project documentation:\r\n\r\n- **Dual-Language Architecture**: Strengthens JavaScript's role as the \"Agent API Surface\" by enabling runtime command extensibility\r\n- **AI-Driven Development**: Empowers AI agents to autonomously extend game functionality through custom commands\r\n- **Hot-Reload Support**: Aligns with existing hot-reload philosophy—no C++ recompilation for agent-driven features\r\n- **Multi-Agent Collaboration**: Provides shared command vocabulary for KĀDI protocol agent communication\r\n- **Research Project Goals**: Demonstrates cutting-edge runtime extensibility for game engine architectures\r\n\r\n## Requirements\r\n\r\n### Requirement 1: Generic Command Structure\r\n\r\n**User Story:** As an AI agent developer, I want to submit commands with dynamic payloads to the C++ engine, so that I can prototype new game mechanics without C++ code changes.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN an AI agent creates a command with type \"SpawnDynamicEntity\" and payload `{position: {x: 10, y: 0, z: 5}, prefabName: \"Enemy\"}` THEN the system SHALL store the command with V8 object payload intact\r\n2. WHEN the command queue capacity is reached THEN the system SHALL reject new submissions and return false\r\n3. WHEN a command is submitted with agentId \"calculator-agent\" THEN the system SHALL record the agentId for audit tracking\r\n4. IF the V8 isolate is locked by another thread THEN the system SHALL safely handle the lock contention without corruption\r\n5. WHEN a command's V8 object payload is accessed THEN the system SHALL use proper V8 handle scopes to prevent memory leaks\r\n\r\n### Requirement 2: Runtime Handler Registry\r\n\r\n**User Story:** As a game engine developer, I want to register command handlers at runtime, so that the engine can execute dynamically-defined command types.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN a handler is registered for command type \"UpdatePhysics\" THEN subsequent commands of that type SHALL invoke the registered handler\r\n2. WHEN a handler is unregistered for command type \"SpawnEntity\" THEN the system SHALL safely remove it without affecting other handlers\r\n3. IF multiple threads attempt to register handlers concurrently THEN the system SHALL serialize access with mutex protection\r\n4. WHEN a command type has no registered handler THEN the system SHALL log a warning with command type and agentId\r\n5. WHEN a handler throws an exception THEN the system SHALL catch it, log the error, and continue processing remaining commands\r\n\r\n### Requirement 3: JavaScript CommandQueue API\r\n\r\n**User Story:** As an AI agent writing JavaScript, I want a clean API to submit commands to C++, so that I can focus on game logic without understanding engine internals.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN calling `CommandQueue.submit(\"SpawnEntity\", {position: {x: 5, y: 0, z: 3}}, \"planner-agent\")` THEN the system SHALL enqueue the command to C++ GenericCommandQueue\r\n2. WHEN calling `CommandQueue.registerSchema(\"UpdateCamera\", {position: isVector3, rotation: isEulerAngles})` THEN the system SHALL validate subsequent commands against the schema\r\n3. IF a command payload fails schema validation THEN the system SHALL throw a descriptive JavaScript error without submitting to C++\r\n4. WHEN JavaScript queries `CommandQueue.getRegisteredTypes()` THEN the system SHALL return an array of all registered command types\r\n5. WHEN the C++ command queue is full THEN `CommandQueue.submit()` SHALL return false and log a backpressure warning\r\n\r\n### Requirement 4: Thread Safety with V8 Integration\r\n\r\n**User Story:** As an engine architect, I want GenericCommand to be thread-safe across worker threads and main thread, so that the async JavaScript architecture remains stable.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN JavaScript worker thread submits a command with V8 object payload THEN the system SHALL use v8::Persistent handles to extend object lifetime\r\n2. WHEN main thread executes a GenericCommand THEN the system SHALL acquire V8 isolate lock before accessing payload\r\n3. IF V8 garbage collection occurs during command execution THEN the system SHALL prevent payload object from being collected prematurely\r\n4. WHEN copying GenericCommand in the ring buffer THEN the system SHALL properly copy v8::Persistent handles without reference corruption\r\n5. WHEN GenericCommandQueue is destroyed THEN the system SHALL properly dispose of all V8 persistent handles to prevent memory leaks\r\n\r\n### Requirement 5: Safety Measures and Monitoring\r\n\r\n**User Story:** As a game developer, I want the system to prevent AI agent abuse and provide debugging tools, so that malicious or buggy agents cannot crash the engine.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN an agent submits more than 100 commands per second THEN the system SHALL enforce rate limiting and reject excess commands\r\n2. WHEN a command is submitted THEN the system SHALL log it to an audit trail with timestamp, agentId, command type, and success/failure status\r\n3. IF an agent submits 10 consecutive invalid commands THEN the system SHALL log a warning about potential agent malfunction\r\n4. WHEN querying `GenericCommandQueue.GetStatistics()` THEN the system SHALL return total submitted, executed, failed, and dropped command counts per agent\r\n5. WHEN the dashboard is opened THEN it SHALL display real-time command submission rates, queue depth, and top command types\r\n\r\n### Requirement 6: Performance Characteristics\r\n\r\n**User Story:** As an engine performance engineer, I want GenericCommand to maintain acceptable latency, so that AI agent commands do not degrade frame rate.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN submitting a GenericCommand THEN the submission latency SHALL be less than 10 microseconds (excluding V8 overhead)\r\n2. WHEN executing 100 GenericCommands per frame THEN the frame time overhead SHALL be less than 1 millisecond\r\n3. IF the command queue reaches 80% capacity THEN the system SHALL log a performance warning\r\n4. WHEN V8 object payload size exceeds 1 KB THEN the system SHALL log a warning about potential performance impact\r\n5. WHEN GenericCommand execution is profiled THEN handler lookup latency SHALL be less than 0.1 microseconds per command\r\n\r\n### Requirement 7: Migration Path from Typed Commands\r\n\r\n**User Story:** As an engine maintainer, I want a clear migration strategy from typed to generic commands, so that existing systems transition smoothly without breaking changes.\r\n\r\n#### Acceptance Criteria\r\n\r\n1. WHEN Phase 1 is complete THEN both typed commands (EntityAPI, CameraAPI) and GenericCommand SHALL coexist without conflicts\r\n2. WHEN an existing typed command is migrated to GenericCommand THEN the JavaScript API SHALL remain backward compatible\r\n3. IF GenericCommand proves unstable THEN the system SHALL allow rollback to typed commands without code loss\r\n4. WHEN Phase 2 migration is complete THEN all typed command queues SHALL be removed and GenericCommand SHALL handle all operations\r\n5. WHEN typed commands are removed THEN the system SHALL maintain or improve performance compared to typed command baseline\r\n\r\n## Non-Functional Requirements\r\n\r\n### Code Architecture and Modularity\r\n\r\n- **Single Responsibility Principle**: GenericCommandQueue handles command queueing only; handler registry and execution are separate concerns\r\n- **Modular Design**:\r\n  - `GenericCommand.hpp` - Command structure definition\r\n  - `GenericCommandQueue.hpp` - Queue implementation using CommandQueueBase template\r\n  - `GenericCommandExecutor.hpp` - Handler registry and execution logic\r\n  - `GenericCommandScriptInterface.hpp` - JavaScript V8 bindings\r\n  - `CommandQueue.js` - JavaScript API facade\r\n- **Dependency Management**:\r\n  - GenericCommand depends on V8 API only\r\n  - GenericCommandQueue inherits from CommandQueueBase (reuses existing SPSC lock-free implementation)\r\n  - GenericCommandExecutor has no dependencies on specific game systems\r\n- **Clear Interfaces**:\r\n  - C++ handler registry uses `std::function<void(v8::Local<v8::Object>)>` for handler signatures\r\n  - JavaScript API uses promises for async command submission\r\n  - V8 integration uses standard v8::Persistent and v8::Local handle patterns\r\n\r\n### Performance\r\n\r\n- **Submission Latency**: < 10µs per command (excluding V8 object copy overhead)\r\n- **Execution Throughput**: 1000+ commands per frame without frame rate impact (target: 60 FPS)\r\n- **Memory Overhead**:\r\n  - GenericCommand size: ~320 bytes (v8::Persistent + metadata)\r\n  - Queue capacity: 500 commands (160 KB total memory)\r\n  - Handler registry: O(1) hash map lookup\r\n- **V8 Integration**: Minimize isolate lock contention through batched command execution\r\n\r\n### Security\r\n\r\n- **Rate Limiting**: 100 commands/second per agent (configurable)\r\n- **Input Validation**: JavaScript-side schema validation before C++ submission\r\n- **Audit Trail**: All commands logged with agentId, timestamp, type, and execution result\r\n- **Sandboxing**: Handlers execute in isolated try-catch blocks; failures do not propagate\r\n- **Memory Safety**: V8 handles properly disposed; no dangling references to JavaScript objects\r\n\r\n### Reliability\r\n\r\n- **Error Isolation**: Handler exceptions logged but do not crash engine or affect other commands\r\n- **Backpressure Handling**: Queue full conditions logged and returned to JavaScript as failure\r\n- **Thread Safety**: Mutex-protected handler registry; lock-free command queue (SPSC)\r\n- **Graceful Degradation**: Unknown command types logged as warnings; system continues processing\r\n- **Memory Leak Prevention**: V8 persistent handles tracked and disposed on queue destruction\r\n\r\n### Usability\r\n\r\n- **JavaScript API Simplicity**: Single-function submission: `CommandQueue.submit(type, payload, agentId)`\r\n- **Schema Validation**: Optional client-side validation with clear error messages\r\n- **Debugging Support**:\r\n  - Chrome DevTools integration for JavaScript command inspection\r\n  - Audit log export for command history analysis\r\n  - Dashboard visualization of command flow and statistics\r\n- **Documentation**:\r\n  - JSDoc comments for all JavaScript APIs\r\n  - C++ Doxygen comments for engine integration\r\n  - Migration guide from typed to generic commands\r\n- **Hot-Reload Compatibility**: Command handlers can be re-registered after JavaScript file reload\r\n",
  "fileStats": {
    "size": 11274,
    "lines": 166,
    "lastModified": "2025-12-12T15:04:21.871Z"
  },
  "comments": []
}