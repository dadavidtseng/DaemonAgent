{
  "id": "snapshot_1768747584806_w2gilsvyy",
  "approvalId": "approval_1768747366524_yh9kevnse",
  "approvalTitle": "Revised Requirements Document for GenericCommand System",
  "version": 3,
  "timestamp": "2026-01-18T14:46:24.806Z",
  "trigger": "revision_requested",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nThe GenericCommand system provides a flexible, runtime-extensible command queue architecture for the DaemonAgent dual-language game engine. This feature enables AI agents to dynamically create and submit new command types from JavaScript without requiring C++ recompilation, supporting the vision of autonomous multi-agent game development.\n\nThe current typed command system (CallbackQueue, ResourceCommandQueue, RenderCommandQueue, AudioCommandQueue) requires C++ code changes for each new command type, limiting AI agent autonomy. The GenericCommand system removes this bottleneck while maintaining the engine's performance and thread-safety guarantees.\n\nThis is a **two-phase migration**: Phase 1 introduces GenericCommand alongside existing typed commands; Phase 2 migrates existing systems to GenericCommand and removes typed command infrastructure if successful.\n\n## How the Generic Command System Works\n\n### High-Level Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                     JavaScript Thread (AI Agent)                 │\n│  ┌────────────────────────────────────────────────────────────┐ │\n│  │ CommandQueue.submit(\"SpawnEntity\", {pos: {x: 5}}, \"agent\") │ │\n│  └──────────────────────┬─────────────────────────────────────┘ │\n└─────────────────────────┼───────────────────────────────────────┘\n                          │ (1) Submit with V8 object payload\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│                GenericCommandQueue (Lock-Free SPSC)              │\n│  ┌────────────────────────────────────────────────────────────┐ │\n│  │ GenericCommand {                                           │ │\n│  │   type: \"SpawnEntity\"                                      │ │\n│  │   payload: v8::Persistent<v8::Object> (ref to JS object)  │ │\n│  │   agentId: \"agent\"                                         │ │\n│  │   timestamp: 1234567890                                    │ │\n│  │ }                                                          │ │\n│  └────────────────────────────────────────────────────────────┘ │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │ (2) ConsumeAll() in C++ main thread\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│              GenericCommandExecutor (Handler Registry)           │\n│  ┌────────────────────────────────────────────────────────────┐ │\n│  │ std::unordered_map<string, HandlerFunc>                   │ │\n│  │   \"SpawnEntity\"    → [](v8::Local<v8::Object> payload) { │ │\n│  │                         auto pos = payload->Get(\"pos\");   │ │\n│  │                         CreateEntity(pos);                │ │\n│  │                       }                                   │ │\n│  │   \"UpdatePhysics\"  → [](payload) { ... }                 │ │\n│  └────────────────────────────────────────────────────────────┘ │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │ (3) Execute handler with payload\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│                    C++ Game Systems (Engine)                     │\n│  EntitySystem, PhysicsSystem, AudioSystem, etc.                 │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n### Execution Flow\n\n**Step 1: JavaScript Submission**\n```javascript\n// AI agent submits command from JavaScript\nCommandQueue.submit(\n  \"SpawnEntity\",                    // Command type (string)\n  { position: { x: 5, y: 0, z: 3 }, // Payload (JavaScript object)\n    prefabName: \"Enemy\" },\n  \"planner-agent\"                   // Agent ID for tracking\n);\n```\n\n**Step 2: C++ Queue Storage**\n```cpp\n// GenericCommand stored in lock-free ring buffer\nstruct GenericCommand {\n  String type;                       // \"SpawnEntity\"\n  v8::Persistent<v8::Object> payload; // Persistent handle to JS object\n  String agentId;                    // \"planner-agent\"\n  uint64_t timestamp;                // 1234567890\n};\n// V8 Persistent handle keeps JS object alive until command executes\n```\n\n**Step 3: C++ Handler Execution**\n```cpp\n// Main thread processes commands (App::Update)\ncommandQueue->ConsumeAll([&](GenericCommand const& cmd) {\n  auto handler = handlerRegistry.GetHandler(cmd.type);\n  if (handler) {\n    v8::Local<v8::Object> payload = cmd.payload.Get(isolate);\n    handler(payload);  // Execute registered C++ handler\n  }\n});\n```\n\n### Key Benefits\n\n1. **Runtime Extensibility**: New command types added from JavaScript without C++ recompilation\n2. **AI Agent Autonomy**: Agents define custom commands for new game mechanics on-the-fly\n3. **Thread-Safe**: Lock-free SPSC queue + V8 Persistent handles prevent race conditions\n4. **Type Flexibility**: V8 object payloads support arbitrary JSON-like structures\n5. **Performance**: Less than 10µs submission latency, 1000+ commands/frame throughput\n\n### Comparison: Typed vs Generic Commands\n\n| Aspect | Typed Commands (Current) | GenericCommand (New) |\n|--------|-------------------------|----------------------|\n| **Adding New Command** | Edit C++ enum + struct + recompile | JavaScript: `CommandQueue.submit(\"NewType\", {...})` |\n| **Handler Registration** | Hardcoded in C++ switch statement | Runtime: `RegisterHandler(\"NewType\", handler)` |\n| **Payload Type** | Fixed C++ struct per command | Flexible V8 object (JSON-like) |\n| **AI Agent Autonomy** | ❌ Requires C++ developer | ✅ Fully autonomous |\n| **Hot-Reload Support** | ❌ C++ recompilation breaks | ✅ Handlers re-register on reload |\n\n### Example Use Case: AI Agent Creating Custom Command\n\n```javascript\n// AI Planner Agent: \"I need a command to spawn waves of enemies\"\n// WITHOUT GenericCommand: Ask human to write C++, wait hours/days\n// WITH GenericCommand: Define and use immediately\n\n// Step 1: Register handler (in C++ or via script binding)\nCommandQueue.registerHandler(\"SpawnWave\", (payload) => {\n  const { count, enemyType, formation } = payload;\n  for (let i = 0; i < count; i++) {\n    const pos = CalculateFormationPos(i, formation);\n    EntityAPI.createEntity(enemyType, pos);\n  }\n});\n\n// Step 2: AI agent immediately uses new command\nCommandQueue.submit(\"SpawnWave\", {\n  count: 10,\n  enemyType: \"Zombie\",\n  formation: \"Circle\"\n}, \"planner-agent\");\n```\n\n### Handler Implementation: C++ vs JavaScript\n\nThe GenericCommand system supports **two handler implementation approaches**, each with different trade-offs:\n\n#### Approach A: Static C++ Handlers (Performance-Critical)\n\n**When to use**: Performance-critical operations, low-level engine systems\n\n```cpp\n// In App::Initialize() or GameSubsystem.cpp (C++ side)\nvoid InitializeGenericCommandHandlers() {\n    // Register C++ lambda as handler (compiled, not hot-reloadable)\n    GenericCommandExecutor::RegisterHandler(\"SpawnEntity\",\n        [](v8::Local<v8::Object> payload, v8::Isolate* isolate) {\n            // Direct C++ implementation - maximum performance\n            auto pos = V8Helper::GetVector3(payload, \"position\", isolate);\n            auto prefab = V8Helper::GetString(payload, \"prefabName\", isolate);\n\n            // Call C++ subsystems directly (no ScriptInterface overhead)\n            EntityID id = EntitySystem::CreateEntity(prefab, pos);\n            PhysicsSystem::AddRigidBody(id);\n        }\n    );\n}\n```\n\n**Characteristics**:\n- ✅ **Performance**: Direct C++ execution, no JavaScript overhead\n- ✅ **Type Safety**: C++ compile-time type checking\n- ❌ **Not Hot-Reloadable**: Requires C++ recompilation\n- ❌ **No AI Agent Autonomy**: Needs C++ developer\n\n---\n\n#### Approach B: Dynamic JavaScript Handlers (AI Agent Autonomy)\n\n**When to use**: AI-generated commands, rapid prototyping, game logic\n\n```javascript\n// In JSGame.js (JavaScript side) - fully hot-reloadable!\nclass CustomCommandHandlers {\n    static initialize() {\n        // Register JavaScript function as handler (runtime, hot-reloadable)\n        CommandQueue.registerHandler(\"SpawnEntity\", (payload) => {\n            // JavaScript implementation - calls existing ScriptInterfaces\n            const { position, prefabName } = payload;\n\n            // Use existing C++/JS bridges (EntityScriptInterface, etc.)\n            const entityId = EntityAPI.createEntity(prefabName, position);\n            PhysicsAPI.addRigidBody(entityId);\n\n            // AI agents can add custom logic here\n            console.log(`AI spawned entity: ${prefabName} at`, position);\n        });\n\n        // AI agents can register new handlers at runtime\n        CommandQueue.registerHandler(\"CustomAICommand\", (payload) => {\n            // Fully autonomous AI-defined behavior\n            // ...\n        });\n    }\n}\n```\n\n**Characteristics**:\n- ✅ **Hot-Reloadable**: Changes apply without C++ recompilation\n- ✅ **AI Agent Autonomy**: Agents define handlers at runtime\n- ✅ **Rapid Prototyping**: Iterate on game logic in seconds\n- ❌ **Slower**: JavaScript → C++ call overhead per subsystem call\n\n---\n\n#### JavaScript Handler Execution Flow\n\nWhen GenericCommandExecutor encounters a JavaScript handler registered via `CommandQueue.registerHandler()`:\n\n1. **Handler Lookup**: Executor retrieves the JavaScript function reference from the handler registry\n2. **V8 Context Entry**: Executor acquires V8 isolate lock and enters the JavaScript context\n3. **Function Invocation**: Executor calls `v8::Function::Call()` with the command payload as argument\n4. **JavaScript Execution**: Handler function executes in V8 runtime\n5. **ScriptInterface Calls**: Handler calls existing ScriptInterface APIs (EntityAPI, CameraAPI, etc.)\n6. **C++ Subsystem Invocation**: ScriptInterfaces marshal calls back to C++ subsystems\n7. **Return to C++**: Executor releases V8 context and continues processing next command\n\n```\nJavaScript Handler Registration:\n┌─────────────────────────────────────────────────────────────┐\n│ CommandQueue.registerHandler(\"MyCommand\", handlerFunc)      │\n└────────────────────┬────────────────────────────────────────┘\n                     │ (Stores v8::Persistent<v8::Function>)\n                     ▼\n┌─────────────────────────────────────────────────────────────┐\n│ GenericCommandExecutor::m_jsHandlers[\"MyCommand\"]           │\n│   = v8::Persistent<v8::Function>(handlerFunc)               │\n└─────────────────────────────────────────────────────────────┘\n\nCommand Execution:\n┌─────────────────────────────────────────────────────────────┐\n│ GenericCommandExecutor::ExecuteCommand(cmd)                 │\n│   ├─ auto jsHandler = m_jsHandlers[cmd.type]                │\n│   ├─ v8::HandleScope scope(isolate)                         │\n│   ├─ v8::Local<v8::Function> func = jsHandler.Get(isolate)  │\n│   ├─ func->Call(context, payload)  ← Invokes JS handler     │\n│   └─ (Handler calls EntityAPI, CameraAPI, etc.)             │\n└─────────────────────────────────────────────────────────────┘\n```\n\n**Thread Safety Note**: JavaScript handler invocation always occurs on the main thread during `App::Update()`, ensuring V8 isolate is accessed from a single thread.\n\n---\n\n### C++/JavaScript Connection Architecture\n\n**Question**: Is ScriptInterface the only connection between C++ and JavaScript?\n\n**Answer**: **No** - there are **multiple connection layers** that work together:\n\n```\n┌───────────────────────────────────────────────────────────────┐\n│                    JavaScript Layer (Hot-Reloadable)           │\n│  ┌─────────────────────────────────────────────────────────┐  │\n│  │ // AI agent submits command                             │  │\n│  │ CommandQueue.submit(\"SpawnEntity\", {...}, \"agent-id\")   │  │\n│  │                                                          │  │\n│  │ // AI agent registers handler                           │  │\n│  │ CommandQueue.registerHandler(\"SpawnEntity\", (payload) => {│ │\n│  │   EntityAPI.createEntity(...);  // ← Calls existing API │  │\n│  │ });                                                      │  │\n│  └───────────────────┬─────────────────────────────────────┘  │\n└──────────────────────┼────────────────────────────────────────┘\n                       │ (1) V8 C++ Bindings\n                       ▼\n┌───────────────────────────────────────────────────────────────┐\n│        Layer 1: GenericCommandScriptInterface (C++)            │\n│  • Exposes CommandQueue.submit() to JavaScript                │\n│  • Exposes CommandQueue.registerHandler() to JavaScript       │\n│  • Converts V8::Object → GenericCommand struct                │\n└───────────────────┬───────────────────────────────────────────┘\n                    │ (2) Submits to queue\n                    ▼\n┌───────────────────────────────────────────────────────────────┐\n│           GenericCommandQueue (Lock-Free SPSC)                 │\n│  Ring buffer with V8::Persistent<V8::Object> payloads         │\n└───────────────────┬───────────────────────────────────────────┘\n                    │ (3) ConsumeAll in main thread\n                    ▼\n┌───────────────────────────────────────────────────────────────┐\n│              GenericCommandExecutor (C++)                      │\n│  • Handler registry (maps command type → handler function)    │\n│  • Executes registered handler (C++ or JavaScript)            │\n└───────────────────┬───────────────────────────────────────────┘\n                    │ (4) Handler execution\n                    ├─────────────────┬─────────────────────────┐\n                    ▼ (C++ Handler)   ▼ (JavaScript Handler)    │\n          ┌──────────────────┐  ┌─────────────────────────────┐│\n          │ C++ Subsystems   │  │ JavaScript Handler Calls    ││\n          │ (Direct)         │  │ Existing ScriptInterfaces   ││\n          │                  │  │                             ││\n          │ EntitySystem::   │  │ Layer 2: Existing APIs      ││\n          │ CreateEntity()   │  │ ┌─────────────────────────┐ ││\n          └──────────────────┘  │ │ EntityScriptInterface   │ ││\n                                │ │ CameraScriptInterface   │ ││\n                                │ │ AudioScriptInterface    │ ││\n                                │ │ PhysicsScriptInterface  │ ││\n                                │ └───────┬─────────────────┘ ││\n                                └─────────┼───────────────────┘│\n                                          ▼                     │\n                                ┌───────────────────────────┐  │\n                                │ C++ Game Subsystems       │  │\n                                │ • EntitySystem            │  │\n                                │ • PhysicsSystem           │  │\n                                │ • AudioSystem             │  │\n                                └───────────────────────────┘  │\n                                                                │\n                                                                │\n```\n\n### Connection Layers Summary\n\n| Layer | Component | Purpose | Hot-Reloadable? | Used By |\n|-------|-----------|---------|-----------------|---------|\n| **Layer 1** | GenericCommandScriptInterface | Exposes `CommandQueue.submit()` and `registerHandler()` | ❌ C++ recompile | JavaScript command submission |\n| **Layer 2** | EntityScriptInterface | Exposes entity operations (`createEntity`, `destroyEntity`) | ❌ C++ recompile | JavaScript handlers |\n| **Layer 2** | CameraScriptInterface | Exposes camera operations (`setPosition`, `lookAt`) | ❌ C++ recompile | JavaScript handlers |\n| **Layer 2** | AudioScriptInterface | Exposes audio operations (`playSound`, `stopSound`) | ❌ C++ recompile | JavaScript handlers |\n| **Layer 3** | JavaScript Handlers | Custom command handlers defined in JavaScript | ✅ Hot-reload | AI agents, game logic |\n\n### Key Architectural Insight\n\n**GenericCommand does NOT replace existing ScriptInterfaces** - it **builds on top of them**:\n\n```javascript\n// JavaScript handler leverages existing C++/JS bridges\nCommandQueue.registerHandler(\"ComplexGameplay\", (payload) => {\n    // Handler can call ANY existing ScriptInterface API\n    EntityAPI.createEntity(payload.entity);      // EntityScriptInterface\n    CameraAPI.setPosition(payload.cameraPos);    // CameraScriptInterface\n    AudioAPI.playSound(payload.soundEffect);     // AudioScriptInterface\n    PhysicsAPI.setGravity(payload.gravity);      // PhysicsScriptInterface\n\n    // This is the power: compose existing APIs into new commands\n});\n```\n\n**ScriptInterfaces are the building blocks that JavaScript handlers compose into custom commands.**\n\n---\n\n### Recommended Pattern: Hybrid Approach\n\n**Best Practice**: Use C++ handlers for engine-critical operations, JavaScript handlers for gameplay:\n\n```cpp\n// C++ handlers (performance-critical engine operations)\nGenericCommandExecutor::RegisterHandler(\"UpdatePhysics\", CppUpdatePhysicsHandler);\nGenericCommandExecutor::RegisterHandler(\"RenderDebugPrimitive\", CppRenderDebugHandler);\n```\n\n```javascript\n// JavaScript handlers (gameplay, AI-driven features)\nCommandQueue.registerHandler(\"SpawnWave\", JsSpawnWaveHandler);\nCommandQueue.registerHandler(\"TriggerCutscene\", JsTriggerCutsceneHandler);\nCommandQueue.registerHandler(\"CustomAIBehavior\", JsCustomAIHandler);  // AI-generated\n```\n\n### Schema Validation Architecture\n\nThe system provides **optional schema validation** for command payloads to catch errors early:\n\n#### Schema Definition\n\nSchemas are defined using a declarative validation API in JavaScript:\n\n```javascript\n// Define schema for a command type\nCommandQueue.registerSchema(\"SpawnEntity\", {\n    position: {\n        type: \"object\",\n        required: true,\n        properties: {\n            x: { type: \"number\", required: true },\n            y: { type: \"number\", required: true },\n            z: { type: \"number\", required: true }\n        }\n    },\n    prefabName: { type: \"string\", required: true },\n    health: { type: \"number\", required: false, default: 100 }\n});\n```\n\n#### Validation Flow\n\n```\nJavaScript Submission:\n┌─────────────────────────────────────────────────────────────┐\n│ CommandQueue.submit(\"SpawnEntity\", payload, agentId)        │\n└────────────────────┬────────────────────────────────────────┘\n                     │\n                     ▼\n┌─────────────────────────────────────────────────────────────┐\n│ SchemaValidator.validate(payload, schema)                   │\n│   ├─ Check required fields present                          │\n│   ├─ Check field types match                                │\n│   ├─ Apply default values for missing optional fields       │\n│   └─ Return validation result                               │\n└────────────────────┬────────────────────────────────────────┘\n                     │\n       ┌─────────────┴─────────────┐\n       │ Valid                     │ Invalid\n       ▼                           ▼\n┌──────────────────┐      ┌───────────────────────────────┐\n│ Enqueue to C++   │      │ Throw JavaScript TypeError    │\n│                  │      │ \"Invalid payload for command  │\n│                  │      │  SpawnEntity: missing field   │\n│                  │      │  'position.x'\"                │\n└──────────────────┘      └───────────────────────────────┘\n```\n\n#### Performance Impact\n\n- **Validation Cost**: ~5-10µs per command (negligible for typical payloads)\n- **Optimization**: Schemas compiled to fast validation functions at registration time\n- **Bypass Option**: Validation can be disabled globally via `CommandQueue.setValidationEnabled(false)` for performance-critical scenarios\n\n---\n\n## Alignment with Product Vision\n\nThis feature directly supports DaemonAgent's core vision as outlined in the project documentation:\n\n- **Dual-Language Architecture**: Strengthens JavaScript's role as the \"Agent API Surface\" by enabling runtime command extensibility\n- **AI-Driven Development**: Empowers AI agents to autonomously extend game functionality through custom commands\n- **Hot-Reload Support**: Aligns with existing hot-reload philosophy—no C++ recompilation for agent-driven features\n- **Multi-Agent Collaboration**: Provides shared command vocabulary for KĀDI protocol agent communication\n- **Research Project Goals**: Demonstrates cutting-edge runtime extensibility for game engine architectures\n\n## Requirements\n\n### Requirement 1: Generic Command Structure\n\n**User Story:** As an AI agent developer, I want to submit commands with dynamic payloads to the C++ engine, so that I can prototype new game mechanics without C++ code changes.\n\n#### Acceptance Criteria\n\n1. WHEN an AI agent creates a command with type \"SpawnDynamicEntity\" and payload `{position: {x: 10, y: 0, z: 5}, prefabName: \"Enemy\"}` THEN the system SHALL store the command with V8 object payload intact\n2. WHEN the command queue capacity is reached THEN the system SHALL reject new submissions and return false\n3. WHEN a command is submitted with agentId \"calculator-agent\" THEN the system SHALL record the agentId for audit tracking\n4. IF the V8 isolate is locked by another thread THEN the system SHALL safely handle the lock contention without corruption\n5. WHEN a command's V8 object payload is accessed THEN the system SHALL use proper V8 handle scopes to prevent memory leaks\n6. WHEN JavaScript modifies a payload object after submission THEN the system SHALL use the object state at submission time (deep copy or immutable snapshot prevents post-submission mutations)\n7. WHEN a payload contains circular references THEN the system SHALL detect and reject the command with error code ERR_CIRCULAR_REFERENCE\n\n### Requirement 2: Runtime Handler Registry\n\n**User Story:** As a game engine developer, I want to register command handlers at runtime, so that the engine can execute dynamically-defined command types.\n\n#### Acceptance Criteria\n\n1. WHEN a handler is registered for command type \"UpdatePhysics\" THEN subsequent commands of that type SHALL invoke the registered handler\n2. WHEN a handler is unregistered for command type \"SpawnEntity\" THEN the system SHALL safely remove it without affecting other handlers\n3. IF multiple threads attempt to register handlers concurrently THEN the system SHALL serialize access with mutex protection\n4. WHEN a command type has no registered handler THEN the system SHALL log a warning with command type and agentId\n5. WHEN a handler throws an exception THEN the system SHALL catch it, log the error, and continue processing remaining commands\n\n### Requirement 3: JavaScript CommandQueue API\n\n**User Story:** As an AI agent writing JavaScript, I want a clean API to submit commands to C++, so that I can focus on game logic without understanding engine internals.\n\n#### Acceptance Criteria\n\n1. WHEN calling `CommandQueue.submit(\"SpawnEntity\", {position: {x: 5, y: 0, z: 3}}, \"planner-agent\")` THEN the system SHALL enqueue the command to C++ GenericCommandQueue\n2. WHEN calling `CommandQueue.registerSchema(\"UpdateCamera\", {position: isVector3, rotation: isEulerAngles})` THEN the system SHALL validate subsequent commands against the schema\n3. IF a command payload fails schema validation THEN the system SHALL throw a descriptive JavaScript error without submitting to C++\n4. WHEN JavaScript queries `CommandQueue.getRegisteredTypes()` THEN the system SHALL return an array of all registered command types\n5. WHEN the C++ command queue is full THEN `CommandQueue.submit()` SHALL return false and log a backpressure warning\n6. WHEN calling `CommandQueue.registerHandler(\"SpawnWave\", handlerFunction)` THEN the system SHALL register the JavaScript function as a command handler\n7. WHEN JavaScript calls `CommandQueue.unregisterHandler(\"SpawnWave\")` THEN the system SHALL remove the handler and log warnings for subsequent commands of that type\n8. WHEN JavaScript files are hot-reloaded THEN the system SHALL allow handler re-registration for all command types\n9. WHEN a handler is re-registered during hot-reload THEN the system SHALL replace the old handler atomically without affecting in-flight commands\n\n### Requirement 4: Thread Safety with V8 Integration\n\n**User Story:** As an engine architect, I want GenericCommand to be thread-safe across worker threads and main thread, so that the async JavaScript architecture remains stable.\n\n#### Acceptance Criteria\n\n1. WHEN JavaScript worker thread submits a command with V8 object payload THEN the system SHALL use v8::Persistent handles to extend object lifetime\n2. WHEN main thread executes a GenericCommand THEN the system SHALL acquire V8 isolate lock before accessing payload\n3. IF V8 garbage collection occurs during command execution THEN the system SHALL prevent payload object from being collected prematurely\n4. WHEN copying GenericCommand in the ring buffer THEN the system SHALL properly copy v8::Persistent handles without reference corruption\n5. WHEN GenericCommandQueue is destroyed THEN the system SHALL properly dispose of all V8 persistent handles to prevent memory leaks\n\n### Requirement 5: Safety Measures and Monitoring\n\n**User Story:** As a game developer, I want the system to prevent AI agent abuse and provide debugging tools, so that malicious or buggy agents cannot crash the engine.\n\n#### Acceptance Criteria\n\n1. WHEN an agent submits more than 100 commands per second (measured via sliding 1-second window) THEN the system SHALL reject excess commands with error code ERR_RATE_LIMITED and log the rejection\n2. WHEN a command is submitted THEN the system SHALL log it to an audit trail with timestamp, agentId, command type, and success/failure status\n3. IF an agent submits 10 consecutive invalid commands THEN the system SHALL log a warning about potential agent malfunction\n4. WHEN querying `GenericCommandQueue.GetStatistics()` THEN the system SHALL return total submitted, executed, failed, and dropped command counts per agent\n5. WHEN the spec-workflow dashboard is opened THEN it SHALL display real-time command submission rates, queue depth, and top command types via WebSocket integration\n\n### Requirement 6: Performance Characteristics\n\n**User Story:** As an engine performance engineer, I want GenericCommand to maintain acceptable latency, so that AI agent commands do not degrade frame rate.\n\n#### Acceptance Criteria\n\n1. WHEN submitting a GenericCommand THEN the submission latency SHALL be less than 10 microseconds (excluding V8 overhead)\n2. WHEN executing 100 GenericCommands per frame THEN the frame time overhead SHALL be less than 1 millisecond\n3. IF the command queue reaches 80% capacity THEN the system SHALL log a performance warning\n4. WHEN V8 object payload size exceeds 1 KB THEN the system SHALL log a warning about potential performance impact\n5. WHEN GenericCommand execution is profiled THEN handler lookup latency SHALL be less than 0.1 microseconds per command\n\n### Requirement 7: Migration Path from Typed Commands\n\n**User Story:** As an engine maintainer, I want a clear migration strategy from typed to generic commands, so that existing systems transition smoothly without breaking changes.\n\n#### Acceptance Criteria\n\n1. WHEN Phase 1 is complete THEN both typed commands (EntityAPI, CameraAPI) and GenericCommand SHALL coexist without conflicts\n2. WHEN an existing typed command is migrated to GenericCommand THEN the JavaScript API SHALL remain backward compatible\n3. IF GenericCommand proves unstable THEN the system SHALL allow rollback to typed commands without code loss\n4. WHEN Phase 2 migration is complete THEN all typed command queues SHALL be removed and GenericCommand SHALL handle all operations\n5. WHEN typed commands are removed THEN the system SHALL maintain or improve performance compared to typed command baseline\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **Single Responsibility Principle**: GenericCommandQueue handles command queueing only; handler registry and execution are separate concerns\n- **Modular Design**:\n  - `GenericCommand.hpp` - Command structure definition\n  - `GenericCommandQueue.hpp` - Queue implementation using CommandQueueBase template\n  - `GenericCommandExecutor.hpp` - Handler registry and execution logic\n  - `GenericCommandScriptInterface.hpp` - JavaScript V8 bindings\n  - `CommandQueue.js` - JavaScript API facade\n- **Dependency Management**:\n  - GenericCommand depends on V8 API only\n  - GenericCommandQueue inherits from CommandQueueBase (reuses existing SPSC lock-free implementation)\n  - GenericCommandExecutor has no dependencies on specific game systems\n- **Clear Interfaces**:\n  - C++ handler registry uses `std::function<void(v8::Local<v8::Object>)>` for handler signatures\n  - JavaScript API uses promises for async command submission\n  - V8 integration uses standard v8::Persistent and v8::Local handle patterns\n\n### Performance\n\n- **Submission Latency**: < 10µs per command (excluding V8 object copy overhead)\n- **Execution Throughput**: 1000+ commands per frame without frame rate impact (target: 60 FPS)\n- **Memory Overhead**:\n  - GenericCommand size: ~320 bytes (v8::Persistent + metadata)\n  - Queue capacity: 500 commands (160 KB total memory)\n  - Handler registry: O(1) hash map lookup\n- **V8 Integration**: Minimize isolate lock contention through batched command execution\n\n### Security\n\n- **Rate Limiting**: 100 commands/second per agent (sliding 1-second window, configurable via GameConfig.xml)\n- **Input Validation**: JavaScript-side schema validation before C++ submission\n- **Audit Trail**: All commands logged with agentId, timestamp, type, and execution result to `.spec-workflow/command-audit-log.json`\n- **Sandboxing**: Handlers execute in isolated try-catch blocks; failures do not propagate\n- **Memory Safety**: V8 handles properly disposed; no dangling references to JavaScript objects\n\n### Reliability\n\n- **Error Isolation**: Handler exceptions logged but do not crash engine or affect other commands\n- **Backpressure Handling**: Queue full conditions logged and returned to JavaScript as failure\n- **Thread Safety**: Mutex-protected handler registry; lock-free command queue (SPSC)\n- **Graceful Degradation**: Unknown command types logged as warnings; system continues processing\n- **Memory Leak Prevention**: V8 persistent handles tracked and disposed on queue destruction\n\n### Usability\n\n- **JavaScript API Simplicity**: Single-function submission: `CommandQueue.submit(type, payload, agentId)`\n- **Schema Validation**: Optional client-side validation with clear error messages\n- **Debugging Support**:\n  - Chrome DevTools integration for JavaScript command inspection\n  - Audit log export for command history analysis\n  - Dashboard visualization of command flow and statistics (integrated with existing spec-workflow dashboard at `http://localhost:5000`)\n- **Documentation**:\n  - JSDoc comments for all JavaScript APIs\n  - C++ Doxygen comments for engine integration\n  - Migration guide from typed to generic commands\n- **Hot-Reload Compatibility**: Command handlers can be re-registered after JavaScript file reload without losing state\n\n### Dashboard Integration\n\nThe GenericCommand monitoring features integrate with the existing **spec-workflow dashboard** (http://localhost:5000):\n\n- **Real-time Statistics**: WebSocket notifications push command queue metrics to dashboard\n- **Command History**: Stored in `.spec-workflow/command-audit-log.json` for retrospective analysis\n- **Visualization Components**:\n  - Command submission rate graph (commands/second per agent)\n  - Queue depth gauge (current utilization percentage)\n  - Top command types bar chart (most frequently used commands)\n  - Agent activity heatmap (which agents are most active)\n- **Integration Points**:\n  - Reuses existing WebSocket infrastructure from spec-workflow MCP server\n  - Command audit log follows same JSON format as implementation logs\n  - Dashboard UI extends existing React components for consistency\n",
  "fileStats": {
    "size": 37503,
    "lines": 598,
    "lastModified": "2026-01-18T14:42:32.780Z"
  },
  "comments": []
}