{
  "id": "snapshot_1768862083681_ng1lufmyb",
  "approvalId": "approval_1768750476635_c5k12yjsg",
  "approvalTitle": "Design Document for GenericCommand System",
  "version": 2,
  "timestamp": "2026-01-19T22:34:43.681Z",
  "trigger": "revision_requested",
  "status": "pending",
  "content": "# Design Document: GenericCommand System\r\n\r\n## Overview\r\n\r\nThe GenericCommand system provides a runtime-extensible command queue architecture for the DaemonAgent game engine, enabling AI agents to dynamically create and submit custom command types from JavaScript without C++ recompilation. The system builds upon the proven CommandQueueBase template pattern used by RenderCommandQueue and CallbackQueue, while adding flexible V8 object payloads and optional async callbacks following the EntityAPI/CameraAPI pattern.\r\n\r\n**Core Innovation**: Unlike typed command systems (EntityAPI, CameraAPI) that require C++ code changes for new commands, GenericCommand allows JavaScript handlers to compose existing APIs into custom workflows dynamically.\r\n\r\n## Steering Document Alignment\r\n\r\n### Technical Standards (tech.md)\r\n\r\n**C++20 Standards Compliance**:\r\n- Template-based design following CommandQueueBase pattern\r\n- RAII resource management for V8 handles (v8::Persistent disposal)\r\n- Modern C++ idioms (std::function, std::unordered_map, move semantics)\r\n- Lock-free atomic operations (SPSC queue pattern)\r\n\r\n**Architecture Patterns**:\r\n- SOLID principles: Single Responsibility (queue vs executor separation), Dependency Inversion (handlers don't depend on concrete systems)\r\n- Lock-free SPSC ring buffer (proven pattern from CommandQueueBase)\r\n- V8 handle lifecycle management (established EntityScriptInterface pattern)\r\n- Error isolation (JavaScript errors don't crash C++, following EntityAPI pattern)\r\n\r\n### Project Structure (structure.md)\r\n\r\n**Module Organization**:\r\n```\r\nEngine/Code/Engine/Core/\r\n├── GenericCommand.hpp           # Command structure definition\r\n├── GenericCommandQueue.hpp      # Queue inheriting CommandQueueBase\r\n├── GenericCommandQueue.cpp      # Queue implementation\r\n├── GenericCommandExecutor.hpp   # Handler registry and execution\r\n├── GenericCommandExecutor.cpp   # Handler execution logic\r\n├── HandlerResult.hpp            # Handler return value structure\r\n└── HandlerResult.cpp            # V8 conversion implementation\r\n\r\nEngine/Code/Engine/Script/\r\n├── GenericCommandScriptInterface.hpp  # V8 bindings\r\n└── GenericCommandScriptInterface.cpp  # JavaScript API implementation\r\n\r\nRun/Data/Scripts/\r\n└── CommandQueue.js               # JavaScript API facade\r\n```\r\n\r\n**Naming Conventions**:\r\n- Classes: PascalCase (`GenericCommand`, `GenericCommandQueue`)\r\n- Files: PascalCase matching class names\r\n- Members: `m_` prefix (`m_commandQueue`, `m_handlers`)\r\n- Methods: PascalCase (`Submit`, `ExecuteCommand`)\r\n\r\n## Code Reuse Analysis\r\n\r\n### Existing Components to Leverage\r\n\r\n1. **CommandQueueBase Template** (`Engine/Core/CommandQueueBase.hpp`)\r\n   - **Reuse**: GenericCommandQueue inherits from `CommandQueueBase<GenericCommand>`\r\n   - **Benefits**: Lock-free SPSC implementation (~800 lines), atomic indices, cache-line separation\r\n   - **Pattern**: Same inheritance as CallbackQueue, RenderCommandQueue\r\n\r\n2. **CallbackQueue** (`Engine/Core/CallbackQueue.hpp`)\r\n   - **Reuse**: GenericCommand reuses CallbackQueue for async callback delivery\r\n   - **Benefits**: Proven Main→Worker thread communication, existing CallbackData structure\r\n   - **Integration**: GenericCommandExecutor enqueues to existing CallbackQueue after handler execution\r\n\r\n3. **EntityScriptInterface / CameraScriptInterface** (`Engine/Entity/`, `Engine/Renderer/`)\r\n   - **Reuse**: V8 binding patterns (ExtractVec3, ExtractCallback, ScriptMethodResult)\r\n   - **Benefits**: Established error handling, type conversion utilities\r\n   - **Pattern**: GenericCommandScriptInterface follows same IScriptableObject interface\r\n\r\n4. **V8Subsystem** (`Engine/Script/V8Subsystem.hpp`)\r\n   - **Reuse**: V8 isolate management, handle scopes, TryCatch blocks\r\n   - **Benefits**: Centralized V8 lifecycle, existing error logging\r\n   - **Integration**: GenericCommandScriptInterface registers with V8Subsystem\r\n\r\n### Integration Points\r\n\r\n1. **Existing CallbackQueue → JavaScript Worker**\r\n   - GenericCommand callbacks enqueued to **same CallbackQueue** used by EntityAPI/CameraAPI\r\n   - No new queue needed - reuses existing infrastructure\r\n   - JavaScript calls `executePendingCallbacks()` once per frame (existing pattern)\r\n\r\n2. **Existing ScriptInterface APIs**\r\n   - JavaScript handlers call `EntityAPI.createEntity()`, `CameraAPI.setPosition()`, etc.\r\n   - GenericCommand **composes** existing APIs, doesn't replace them\r\n   - Handlers act as workflow orchestrators\r\n\r\n3. **Existing V8 Type Converters**\r\n   - HandlerResult uses EntityScriptInterface's `ExtractVec3`, `ExtractRgba8` patterns\r\n   - Payload extraction reuses existing V8→C++ type conversion utilities\r\n   - Error handling follows EntityScriptInterface's ScriptMethodResult pattern\r\n\r\n## Architecture\r\n\r\n### High-Level System Design\r\n\r\n```mermaid\r\ngraph TD\r\n    A[JavaScript Worker Thread] -->|submit| B[GenericCommandScriptInterface]\r\n    B -->|Submit| C[GenericCommandQueue]\r\n    C -->|inherits| D[CommandQueueBase template]\r\n\r\n    E[Main Thread App::Update] -->|ConsumeAll| C\r\n    E --> F[GenericCommandExecutor]\r\n    F -->|GetHandler| G[Handler Registry]\r\n    G -->|C++ Handler| H[Direct C++ Systems]\r\n    G -->|JS Handler| I[V8 Function Call]\r\n    I --> J[EntityAPI / CameraAPI]\r\n\r\n    F -->|result| K{Callback?}\r\n    K -->|yes| L[CallbackQueue]\r\n    L -->|dequeue| A\r\n\r\n    style D fill:#e1f5e1\r\n    style L fill:#ffe6e6\r\n    style J fill:#e3f2fd\r\n```\r\n\r\n### Modular Design Principles\r\n\r\n**Single File Responsibility**:\r\n- `GenericCommand.hpp` - **Only** command structure definition (payload, callback, metadata)\r\n- `GenericCommandQueue.hpp` - **Only** queue operations (Submit, ConsumeAll inheritance)\r\n- `GenericCommandExecutor.hpp` - **Only** handler registry and execution logic\r\n- `HandlerResult.hpp` - **Only** handler return value structure\r\n- `GenericCommandScriptInterface.hpp` - **Only** V8 bindings (JavaScript↔C++ boundary)\r\n\r\n**Component Isolation**:\r\n- Queue doesn't know about handlers (just stores commands)\r\n- Executor doesn't know about queue (receives commands via lambda)\r\n- ScriptInterface doesn't know about executor (just submits to queue)\r\n- Handlers don't know about each other (registry pattern)\r\n\r\n**Service Layer Separation**:\r\n- **Data Layer**: GenericCommand (POD struct with V8 handles)\r\n- **Queue Layer**: GenericCommandQueue (lock-free transport)\r\n- **Execution Layer**: GenericCommandExecutor (handler dispatch)\r\n- **Presentation Layer**: GenericCommandScriptInterface (JavaScript API)\r\n\r\n## Components and Interfaces\r\n\r\n### Component 1: GenericCommand (Data Structure)\r\n\r\n**Purpose**: Encapsulate command data with optional callback support\r\n\r\n**Structure**:\r\n```cpp\r\nstruct GenericCommand {\r\n    String type;                              // Command type (e.g., \"SpawnEntity\")\r\n    v8::Persistent<v8::Object> payload;       // JavaScript object payload\r\n    String agentId;                           // Agent identifier for tracking\r\n    uint64_t timestamp;                       // Submission timestamp (milliseconds)\r\n\r\n    // Optional async callback support\r\n    CallbackID callbackId;                    // 0 if no callback, else unique ID\r\n    v8::Persistent<v8::Function> callback;    // JavaScript callback function (if provided)\r\n\r\n    // Lifecycle management\r\n    GenericCommand();                         // Default constructor\r\n    ~GenericCommand();                        // Destructor (disposes V8 handles)\r\n    GenericCommand(GenericCommand const&);    // Copy constructor (V8 handle copy)\r\n    GenericCommand& operator=(GenericCommand const&); // Assignment (V8 handle copy)\r\n};\r\n```\r\n\r\n**Interfaces**: None (POD-like struct with V8 handle management)\r\n\r\n**Dependencies**:\r\n- V8 API (`v8::Persistent`, `v8::Object`, `v8::Function`)\r\n- Core utilities (String type alias, CallbackID type)\r\n\r\n**Reuses**:\r\n- CallbackID type from EntityAPI/CameraAPI\r\n- V8 Persistent handle pattern from EntityScriptInterface\r\n\r\n### Component 2: GenericCommandQueue (Transport Layer)\r\n\r\n**Purpose**: Lock-free SPSC queue for command transport (JavaScript→Main thread)\r\n\r\n**Interfaces**:\r\n```cpp\r\nclass GenericCommandQueue : public CommandQueueBase<GenericCommand> {\r\npublic:\r\n    explicit GenericCommandQueue(size_t capacity = DEFAULT_CAPACITY);\r\n    ~GenericCommandQueue();\r\n\r\n    // Inherited from CommandQueueBase:\r\n    // bool Submit(GenericCommand const& command);\r\n    // template<typename F> void ConsumeAll(F&& processor);\r\n    // size_t GetApproximateSize() const;\r\n    // bool IsEmpty() const;\r\n    // bool IsFull() const;\r\n\r\nprotected:\r\n    // Optional hooks (override for logging)\r\n    void OnSubmit(GenericCommand const& cmd) override;\r\n    void OnQueueFull() override;\r\n};\r\n```\r\n\r\n**Dependencies**:\r\n- CommandQueueBase template (inheritance)\r\n- GenericCommand structure\r\n\r\n**Reuses**:\r\n- **100% reuses CommandQueueBase implementation** (~800 lines of lock-free code)\r\n- Same pattern as CallbackQueue, RenderCommandQueue\r\n\r\n**Design Rationale**:\r\n- Capacity: 500 commands (200 KB memory, ~0.5 seconds at 1000 commands/sec)\r\n- Lock-free: No mutexes, < 10µs submission latency\r\n- SPSC: Single JavaScript worker submits, single main thread consumes\r\n\r\n### Component 3: GenericCommandExecutor (Execution Layer)\r\n\r\n**Purpose**: Handler registry and command execution with callback support\r\n\r\n**Interfaces**:\r\n```cpp\r\nclass GenericCommandExecutor {\r\npublic:\r\n    explicit GenericCommandExecutor(CallbackQueue* callbackQueue,\r\n                                    ScriptSubsystem* scriptSubsystem);\r\n    ~GenericCommandExecutor();\r\n\r\n    // Handler registration\r\n    using HandlerFunc = std::function<HandlerResult(v8::Local<v8::Object> payload)>;\r\n    void RegisterHandler(String const& commandType, HandlerFunc handler);\r\n    void UnregisterHandler(String const& commandType);\r\n    bool HasHandler(String const& commandType) const;\r\n    std::vector<String> GetRegisteredTypes() const;\r\n\r\n    // Command execution\r\n    void ExecuteCommand(GenericCommand const& cmd);\r\n\r\n    // Callback management\r\n    CallbackID GenerateCallbackID();\r\n    void RegisterCallback(CallbackID callbackId, v8::Persistent<v8::Function> callback);\r\n\r\nprivate:\r\n    std::unordered_map<String, HandlerFunc> m_handlers;\r\n    CallbackQueue* m_callbackQueue;            // Reuses existing CallbackQueue\r\n    ScriptSubsystem* m_scriptSubsystem;        // For V8 context access\r\n    uint64_t m_nextCallbackId = 1;\r\n    std::mutex m_handlerMutex;                 // Thread-safe handler registration\r\n    std::unordered_map<CallbackID, v8::Persistent<v8::Function>> m_pendingCallbacks;\r\n};\r\n```\r\n\r\n**Dependencies**:\r\n- HandlerResult structure\r\n- CallbackQueue (existing)\r\n- ScriptSubsystem (existing)\r\n\r\n**Reuses**:\r\n- CallbackQueue for async result delivery\r\n- ScriptSubsystem for V8 context and error handling\r\n- Handler registry pattern (similar to ScriptSubsystem's method registry)\r\n\r\n**Design Rationale**:\r\n- Handler mutex: Allows safe registration from hot-reload or runtime\r\n- Callback tracking: Same pattern as EntityAPI's m_pendingCallbacks\r\n- HandlerFunc signature: Returns HandlerResult for structured return values\r\n\r\n### Component 4: HandlerResult (Return Value Structure)\r\n\r\n**Purpose**: Structured return values from handlers to support callbacks\r\n\r\n**Structure**:\r\n```cpp\r\nstruct HandlerResult {\r\n    std::unordered_map<String, std::any> data;  // Result data (flexible key-value)\r\n    String error;                                // Empty = success, non-empty = error\r\n\r\n    // Factory methods\r\n    static HandlerResult Success(std::unordered_map<String, std::any> resultData);\r\n    static HandlerResult Error(String errorMessage);\r\n\r\n    // V8 conversion\r\n    v8::Local<v8::Object> toV8Object(v8::Isolate* isolate) const;\r\n\r\n    // Convenience accessors\r\n    bool isSuccess() const { return error.empty(); }\r\n    bool hasData(String const& key) const { return data.count(key) > 0; }\r\n};\r\n```\r\n\r\n**Interfaces**:\r\n- Factory methods for creating success/error results\r\n- V8 conversion for callback delivery\r\n\r\n**Dependencies**:\r\n- V8 API for object creation\r\n- std::any for flexible data types\r\n\r\n**Reuses**:\r\n- EntityScriptInterface's error handling pattern (success/error distinction)\r\n- V8 object conversion patterns from existing ScriptInterfaces\r\n\r\n**Design Rationale**:\r\n- std::any: Type-erased values (int, float, string, EntityID, etc.)\r\n- toV8Object: Converts C++ map to JavaScript object for callback\r\n- Error string: Human-readable error messages for JavaScript debugging\r\n\r\n### Component 5: GenericCommandScriptInterface (JavaScript Binding Layer)\r\n\r\n**Purpose**: V8 bindings for JavaScript CommandQueue API\r\n\r\n**Interfaces**:\r\n```cpp\r\nclass GenericCommandScriptInterface : public IScriptableObject {\r\npublic:\r\n    explicit GenericCommandScriptInterface(GenericCommandQueue* queue,\r\n                                           GenericCommandExecutor* executor);\r\n    ~GenericCommandScriptInterface();\r\n\r\n    // IScriptableObject interface\r\n    void InitializeMethodRegistry() override;\r\n    ScriptMethodResult CallMethod(String const& methodName,\r\n                                  v8::FunctionCallbackInfo<v8::Value> const& args) override;\r\n    std::vector<String> GetAvailableMethods() const override;\r\n\r\nprivate:\r\n    // JavaScript methods\r\n    ScriptMethodResult ExecuteSubmit(v8::FunctionCallbackInfo<v8::Value> const& args);\r\n    ScriptMethodResult ExecuteRegisterHandler(v8::FunctionCallbackInfo<v8::Value> const& args);\r\n    ScriptMethodResult ExecuteUnregisterHandler(v8::FunctionCallbackInfo<v8::Value> const& args);\r\n    ScriptMethodResult ExecuteGetRegisteredTypes(v8::FunctionCallbackInfo<v8::Value> const& args);\r\n    ScriptMethodResult ExecuteExecutePendingCallbacks(v8::FunctionCallbackInfo<v8::Value> const& args);\r\n\r\n    // Helper methods (reuses EntityScriptInterface patterns)\r\n    v8::Local<v8::Object> ExtractPayload(v8::FunctionCallbackInfo<v8::Value> const& args, int index);\r\n    v8::Persistent<v8::Function> ExtractCallback(v8::FunctionCallbackInfo<v8::Value> const& args, int index);\r\n\r\n    GenericCommandQueue* m_commandQueue;\r\n    GenericCommandExecutor* m_executor;\r\n};\r\n```\r\n\r\n**Dependencies**:\r\n- IScriptableObject interface (existing)\r\n- GenericCommandQueue, GenericCommandExecutor\r\n- V8 API\r\n\r\n**Reuses**:\r\n- IScriptableObject interface (same as EntityScriptInterface)\r\n- ScriptMethodResult pattern for error handling\r\n- ExtractCallback pattern from EntityScriptInterface\r\n\r\n**Design Rationale**:\r\n- Follows exact pattern of EntityScriptInterface for consistency\r\n- ExecuteSubmit: Validates args, creates GenericCommand, submits to queue\r\n- ExecutePendingCallbacks: Dequeues from CallbackQueue, executes JavaScript callbacks\r\n\r\n## Data Models\r\n\r\n### GenericCommand Structure\r\n\r\n```cpp\r\nstruct GenericCommand {\r\n    // Command identification\r\n    String type;                              // \"SpawnEntity\", \"LoadResource\", etc.\r\n    String agentId;                           // \"planner-agent\", \"ui-agent\", etc.\r\n    uint64_t timestamp;                       // Milliseconds since epoch\r\n\r\n    // Command payload (flexible JavaScript object)\r\n    v8::Persistent<v8::Object> payload;       // {position: {x:5, y:0, z:3}, prefabName: \"Enemy\"}\r\n\r\n    // Optional async callback\r\n    CallbackID callbackId;                    // 0 = no callback, else unique ID\r\n    v8::Persistent<v8::Function> callback;    // JavaScript function (if provided)\r\n};\r\n\r\n// Size estimate: ~400 bytes per command\r\n// - String type: ~24 bytes\r\n// - String agentId: ~24 bytes\r\n// - uint64_t timestamp: 8 bytes\r\n// - v8::Persistent<v8::Object>: ~64 bytes (pointer + metadata)\r\n// - CallbackID: 8 bytes\r\n// - v8::Persistent<v8::Function>: ~64 bytes (pointer + metadata)\r\n// - Padding: ~208 bytes\r\n```\r\n\r\n### HandlerResult Structure\r\n\r\n```cpp\r\nstruct HandlerResult {\r\n    // Result data (flexible key-value map)\r\n    std::unordered_map<String, std::any> data;  // {\"entityId\": 12345, \"health\": 100}\r\n\r\n    // Error status (empty = success)\r\n    String error;                                // \"\" or \"Entity creation failed: invalid prefab\"\r\n};\r\n\r\n// Example usage:\r\n// Success: HandlerResult::Success({{\"entityId\", EntityID(12345)}, {\"health\", 100}})\r\n// Error: HandlerResult::Error(\"Entity creation failed: invalid prefab\")\r\n```\r\n\r\n### CallbackData Structure (Reused from Existing)\r\n\r\n```cpp\r\nstruct CallbackData {\r\n    uint64_t callbackId;      // Matches GenericCommand.callbackId\r\n    uint64_t resultId;        // Entity/Camera/Resource ID (if applicable)\r\n    std::string errorMessage; // Empty = success, non-empty = error\r\n    CallbackType type;        // ENTITY_CREATED, CAMERA_CREATED, GENERIC\r\n};\r\n\r\n// GenericCommand extends CallbackType enum:\r\nenum class CallbackType : uint8_t {\r\n    ENTITY_CREATED,\r\n    CAMERA_CREATED,\r\n    RESOURCE_LOADED,\r\n    GENERIC             // New: for GenericCommand callbacks\r\n};\r\n```\r\n\r\n## Error Handling\r\n\r\n### Error Scenarios\r\n\r\n1. **Queue Full (Backpressure)**\r\n   - **Handling**: `GenericCommandQueue::Submit()` returns false, logs warning\r\n   - **User Impact**: Command dropped, no callback executed\r\n   - **Recovery**: AI agent receives false return value, can retry or log error\r\n\r\n2. **No Handler Registered**\r\n   - **Handling**: `GenericCommandExecutor::ExecuteCommand()` logs warning, skips command\r\n   - **User Impact**: Command silently ignored (no crash)\r\n   - **Recovery**: If callback provided, enqueue error callback: \"No handler registered for command type 'Foo'\"\r\n\r\n3. **Handler Throws Exception**\r\n   - **Handling**: `GenericCommandExecutor::ExecuteCommand()` catches C++ exceptions in try-catch\r\n   - **User Impact**: Error logged, other commands continue processing\r\n   - **Recovery**: If callback provided, enqueue error callback with exception message\r\n\r\n4. **JavaScript Handler Throws Error**\r\n   - **Handling**: V8 TryCatch block in `GenericCommandExecutor`, error logged to console\r\n   - **User Impact**: JavaScript error logged, C++ continues\r\n   - **Recovery**: If callback provided, enqueue error callback with JavaScript error message\r\n\r\n5. **V8 Handle Lifecycle Error**\r\n   - **Handling**: V8 Persistent handles disposed in GenericCommand destructor\r\n   - **User Impact**: Memory leak prevented\r\n   - **Recovery**: N/A (automatic cleanup via RAII)\r\n\r\n6. **CallbackQueue Full**\r\n   - **Handling**: CallbackQueue::Enqueue() returns false, GenericCommandExecutor logs warning\r\n   - **User Impact**: Callback dropped, JavaScript never receives result\r\n   - **Recovery**: AI agent should implement timeout for callback execution\r\n\r\n7. **Invalid Payload Type**\r\n   - **Handling**: Handler attempts to extract data, std::any throws bad_any_cast\r\n   - **User Impact**: Handler catches exception, returns HandlerResult::Error()\r\n   - **Recovery**: Error callback delivered to JavaScript with descriptive message\r\n\r\n## Testing Strategy\r\n\r\n### Unit Testing\r\n\r\n**CommandQueueBase Inheritance**:\r\n- Test GenericCommandQueue::Submit() with full queue (backpressure)\r\n- Test GenericCommandQueue::ConsumeAll() with empty queue\r\n- Test atomic counter correctness (GetTotalSubmitted/Consumed)\r\n\r\n**Handler Registry**:\r\n- Test GenericCommandExecutor::RegisterHandler() with duplicate types (overwrites)\r\n- Test GenericCommandExecutor::UnregisterHandler() with unknown type (no crash)\r\n- Test GenericCommandExecutor::ExecuteCommand() with unregistered type (logs warning)\r\n\r\n**HandlerResult Conversion**:\r\n- Test HandlerResult::toV8Object() with various data types (int, float, string, EntityID)\r\n- Test HandlerResult::toV8Object() with nested objects\r\n- Test HandlerResult::toV8Object() with error status (JavaScript receives error field)\r\n\r\n**V8 Handle Lifecycle**:\r\n- Test GenericCommand copy constructor (V8 handle refcount incremented)\r\n- Test GenericCommand destructor (V8 handles disposed, no memory leak)\r\n- Test V8 garbage collection during command execution (payload remains valid)\r\n\r\n### Integration Testing\r\n\r\n**JavaScript → C++ Command Flow**:\r\n- Test CommandQueue.submit() from JavaScript worker thread\r\n- Test GenericCommandQueue::ConsumeAll() on main thread\r\n- Test handler execution with EntityAPI/CameraAPI calls\r\n- Verify no race conditions (V8 isolate lock acquired correctly)\r\n\r\n**Async Callback Flow**:\r\n- Test command submission with callback function\r\n- Test CallbackQueue enqueue after handler completion\r\n- Test JavaScript executePendingCallbacks() retrieves result\r\n- Verify callback receives correct result data (entityId, health, etc.)\r\n\r\n**Hot-Reload Support**:\r\n- Test handler re-registration after JavaScript file reload\r\n- Verify old handlers replaced atomically\r\n- Test in-flight commands execute with old handler (no mid-execution replacement)\r\n\r\n**Error Propagation**:\r\n- Test JavaScript handler throwing error (V8 TryCatch catches)\r\n- Test C++ handler throwing exception (std::exception caught)\r\n- Verify error callbacks delivered to JavaScript\r\n- Verify C++ continues processing after error\r\n\r\n### End-to-End Testing\r\n\r\n**AI Agent Workflow**:\r\n1. AI agent registers JavaScript handler for \"SpawnWave\"\r\n2. AI agent submits \"SpawnWave\" command with callback\r\n3. Main thread executes handler (calls EntityAPI.createEntity() 10 times)\r\n4. Handler returns success result with entity IDs\r\n5. Callback enqueued to CallbackQueue\r\n6. JavaScript worker receives callback with entity IDs\r\n7. AI agent logs success\r\n\r\n**Performance Benchmarks**:\r\n- Submit 1000 commands/frame for 60 frames (no drops)\r\n- Measure submission latency (< 10µs)\r\n- Measure handler execution time (< 1ms for 100 commands)\r\n- Measure callback delivery latency (< 5µs per callback)\r\n- Verify no memory leaks after 10,000 commands (V8 handles disposed)\r\n\r\n**Thread Safety Stress Test**:\r\n- Run 10 JavaScript workers submitting commands concurrently (mutex protects handler registry)\r\n- Verify queue remains consistent (no corruption)\r\n- Verify callbacks delivered to correct worker (callbackId matching)\r\n\r\n## Implementation Phases\r\n\r\n### Phase 1: Core GenericCommand Infrastructure (Week 1)\r\n\r\n**Tasks**:\r\n1. Create GenericCommand.hpp with structure definition\r\n2. Implement GenericCommandQueue inheriting CommandQueueBase\r\n3. Implement HandlerResult structure with V8 conversion\r\n4. Write unit tests for queue and result conversion\r\n\r\n**Deliverables**:\r\n- GenericCommand.hpp, GenericCommandQueue.hpp/cpp\r\n- HandlerResult.hpp/cpp\r\n- Unit tests passing (queue operations, result conversion)\r\n\r\n### Phase 2: Handler Executor and Registry (Week 1-2)\r\n\r\n**Tasks**:\r\n1. Implement GenericCommandExecutor with handler registry\r\n2. Add handler registration/unregistration methods\r\n3. Implement ExecuteCommand with try-catch error handling\r\n4. Integrate with CallbackQueue for async callbacks\r\n5. Write unit tests for handler execution\r\n\r\n**Deliverables**:\r\n- GenericCommandExecutor.hpp/cpp\r\n- Unit tests passing (handler registry, execution, callbacks)\r\n\r\n### Phase 3: JavaScript Bindings (Week 2)\r\n\r\n**Tasks**:\r\n1. Implement GenericCommandScriptInterface following EntityScriptInterface pattern\r\n2. Add ExecuteSubmit method with payload extraction\r\n3. Add ExecuteRegisterHandler for JavaScript handler registration\r\n4. Add ExecutePendingCallbacks for callback delivery\r\n5. Create CommandQueue.js facade\r\n6. Write integration tests\r\n\r\n**Deliverables**:\r\n- GenericCommandScriptInterface.hpp/cpp\r\n- CommandQueue.js\r\n- Integration tests passing (JavaScript → C++ → JavaScript callback)\r\n\r\n### Phase 4: Hot-Reload and Error Handling (Week 2-3)\r\n\r\n**Tasks**:\r\n1. Add atomic handler replacement for hot-reload\r\n2. Implement comprehensive error handling (queue full, no handler, exceptions)\r\n3. Add error callback delivery\r\n4. Write error handling tests\r\n\r\n**Deliverables**:\r\n- Hot-reload support\r\n- Error handling tests passing\r\n\r\n### Phase 5: Performance Optimization and Documentation (Week 3)\r\n\r\n**Tasks**:\r\n1. Profile submission latency and handler execution\r\n2. Optimize V8 handle usage (minimize copies)\r\n3. Add performance monitoring (statistics, logging)\r\n4. Write comprehensive documentation\r\n5. Create example AI agent workflows\r\n\r\n**Deliverables**:\r\n- Performance benchmarks meeting requirements (< 10µs submission, 1000+ commands/frame)\r\n- Documentation (README, API reference, examples)\r\n\r\n## Risks and Mitigations\r\n\r\n### Risk 1: V8 Handle Lifecycle Complexity\r\n\r\n**Risk**: Incorrect V8 Persistent handle management could cause memory leaks or crashes\r\n\r\n**Mitigation**:\r\n- Follow EntityScriptInterface patterns exactly (proven implementation)\r\n- Use RAII pattern (dispose in destructor)\r\n- Write comprehensive unit tests with V8 GC triggered\r\n- Profile memory usage with 10,000 commands\r\n\r\n### Risk 2: CallbackQueue Capacity Exceeded\r\n\r\n**Risk**: High command rate with callbacks could fill CallbackQueue (100 capacity)\r\n\r\n**Mitigation**:\r\n- Log backpressure warnings when CallbackQueue full\r\n- AI agents implement callback timeouts (drop commands that don't complete)\r\n- Consider increasing CallbackQueue capacity if needed (configurable)\r\n\r\n### Risk 3: Handler Performance Bottleneck\r\n\r\n**Risk**: Complex JavaScript handlers could block main thread (> 1ms)\r\n\r\n**Mitigation**:\r\n- Document handler performance guidelines (< 100µs per handler)\r\n- Add performance monitoring (log handlers exceeding threshold)\r\n- Recommend batching operations in handlers\r\n- Provide profiling tools for AI agent developers\r\n\r\n### Risk 4: Thread Safety with Hot-Reload\r\n\r\n**Risk**: Handler replacement during command execution could cause crashes\r\n\r\n**Mitigation**:\r\n- Use mutex-protected handler registry\r\n- Handlers fetched once at command execution start (atomic read)\r\n- Old handlers remain valid until execution completes (no mid-execution replacement)\r\n- Write stress tests with concurrent hot-reloads\r\n\r\n### Risk 5: Backward Compatibility with EntityAPI/CameraAPI\r\n\r\n**Risk**: GenericCommand could interfere with existing typed command patterns\r\n\r\n**Mitigation**:\r\n- GenericCommand uses separate queue (no RenderCommandQueue interaction)\r\n- CallbackQueue shared but capacity sufficient for both systems\r\n- Phase 1: Coexistence mode (both systems active)\r\n- Gradual migration only after proving stability\r\n\r\n## Performance Characteristics\r\n\r\n### Target Metrics (from Requirements)\r\n\r\n- **Submission Latency**: < 10µs per command\r\n- **Execution Throughput**: 1000+ commands/frame (60 FPS)\r\n- **Callback Overhead**: < 5µs per callback enqueue\r\n- **Memory Overhead**: 400 bytes/command, 200 KB queue capacity\r\n- **Handler Lookup**: O(1) hash map, < 0.1µs\r\n\r\n### Optimization Strategies\r\n\r\n1. **Lock-Free Queue**: CommandQueueBase eliminates mutex overhead\r\n2. **Cache-Line Separation**: Prevents false sharing between producer/consumer\r\n3. **V8 Handle Reuse**: Minimize Persistent handle copies\r\n4. **Batch Callback Delivery**: ExecutePendingCallbacks processes all callbacks at once\r\n5. **Handler Inlining**: std::function allows compiler optimization\r\n\r\n### Monitoring and Profiling\r\n\r\n- Log submission rate (commands/second per agent)\r\n- Log queue depth (warn at 80% capacity)\r\n- Log handler execution time (warn at > 100µs)\r\n- Log callback delivery rate (callbacks/second)\r\n- Expose statistics via JavaScript API (CommandQueue.getStatistics())\r\n\r\n## Future Extensions (Phase 2+)\r\n\r\n### Command Priority System\r\n\r\nAdd priority field to GenericCommand, use priority queue for execution order.\r\n\r\n### Dynamic Capacity Expansion\r\n\r\nResize queue when 80% full (requires lock-free resize algorithm or brief mutex).\r\n\r\n### Command Batching\r\n\r\nAllow multiple commands in single Submit call (reduce queue overhead).\r\n\r\n### Handler Composition\r\n\r\nRegister handler chains (middleware pattern for preprocessing/postprocessing).\r\n\r\n### Performance Dashboard\r\n\r\nReal-time visualization of command flow, handler execution time, callback latency.\r\n\r\n---\r\n\r\n**Document Status**: Complete | **Version**: 1.0 | **Date**: 2026-01-18\r\n",
  "fileStats": {
    "size": 27842,
    "lines": 700,
    "lastModified": "2026-01-18T15:32:44.107Z"
  },
  "comments": []
}